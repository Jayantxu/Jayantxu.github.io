<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>rJUI&amp;vJUI✨✨✨</title>
      <link href="/2021/06/01/2021/rJUI&amp;vJUI/"/>
      <url>/2021/06/01/2021/rJUI&amp;vJUI/</url>
      
        <content type="html"><![CDATA[<h2 id="rJUI"><a href="#rJUI" class="headerlink" title="rJUI"></a>rJUI</h2><p><em>React</em>编写的个人UI组件库，GitHub地址：<a href="https://github.com/Jayantxu/rJUI" target="_blank" rel="noopener">rJUI地址</a>，刚开始接触使用<em>React</em>，因此还有很多不足，目前也还在利用工作之余的时间在迭代中💪…</p><p>整体风格方面，会借鉴一下优秀的开源组件库像ant-design等。</p><p><strong>rJUI</strong>官网使用是使用nextJS进行搭建的，并且导出为全静态的页面，挂载在hexo的博客上的，部分资源使用的是<em>jsdelivr</em>cdn。可能会有访问比较慢的问题。</p><p><em>链接：</em> <a href="/rJUI">rJUI介绍</a></p><h2 id="vJUI"><a href="#vJUI" class="headerlink" title="vJUI"></a>vJUI</h2><p>进行中…<br><!-- [vJUI](/vJUI) --></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大量/批量数据优化总结</title>
      <link href="/2021/05/26/2021/%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E7%BB%98%E5%88%B6%E5%BF%83%E5%BE%97/"/>
      <url>/2021/05/26/2021/%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E7%BB%98%E5%88%B6%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<p>还没开始写，就感觉真的是将要呕心沥血（拖拖拉拉）的一篇，其实写东西真的好不容易😂，虽然有时候，心灵深处一扑通，特别想总结某一样东西，但是总是顶不住拖延或者又被工作或者什么其他优先级更高的事给挤走了。</p><p>今天就总结一下，在日常开发中，面对Gis的数据渲染，大量或者批量所采用过的渲染策略🐱‍🏍</p><p>全文分了几个部分方式：</p><ol><li>简单粗暴，直接渲染；</li><li>视域内<code>diff</code>增量；</li><li>建立简易<code>LRU缓存队列</code>；</li><li>通用辅助-<code>Worker</code>及<code>setTimeout</code>协助分批渲染；</li><li>通用辅助-高层级隐藏</li><li>通用辅助-采用<code>tile</code>的方式缓存渲染</li></ol><p><em>以下的方法只是思路的描述，不包含具体方法的实现等部分</em></p><h4 id="一、简单粗暴"><a href="#一、简单粗暴" class="headerlink" title="一、简单粗暴"></a>一、简单粗暴</h4><p><img src="/2021/05/26/2021/批量数据绘制心得/GIF_1.gif" alt="NO1" title="NO1"></p><p>取到数据之后，组织为相应<code>API</code>格式之后，直接渲染，这种方式仅适合小量少量的数据点，并且缺点就是，<em>每次都会对整个图层进行删除，重绘</em>如果有重复的部分，那会浪费掉了一些不必要的性能开销。</p><h4 id="二、视域内的Diff渲染"><a href="#二、视域内的Diff渲染" class="headerlink" title="二、视域内的Diff渲染"></a>二、视域内的Diff渲染</h4><p>让我们回顾一下，对于第一种绘制，有没有什么更好的方式，毕竟每一次都要<em>删除，重绘</em>，有可能有不必要的地方。</p><p>可能读者也都有想到，我们可以对已经绘制过的数据进行一次存储，再下一次更新之前，做好对比，从而提取出<code>新增</code>、<code>删除</code>的部分。</p><p>并且，在窗口范围内，用户移动地图时，也不会在乎地图外究竟有什么数据，有什么<code>点</code>，因此我们只需要照顾好<code>视域</code>范围内的数据即可。</p><p>我们把上面的步骤简单梳理一下:</p><ol><li>按照<code>窗口视域</code>请求范围内的数据点。</li><li><code>提取点数据特征</code>，并做好存储，存储在哪因情况制宜。</li><li>若识别到有之前数据，则开始<code>diff</code>过程，筛选出<code>新增</code>、<code>删除</code>数据。</li><li>绘制。</li></ol><p>其实过程很简单，实现也很简单。</p><p>例如我们在<code>视域</code>内获取了一批点：</p><pre><code>&quot;DataTable&quot;: [    {        &quot;网络类型&quot;: &quot;4G&quot;,        &quot;覆盖类型&quot;: &quot;室外&quot;,        &quot;小区数&quot;: 2,        &quot;方向角&quot;: 350.0,        &quot;同覆盖标识&quot;: &quot;105662&quot;,        &quot;纬度&quot;: 26.649187,        &quot;经度&quot;: 106.625329,        &quot;高度&quot;: 12.0    },    {        &quot;网络类型&quot;: &quot;4G&quot;,        &quot;覆盖类型&quot;: &quot;室内&quot;,        &quot;小区数&quot;: 1,        &quot;方向角&quot;: null,        &quot;同覆盖标识&quot;: &quot;348321&quot;,        &quot;纬度&quot;: 26.653,        &quot;经度&quot;: 106.632,        &quot;高度&quot;: 0.0    },    // ...很多]</code></pre><p>我们需要去和后台同事沟通好他们的<code>主键</code>，或者是否是<code>组合主键</code>。并且在绘制之前，提取出来，将他们保存下来。</p><pre><code>[    &quot;105662&quot;,    &quot;348321&quot;,    // ...很多]</code></pre><p>之所以只保存主键，是因为我们除了绘制需要用到更多的信息，在我们<code>diff</code>的过程中，大部分信息都是没有用的，我们能有<code>足够的信息</code>标识这个点数据即可</p><p>再后面，用户拖动查看了周边其他情况，我们需要加载渲染新的数据的时候，有些点并不是完全会被移除<code>视域</code>，因此我们并不需要为此将它们删去。</p><p><code>diff</code>的方法及实现有很多，核心的想法就只是将<code>新旧数据</code>进行找不同，对这些不同的进行操作。</p><p>新请求的数据：<code>newArr = [...很多]</code>；<br>存储的移动前数据：<code>oldArr = [...很多]</code>；<br>新渲染的数据：<code>newRender = []</code>；<br>移除的渲染数据：<code>deleteRender = []</code></p><ol><li>我们遍历<code>newArr</code>，判断每一项的<code>主键</code>是否存在<code>oldArr</code>中：<ul><li>若存在，则证明，新旧数据点中都将绘制此点，并且此时旧图层中已经渲染了，我们不必要再对此点进行其他操作，不动即可。</li><li>若不存在，则证明其是将要新绘制的数据点，我们将它<code>push</code>进<code>newRender</code>中。</li></ul></li><li><p>我们遍历<code>oldArr</code>，判断每一项是否在<code>newArr</code>中存在：</p><ul><li>如果存在，则证明都是需要绘制，并且已经绘制了的点，我们不操作即可。</li><li>如果不存在，则证明此点在移动地图后，已经不存在<code>视域</code>内了，我们需要将它移除，因此我们应该将它<code>push</code>进行<code>deleteRender</code>中，等待移除。</li></ul></li><li><p>通过前两步，我们遍可以筛选出需要<code>新增</code>，<code>移除</code>的数据内容。我们再针对性的进行操作即可。</p></li></ol><p><em>左边的数据是存储在localStorage中的数据</em></p><p><img src="/2021/05/26/2021/批量数据绘制心得/GIF_2.gif" alt="NO2" title="NO2"></p><p>我们可以看到，那些没有被完全移除视域的点，我们没有进行到任何操作。</p><h4 id="三、建立简易LRU缓存队列"><a href="#三、建立简易LRU缓存队列" class="headerlink" title="三、建立简易LRU缓存队列"></a>三、建立简易LRU缓存队列</h4><p><strong>Q：</strong>对于上一种方式，其实还是有不足的地方，例如：如果我们每次稍微<code>足够大范围</code>移动gis，以致于所有的对比点都失效了，那不是相当于全部都要重新绘制了吗？</p><p>我们可以建立一个<code>缓存队列</code>，队列的特点是<code>先进先出</code>。</p><p>我们可以使用<code>Map</code>进行实现。<br>同时<code>Map</code>也可记录下索引值，nice🤳</p><pre><code>let lruMap = new Map();let maxSize = 5000;</code></pre><p>思路是这样的：</p><ol><li>我们每一次获取到数据，在渲染前遍历是否存在<code>map</code>中<ul><li>如果存在，我们将需要<code>delete</code>掉此数据。并且紧接<code>delete</code>后需要再次将其<code>set</code>进map中，成为新的一项。</li><li>如果不存在，我们需要判断一下此时<code>map</code>的大小<ul><li>如果此时<code>map.size &lt; maxSize</code>，则我们还有足够的空降<code>set</code>新数据进去即可。</li><li>如果此时<code>map.size = maxSize</code>，我们需要将第一个数据进行一个移除，毕竟它是最久没有更新的。</li></ul></li></ul></li></ol><p>大致的代码如下：</p><pre><code>if(computedMap.has(areaIdStr)) {    computedMap.delete(areaIdStr);    computedMap.set(areaIdStr, true);    return false;} else {    if(computedMap.size &gt; maxLen) {        let firstKey = computedMap.keys().next().value;        computedMap.delete(firstKey);        // 图层操作，移除mesh    }    computedMap.set(areaIdStr, true);    return true;}</code></pre><h4 id="四、Worker，setTimeout辅助"><a href="#四、Worker，setTimeout辅助" class="headerlink" title="四、Worker，setTimeout辅助"></a>四、Worker，setTimeout辅助</h4><ul><li>Worker<br>之所以要提到这，是因为，有时候大部分数据，从后台取回来的格式并不是完全是可以渲染的格式；<br>①、有时候需要跟指标，去匹配颜色等等<br>②、有时候要从不同地方读取数据从而组合成最终数据<br>③…等等</li></ul><p>因此在组合运算这些数据，组成合适的数据结构的过程中，习惯使用<code>Worker</code>开启多线程去处理，最终返回合适的结果集就好了。</p><p><img src="/2021/05/26/2021/批量数据绘制心得/GIF_3.gif" alt="Worker辅助计算座位经纬度的组合" title="NO3"></p><ul><li>setTimeout，有时候，还是需要渲染较多较复杂的数据的时候，我们可以使用来进行<code>数据切片</code>，例如渲染1000条数据，我们切片后，按照每次100条，分10次的模式，进行渲染，某种程度上也是减缓了处理的性能开销。</li></ul><p><img src="/2021/05/26/2021/批量数据绘制心得/GIF_4.gif" alt="setTimeout辅助，大范围的场景点切片渲染" title="NO4"></p><h4 id="五、大层级的自动隐藏"><a href="#五、大层级的自动隐藏" class="headerlink" title="五、大层级的自动隐藏"></a>五、大层级的自动隐藏</h4><p>其实大部分的项目，在缩放地图层级到某一个范围时，数据已经足够的小了。没必要再让用户去查看这些数据，我们可以在这些层级时做好隐藏的用户体验，同时，停止去请求新的数据，渲染新的数据。</p><p><img src="/2021/05/26/2021/批量数据绘制心得/GIF_5.gif" alt="层级缩小时，已经不需要去关心过于“小”的数据了" title="NO5"></p><p>或者，层级缩小的时候，对点进行一下汇聚重渲染。这样用户在高层级地图上，它们只需要关心基本的一些<code>数据特征</code>即可。</p><p>🐱‍🏍<br>🐱‍🏍<br>🐱‍🏍</p><p>over</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SKU商品属性组合实践</title>
      <link href="/2021/05/07/2021/SKU%E5%95%86%E5%93%81%E5%B1%9E%E6%80%A7%E7%BB%84%E5%90%88%E5%AE%9E%E8%B7%B5/"/>
      <url>/2021/05/07/2021/SKU%E5%95%86%E5%93%81%E5%B1%9E%E6%80%A7%E7%BB%84%E5%90%88%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h4 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h4><p>最近有一个内部购买页面有如下gif所示逻辑的业务需求。</p><p><img src="/2021/05/07/2021/SKU商品属性组合实践/GIF.gif" alt="“硬”处理" title="GIF"></p><p>最初拿到这个平台需求，感觉可能没有很麻烦，可能只是一下状态什么的处理，然后就简单用了固定“硬”处理，直接把所有逻辑写了一遍，后来发现还是<code>too young</code>🤦‍♂️…</p><p>后来真实的开始动手想优雅点实现了，发现其实有些不太好整，并且一开始也不知道要如何形容这个东西，只能搜索什么<code>购买商品</code>、<code>淘宝商品页</code>等等等，毕竟还是知道这个应该是电商业务会处理到的。</p><p>后来知道这个是叫做<code>SKU</code>，查阅记录一下</p><blockquote><p>存货单位（英语：stock keeping unit，SKU/ˌɛsˌkeɪˈjuː/）[1]，也翻译为库存单元，是一个会计学名词，定义为库存管理中的最小可用单元，例如纺织品中一个SKU通常表示规格、颜色、款式，而在连锁零售门店中有时称单品为一个SKU。最小库存管理单元可以区分不同商品销售的最小单元，是科学管理商品的采购、销售、物流和财务管理以及POS和MIS系统的数据统计的需求，通常对应一个管理信息系统的编码。（来自维基百科👉：<a href="https://zh.wikipedia.org/zh-hans/%E5%AD%98%E8%B4%A7%E5%8D%95%E4%BD%8D" target="_blank" rel="noopener">SKU</a> ）</p></blockquote><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p>一共有几种待选类型：<code>计费方式,付费类型,购买次数,购买时长,并发性能</code>；</p><p>每种类型各有以下选项（选项经过删减）：</p><ul><li>计费方式<ol><li>按量计费</li><li>按时计费</li></ol></li><li>付费类型<ol><li>预付费</li><li>后付费</li></ol></li><li>购买时长<ol><li>1个月</li><li>2个月</li><li>3个月</li><li>…</li><li>按实际使用时长计算</li></ol></li><li>购买次数<ol><li>100000</li><li>200000</li><li>…</li><li>按实际使用量计算</li></ol></li><li>并发性能<ol><li>10QPS</li><li>50QPS</li><li>100QPS</li><li>无限</li></ol></li></ul><p>好了，现在来分析一下这个需求<code>SKU</code>的一些更细致的部分。</p><ol><li>组合的库存无限，不需要组合判断是增加库存的判断，<strong>因此只需要进行商品组合的判断即可</strong>；</li><li>购买时长、购买次数分别对应的是计费方式中的按量计费、按时计费，即按量计费只可以选择购买次数，按时计费只能选择购买时长；</li><li>后付费与预付费则对应的是<em>按实际使用</em>与<em>具体值</em>，即<em>预付费</em>只能选择具体的<em>购买次数</em>或者<em>购买时长</em>，<em>后付费</em>则只能选择<em>按实际使用</em>；</li><li>组合金额等，通过后期接口后台同事查询，因此也减少了增加金额的组合判断；</li></ol><h4 id="需求实现"><a href="#需求实现" class="headerlink" title="需求实现"></a>需求实现</h4><p>前期数据，可以从后台拿到配置的类型选项以及存在的配置商品项：</p><ul><li>类型配置数据：</li></ul><pre><code>[    { title: &quot;计费方式&quot;, list: [        { &quot;id&quot;: 1, &quot;desc&quot;: &quot;按量计费&quot;, &quot;name&quot;: &quot;按量计费&quot; },        { &quot;id&quot;: 2, &quot;desc&quot;: &quot;按时计费&quot;, &quot;name&quot;: &quot;按时计费&quot; }      ]    },    { title: &quot;付费类型&quot;, list: [        { &quot;name&quot;: &quot;预付费&quot;, &quot;desc&quot;: &quot;预付费&quot;, &quot;id&quot;: 1 },        { &quot;name&quot;: &quot;后付费&quot;, &quot;desc&quot;: &quot;后付费&quot;, &quot;id&quot;: 2 }      ]     },    { title: &quot;购买次数&quot;, list: [        { &quot;id&quot;: 1, &quot;name&quot;: &quot;100000&quot;, &quot;desc&quot;: &quot;10W&quot; },        { &quot;id&quot;: 2, &quot;name&quot;: &quot;200000&quot;, &quot;desc&quot;: &quot;20W&quot; },        { &quot;id&quot;: 3, &quot;name&quot;: &quot;按实际使用量计算&quot;, &quot;desc&quot;: &quot;按实际使用量计算&quot; }      ]     },    { title: &quot;购买时长&quot;, list: [        { &quot;desc&quot;: &quot;1个月&quot;, &quot;name&quot;: &quot;1个月&quot;, &quot;id&quot;: 1 },        { &quot;desc&quot;: &quot;2个月&quot;, &quot;name&quot;: &quot;2个月&quot;, &quot;id&quot;: 2 },        { &quot;desc&quot;: &quot;3个月&quot;, &quot;name&quot;: &quot;3个月&quot;, &quot;id&quot;: 3 },        { &quot;id&quot;: 4, &quot;name&quot;: &quot;按实际使用时长计算&quot;, &quot;desc&quot;: &quot;按实际使用时长计算&quot; }      ]    },    { title: &quot;并发性能&quot;, list: [        { &quot;id&quot;: 1, &quot;name&quot;: &quot;10 QPS&quot;, &quot;desc&quot;: &quot;10 QPS&quot; },        { &quot;id&quot;: 2, &quot;name&quot;: &quot;50 QPS&quot;, &quot;desc&quot;: &quot;50 QPS&quot; },        { &quot;id&quot;: 3, &quot;name&quot;: &quot;100 QPS&quot;, &quot;desc&quot;: &quot;100 QPS&quot; },        { &quot;id&quot;: 4, &quot;name&quot;: &quot;无限&quot;, &quot;desc&quot;: &quot;无限&quot; }      ]    },]</code></pre><ul><li>商品组合数据：</li></ul><pre><code>skuList = [    { id: 1, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按量计费&quot;, &quot;付费类型&quot;: &quot;预付费&quot;, &quot;购买次数&quot;: &quot;100000&quot;, &quot;购买时长&quot;: &quot;&quot;, &quot;并发性能&quot;: &quot;10 QPS&quot; },    { id: 2, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按量计费&quot;, &quot;付费类型&quot;: &quot;预付费&quot;, &quot;购买次数&quot;: &quot;200000&quot;, &quot;购买时长&quot;: &quot;&quot;, &quot;并发性能&quot;: &quot;10 QPS&quot; },    { id: 3, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按量计费&quot;, &quot;付费类型&quot;: &quot;预付费&quot;, &quot;购买次数&quot;: &quot;100000&quot;, &quot;购买时长&quot;: &quot;&quot;, &quot;并发性能&quot;: &quot;50 QPS&quot; },    { id: 4, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按量计费&quot;, &quot;付费类型&quot;: &quot;预付费&quot;, &quot;购买次数&quot;: &quot;200000&quot;, &quot;购买时长&quot;: &quot;&quot;, &quot;并发性能&quot;: &quot;50 QPS&quot; },    { id: 5, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按量计费&quot;, &quot;付费类型&quot;: &quot;预付费&quot;, &quot;购买次数&quot;: &quot;100000&quot;, &quot;购买时长&quot;: &quot;&quot;, &quot;并发性能&quot;: &quot;100 QPS&quot; },    { id: 6, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按量计费&quot;, &quot;付费类型&quot;: &quot;预付费&quot;, &quot;购买次数&quot;: &quot;200000&quot;, &quot;购买时长&quot;: &quot;&quot;, &quot;并发性能&quot;: &quot;100 QPS&quot; },    { id: 7, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按量计费&quot;, &quot;付费类型&quot;: &quot;预付费&quot;, &quot;购买次数&quot;: &quot;100000&quot;, &quot;购买时长&quot;: &quot;&quot;, &quot;并发性能&quot;: &quot;无限&quot; },    { id: 8, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按量计费&quot;, &quot;付费类型&quot;: &quot;预付费&quot;, &quot;购买次数&quot;: &quot;200000&quot;, &quot;购买时长&quot;: &quot;&quot;, &quot;并发性能&quot;: &quot;无限&quot; },    { id: 9, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按量计费&quot;, &quot;付费类型&quot;: &quot;后付费&quot;, &quot;购买次数&quot;: &quot;按实际使用量计算&quot;, &quot;购买时长&quot;: &quot;&quot;, &quot;并发性能&quot;: &quot;10 QPS&quot; },    { id: 10, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按量计费&quot;, &quot;付费类型&quot;: &quot;后付费&quot;, &quot;购买次数&quot;: &quot;按实际使用量计算&quot;, &quot;购买时长&quot;: &quot;&quot;, &quot;并发性能&quot;: &quot;50 QPS&quot; },    { id: 11, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按量计费&quot;, &quot;付费类型&quot;: &quot;后付费&quot;, &quot;购买次数&quot;: &quot;按实际使用量计算&quot;, &quot;购买时长&quot;: &quot;&quot;, &quot;并发性能&quot;: &quot;100 QPS&quot; },    { id: 12, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按量计费&quot;, &quot;付费类型&quot;: &quot;后付费&quot;, &quot;购买次数&quot;: &quot;按实际使用量计算&quot;, &quot;购买时长&quot;: &quot;&quot;, &quot;并发性能&quot;: &quot;无限&quot; },    { id: 13, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按时计费&quot;, &quot;付费类型&quot;: &quot;预付费&quot;, &quot;购买次数&quot;: &quot;&quot;, &quot;购买时长&quot;: &quot;1个月&quot;, &quot;并发性能&quot;: &quot;10 QPS&quot; },    { id: 14, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按时计费&quot;, &quot;付费类型&quot;: &quot;预付费&quot;, &quot;购买次数&quot;: &quot;&quot;, &quot;购买时长&quot;: &quot;1个月&quot;, &quot;并发性能&quot;: &quot;50 QPS&quot; },    { id: 15, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按时计费&quot;, &quot;付费类型&quot;: &quot;预付费&quot;, &quot;购买次数&quot;: &quot;&quot;, &quot;购买时长&quot;: &quot;1个月&quot;, &quot;并发性能&quot;: &quot;100 QPS&quot; },    { id: 16, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按时计费&quot;, &quot;付费类型&quot;: &quot;预付费&quot;, &quot;购买次数&quot;: &quot;&quot;, &quot;购买时长&quot;: &quot;1个月&quot;, &quot;并发性能&quot;: &quot;无限&quot; },    { id: 17, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按时计费&quot;, &quot;付费类型&quot;: &quot;预付费&quot;, &quot;购买次数&quot;: &quot;&quot;, &quot;购买时长&quot;: &quot;2个月&quot;, &quot;并发性能&quot;: &quot;10 QPS&quot; },    { id: 18, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按时计费&quot;, &quot;付费类型&quot;: &quot;预付费&quot;, &quot;购买次数&quot;: &quot;&quot;, &quot;购买时长&quot;: &quot;2个月&quot;, &quot;并发性能&quot;: &quot;50 QPS&quot; },    { id: 19, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按时计费&quot;, &quot;付费类型&quot;: &quot;预付费&quot;, &quot;购买次数&quot;: &quot;&quot;, &quot;购买时长&quot;: &quot;2个月&quot;, &quot;并发性能&quot;: &quot;100 QPS&quot; },    { id: 20, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按时计费&quot;, &quot;付费类型&quot;: &quot;预付费&quot;, &quot;购买次数&quot;: &quot;&quot;, &quot;购买时长&quot;: &quot;2个月&quot;, &quot;并发性能&quot;: &quot;无限&quot; },    { id: 21, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按时计费&quot;, &quot;付费类型&quot;: &quot;预付费&quot;, &quot;购买次数&quot;: &quot;&quot;, &quot;购买时长&quot;: &quot;3个月&quot;, &quot;并发性能&quot;: &quot;10 QPS&quot; },    { id: 22, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按时计费&quot;, &quot;付费类型&quot;: &quot;预付费&quot;, &quot;购买次数&quot;: &quot;&quot;, &quot;购买时长&quot;: &quot;3个月&quot;, &quot;并发性能&quot;: &quot;50 QPS&quot; },    { id: 23, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按时计费&quot;, &quot;付费类型&quot;: &quot;预付费&quot;, &quot;购买次数&quot;: &quot;&quot;, &quot;购买时长&quot;: &quot;3个月&quot;, &quot;并发性能&quot;: &quot;100 QPS&quot; },    { id: 24, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按时计费&quot;, &quot;付费类型&quot;: &quot;预付费&quot;, &quot;购买次数&quot;: &quot;&quot;, &quot;购买时长&quot;: &quot;3个月&quot;, &quot;并发性能&quot;: &quot;无限&quot; },    { id: 25, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按时计费&quot;, &quot;付费类型&quot;: &quot;后付费&quot;, &quot;购买次数&quot;: &quot;&quot;, &quot;购买时长&quot;: &quot;按实际使用时长计算&quot;, &quot;并发性能&quot;: &quot;10 QPS&quot; },    { id: 26, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按时计费&quot;, &quot;付费类型&quot;: &quot;后付费&quot;, &quot;购买次数&quot;: &quot;&quot;, &quot;购买时长&quot;: &quot;按实际使用时长计算&quot;, &quot;并发性能&quot;: &quot;50 QPS&quot; },    { id: 27, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按时计费&quot;, &quot;付费类型&quot;: &quot;后付费&quot;, &quot;购买次数&quot;: &quot;&quot;, &quot;购买时长&quot;: &quot;按实际使用时长计算&quot;, &quot;并发性能&quot;: &quot;100 QPS&quot; },    { id: 28, &quot;购买类型&quot;: &quot;创建实例&quot;, &quot;计费方式&quot;: &quot;按时计费&quot;, &quot;付费类型&quot;: &quot;后付费&quot;, &quot;购买次数&quot;: &quot;&quot;, &quot;购买时长&quot;: &quot;按实际使用时长计算&quot;, &quot;并发性能&quot;: &quot;无限&quot; },]</code></pre><p>因为在后台及关系型数据库中保存的配置数据，从后台拿到返回的组合形式即如此，Web端需要再进行加工处理。</p><h5 id="稀里糊涂-￥-🤒"><a href="#稀里糊涂-￥-🤒" class="headerlink" title="稀里糊涂@#￥@#🤒"></a>稀里糊涂@#￥@#🤒</h5><p>一开始，稀里糊涂的不知道为啥，想着将他们全部组合处理出来，简化一下数据：</p><pre><code>this.baseConfigInfo = [    { title: &quot;计费方式&quot;, list: [        { &quot;id&quot;: 1, &quot;desc&quot;: &quot;按量计费&quot;, &quot;name&quot;: &quot;按量计费&quot; },        { &quot;id&quot;: 2, &quot;desc&quot;: &quot;按时计费&quot;, &quot;name&quot;: &quot;按时计费&quot; }      ]    },    { title: &quot;付费类型&quot;, list: [        { &quot;name&quot;: &quot;预付费&quot;, &quot;desc&quot;: &quot;预付费&quot;, &quot;id&quot;: 1 },        { &quot;name&quot;: &quot;后付费&quot;, &quot;desc&quot;: &quot;后付费&quot;, &quot;id&quot;: 2 }      ]     },];</code></pre><p><img src="/2021/05/07/2021/SKU商品属性组合实践/NO5.png" alt title="NO5"></p><p>想通过组合成这种形式</p><pre><code>按量计费,预付费按量计费,后付费按量计费,,预付费,,后付费按时计费,预付费按时计费,后付费按时计费,</code></pre><p>这种形式，通过一些组合匹配达到筛选数据的目的（后续坑了自己，因为短路了忘记要做什么了🤷‍♂️）</p><p>然后就开始emmm…递归求组合</p><pre><code>this.dfsAllItem(&#39;&#39;, 0);</code></pre><pre><code>dfsAllItem(str, idx, bool = false) {    if(idx &gt;= this.baseConfigInfo.length) {        this.dfsAllRes.add(str); // 去重        return ;    }    let letterArr = this.baseConfigInfo[idx].list;    for(let iTem of letterArr) {        let iTemStr = iTem.desc;        let newSpaceStr, newStr = str;        if(idx === 0) {            newSpaceStr = `${iTemStr}`;        } else {            newSpaceStr = `${newStr},${iTemStr}`;            newStr = `${newStr},`;        }        this.dfsAllItem(newSpaceStr, idx + 1);        this.dfsAllItem(newStr, idx + 1);    }},</code></pre><p><em>递归这个注意项就是</em>，<strong>逗号</strong>，<em>的位置</em>，其他的问题及逻辑难度不大，时间空间也会因为维度和层数而变得复杂😢，索性还好，这边得划分没有那么多。</p><p><img src="/2021/05/07/2021/SKU商品属性组合实践/NO6.png" alt title="NO6"></p><p>进行到这里，等到递归写完，我就忘记后面得思路以及逻辑应该怎么整了，失忆🤦‍♂️</p><h5 id="重整思路🙋‍♂️"><a href="#重整思路🙋‍♂️" class="headerlink" title="重整思路🙋‍♂️"></a>重整思路🙋‍♂️</h5><p>因为前面忘记最初的思路是什么样的，后面重新想了一下新的方式。</p><p>以<code>skuList</code>数据为例子，过程如下：</p><ol><li>我选中了<code>按量付费</code><br>可以从<code>skuList</code>中过滤出12条<em>计费方式为按量付费</em>的数据</li></ol><p><img src="/2021/05/07/2021/SKU商品属性组合实践/NO7.png" alt title="NO7"></p><p>再通过过滤这十二条数据的<code>付费类型</code>，<code>购买次数</code>，<code>购买时长</code>，<code>并发性能</code>，就可以得到如下这样一个对象</p><pre><code>filterSkuSelect = {    付费类型: [&#39;预付费&#39;, &#39;后付费&#39;],    并发性能: [&#39;10QPS&#39;, &#39;50QPS&#39;, &#39;100QPS&#39;, &#39;无限&#39;],    计费方式: [&#39;按量计费&#39;],    购买时长: [],    购买次数: [100000, 200000, 按实际使用量计算]}</code></pre><p>是的，我们可以发现，所有有可能的组合状态似乎已经给筛选出来了，我们先继续看一下下一步：</p><ol start="2"><li>再选中<code>预付费</code><br>因此可以从<code>skuList</code>数组中选出<em>计费方式为按量计费</em>与<em>付费类型为预付费</em>的数据，8条数据。</li></ol><p><img src="/2021/05/07/2021/SKU商品属性组合实践/NO8.png" alt title="NO8"></p><p>再次通过过滤得到一个新的对象：</p><pre><code>filterSkuSelect = {    付费类型: [&#39;预付费&#39;],    并发性能: [&#39;10QPS&#39;, &#39;50QPS&#39;, &#39;100QPS&#39;, &#39;无限&#39;],    计费方式: [&#39;按量计费&#39;],    购买时长: [],    购买次数: [100000, 200000 ]}</code></pre><p>至此，我们可以通过选项对<code>skuList</code>的过滤，再选出可能的类型组合数组。</p><p>而这些类型对应的数组，即是每一中类型可选的值，因此，我们在据此进行判断即可。</p><p>🆗！</p><p>切换效果，样式和逻辑还是有后续优化：</p><p><img src="/2021/05/07/2021/SKU商品属性组合实践/NO9.gif" alt title="NO9"></p><blockquote><p>code</p></blockquote><pre><code>choUnitSku(iTem, jTem, bool) {    if(!bool) return;    if(this.recordChoSkuUnit[iTem.title] === jTem.name) {        this.recordChoSkuUnit[iTem.title] = &#39;&#39;;    } else {        this.recordChoSkuUnit[iTem.title] = jTem.name;    }    let arr = this.skuIndexText;    let nowChoSkuUnitArr = [];    for(let iKey of arr) {        nowChoSkuUnitArr.push(`${this.recordChoSkuUnit[iKey]}`);    }    this.nowChoSkuUnitStr = nowChoSkuUnitArr.join(&#39;,&#39;);},skuChoChange() {    let filterArr = [];    let skuListArr = skuList;    for(let iKey in this.recordChoSkuUnit) {        let iTem = this.recordChoSkuUnit[iKey];        if(iTem === &#39;&#39;) continue;        filterArr = [];        for(let skuUnit of skuListArr) {            if(skuUnit[iKey] === iTem) {                filterArr.push(skuUnit);                }        }        skuListArr = filterArr;    }    this.filterSkuSelect = {        &#39;计费方式&#39;: [],        &#39;付费类型&#39;: [],        &#39;购买次数&#39;: [],        &#39;购买时长&#39;: [],        &#39;并发性能&#39;: [],    }    if(filterArr.length === 0) {        filterArr = skuList;    }    for(let item of filterArr) {        for(let ikey of this.skuIndexText) {            let itemVal = item[ikey];            if(!this.filterSkuSelect[ikey].includes(itemVal) &amp;&amp; itemVal) {                this.filterSkuSelect[ikey].push(itemVal);            }        }    }},</code></pre><h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><p>当然这种方式其实也不好，内部有太多重循环了，还有很多更好的方式去实现，巧妙利用数据结构等…<br>我还看到有大佬使用了一些<code>图</code>等结构去实现了</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的多线程</title>
      <link href="/2021/04/12/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2021/04/12/2021/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="进程，线程"><a href="#进程，线程" class="headerlink" title="进程，线程"></a>进程，线程</h4><p>首先我们思考一下进程与线程的关系与区别：</p><ol><li>一个进程由一个或多个线程组成，多个线程可以协同工作。</li><li>进程之间相互独立，同一进程下各个线程共享程序的内存及一些进程级的资源。</li><li>线程之间的切换比进程间的切换更快。</li></ol><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><a id="more"></a><p>浏览器是多进程的。</p><p><img src="/2021/04/12/2021/浏览器的多线程/NO1.png" alt="NO1" title="NO1"></p><p>我们可以看的他们分别拥有不同的进程ID。</p><ol><li>浏览器进程(Browser 进程):浏览器进程只有一个，用于管理标签页、窗口和浏览器本身。这个进程同时负责处理所有跟磁盘、网络、用户输入和显示的交互，然而它不分析和渲染任何网页内容。</li><li>第三方插件进程:览器进程同样为处于使用状态的每种类型的插件创建一个进程，如:Flash、Quicktime 或 Adobe reader。这些进程仅仅包含插件本身以及和浏览器进程、渲染器进程交互的胶水代码。</li><li>GPU 进程:最多一个，用于 3D 绘制等</li><li>浏览器渲染进程(浏览器内核)(Renderer 进程，内部是多线程的):渲染器进程会存在多个，每个都负责渲染网页。渲染器进程中包含用于操作 HTML，JavaScript，CSS，图片和其他内容的复杂的逻辑。我们使用了也同样被 Apple Safari 浏览器使用的开源的 WebKit 渲染引擎实现以上功能。每个渲染进程都运行在沙箱内，这意味着它对磁盘、网络和显示器没有直接的访问权限。所有跟网络应用的交互，包括用户输入事件和屏幕绘制都必须通过浏览器进程。这可以让浏览器进程监视渲染器的可疑行为，一旦发现其从事破坏活动就将其终止。</li></ol><p>当然作为开发，我们最关心的更是渲染进程，页面渲染，JS执行，事件都在此之上完成。</p><h4 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h4><p>包含了以下<em>线程</em>：</p><ol><li><p>GUI渲染线程负责渲染浏览器界面，解析HTML，CSS，render树，布局绘制等，当界面重绘或者回流时，该线程会执行。值得注意的是，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会保存等待JS引擎空闲时执行。<br>注：👉 <a href="/2020/02/03/2020/重绘回流">重绘回流知识点复习</a></p></li><li><p>JS引擎线程也被称为JS内核，负责JS脚本，JS引擎一直等待任务队列的任务，然后进行处理，一个Tab页中，无论如何只有一个JS线程在运行，如果JS线程运行时间过长，会造成页面渲染卡顿阻塞，这个在debugger断点时，就可以很明显察觉。</p></li><li>事件触发线程属于浏览器而不是JS引擎，用于控制事件循环，例如，宏任务，微任务队列。<br>注：👉 <a href="/2020/06/12/2020/EventLoop">任务队列EventLoop复习</a></li><li>定时触发器线程，setInterval与setTimeout所在的线程定时计数器不是由JS引擎再计数的，因此是有单独线程来计时，并且触发（计时完毕后，添加到事件队列中，等待JS引擎执行），注：setTimeout低于4ms事件间隔都算为4ms。</li><li>异步HTTP线程，XMLHTTP连接后，会通过浏览器开一个线程请求，检查到状态变更后，会调用回调函数，将回调加入事件队列中，由JS引擎执行。</li></ol><h4 id="线程中的关系"><a href="#线程中的关系" class="headerlink" title="线程中的关系"></a>线程中的关系</h4><h5 id="GUI线程与JS引擎线程的互斥"><a href="#GUI线程与JS引擎线程的互斥" class="headerlink" title="GUI线程与JS引擎线程的互斥"></a>GUI线程与JS引擎线程的互斥</h5><p>如果两者不互赤，由于JS可操作DOM，如果两者同时运行，会造成线程前后获得的元素数据可能不一致。</p><h5 id="webWorker"><a href="#webWorker" class="headerlink" title="webWorker"></a>webWorker</h5><ol><li>创建Worker时，JS引擎向浏览器申请开一个子线程（浏览器开的），JS线程与worker线程间通过特定方式通信，postMessage，onMessage，需要通过序列化对象与线程交互。</li></ol><h5 id="sharedWorker"><a href="#sharedWorker" class="headerlink" title="sharedWorker"></a>sharedWorker</h5><ol><li>WebWorker 只属于某个页面，不会和其他页面的 Render 进程(浏览器内核进程)共享</li><li>本质上就是进程和线程的区别。SharedWorker 由独立的进程管理，WebWorker 只是属于 render 进程下的一个线程。</li></ol><h4 id="浏览器渲染流程"><a href="#浏览器渲染流程" class="headerlink" title="浏览器渲染流程"></a>浏览器渲染流程</h4><p><em>从你输入URL到页面生成，经历了什么 ？</em><br>大致过程如下：</p><ol><li>输入url</li><li>浏览器主线程接管</li><li>dns查询IP，会通过缓存查，查浏览器缓存，系统缓存，路由器缓存直至请求到</li><li>发送http请求</li><li>三次确立握手</li><li>四次挥手断开连接</li><li>将返回内容交给Render进程</li><li>开始渲染</li><li>解析html构建dom树，构建CSS树，两者合为render树</li><li>绘制render树</li></ol><p>注：👉 <a href="/2020/07/09/2020/三次握手四次挥手">三次握手，四次挥手复习</a></p><p>几个概念：</p><ul><li>DOM Tree: 浏览器将 HTML 解析成树形的数据结构</li><li>CSS Rule Tree: 浏览器将 CSS 解析成树形的数据结构</li><li>Render Tree: DOM 和 CSSOM 合并后生成 Render Tree</li></ul><h4 id="CSS加载"><a href="#CSS加载" class="headerlink" title="CSS加载"></a>CSS加载</h4><p>CSS是由单独的下载线程异步下载的。<br>所有CSS不会阻塞DOM树解析，但会阻塞Render树渲染。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP1-HTTP1.1-HTTP2-HTTPS-HTTP3的区别特定</title>
      <link href="/2021/04/07/2021/HTTP1-HTTP1-1-HTTP2-HTTPS-HTTP3%E7%9A%84%E5%8C%BA%E5%88%AB%E7%89%B9%E7%82%B9/"/>
      <url>/2021/04/07/2021/HTTP1-HTTP1-1-HTTP2-HTTPS-HTTP3%E7%9A%84%E5%8C%BA%E5%88%AB%E7%89%B9%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>这是在网络请求，HTTP问题上需要知道的一些区别特定，以及相对应改进了的部分。</p><p>可能收集总结的不全，权当了解。</p><a id="more"></a><h4 id="HTTP1-0与HTTP1-1"><a href="#HTTP1-0与HTTP1-1" class="headerlink" title="HTTP1.0与HTTP1.1"></a>HTTP1.0与HTTP1.1</h4><ol><li><p>长连接<br>在HTTP1.1中默认开启长连接<code>connection: keep-alive</code>，在一个TCP连接上可以传送多个请求和响应，减少了建立请求和关闭连接的消耗和延迟。</p></li><li><p>缓存处理</p><ul><li>在<code>HTTP1.0</code>主要是使用了header的<code>Exprires</code>，<code>if-Modified-Since</code>来做缓存判断的标准；</li><li>在<code>HTTP1.1</code>中则有更多选择，<code>Entity Tag</code>，<code>IF-Unmodified-Since</code>，<code>IF-Match</code>，<code>If-none-Match</code>等缓存头进行缓存控制策略。</li></ul></li><li><p>带宽优化，及网络连接<br><code>HTTP1.0</code>中，如果只需要某个对象的一部分，服务器会将整个对象送过来，并且不支持断点续传，而<code>HTTP1.1</code>中则可以在请求头中引入range头部，只允许请求资源的某个部分，即返回码是<code>206</code>；</p></li></ol><p><em>HTTP状态码复习：👉 <a href="/2020/10/28/2020/HTTP常见状态码">HTTP常见状态码</a></em></p><h4 id="HTTP1-X与HTTP2-0"><a href="#HTTP1-X与HTTP2-0" class="headerlink" title="HTTP1.X与HTTP2.0"></a>HTTP1.X与HTTP2.0</h4><p><em>HTTP1.X存在的问题：</em></p><ol><li>TCP连接限制：对于同一个域名，浏览器只能同时创建6~8个TCP连接。</li><li>队头阻塞：当<code>HTTP开启长连接</code>时，共用一个TCP连接，同一时刻只能处理一个请求，如果上一个请求没有返回，则后续的请求与响应都会受阻，即：<br>请求1 –&gt;  响应1<br>请求2 —&gt; 响应2<br>请求3 —&gt; (!!卡顿)<br>[以下部分将阻塞]<br>请求4 —&gt;<br>请求5 —&gt;</li><li>header内容多，每次请求的header没有压缩优化的方案；</li><li>为了减少请求数，需要做合并文件、雪碧图、等优化工作，但是也无疑增大了请求的内容变大；</li><li>明文传输。</li></ol><p><em>HTTP2.0</em></p><ol><li>二进制传输，HTTP2采用二进制格式传输数据，而非HTTP1.X的纯文本形式，二进制解析起来更高效；</li><li>多路复用，在一个TCP连接上，我们向对方不断发送帧，每帧的<code>stream identifier</code>标明属于哪个流，接收时，将每个流所有帧拼接起来组成完整数据；</li><li>header压缩，使用<code>HPACK</code>算法来压缩首部内容；</li><li>服务端推送，浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求。</li></ol><p><em>为什么HTTP1.1不能实现多路复用？</em><br><code>HTTP1.X</code>不是二进制传输，通过文本传输，没有流的概念，无法将多个响应拆分重组，因此实现不了多路复用。</p><p><em>多路复用与keep-alive的区别？</em></p><p><img src="/2021/04/07/2021/HTTP1-HTTP1-1-HTTP2-HTTPS-HTTP3的区别特点/NO1.png" alt="NO1" title="NO1"></p><h4 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h4><p><em>HTTP2的缺点</em></p><p>尽管<code>HTTP/2</code>解决了很多1.1的问题，但<code>HTTP/2</code>仍然存在一些缺陷，这些缺陷并不是来自于<code>HTTP/2</code>协议本身，而是来源于底层的TCP协议，我们知道TCP链接是可靠的连接，如果出现了丢包，那么整个连接都要等待重传，<code>HTTP/1.1</code>可以同时使用6个TCP连接，一个阻塞另外五个还能工作，但<code>HTTP/2</code>只有一个TCP连接，阻塞的问题便被放大了。</p><p>HTTP3采用了UDP协议。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有趣-github的3D打印</title>
      <link href="/2021/04/05/2021/github%E7%9A%843D%E6%89%93%E5%8D%B0/"/>
      <url>/2021/04/05/2021/github%E7%9A%843D%E6%89%93%E5%8D%B0/</url>
      
        <content type="html"><![CDATA[<p>github开放了一个平台，支持导出自己github账户的年度提交量，生成一个3D模型文件</p><p>尝试了一下，导出自己2020年的数据，😂还好不是只是一个平底座…<br>淘宝下单打印了，放在桌子上，提醒自己吧。</p><p><img src="/2021/04/05/2021/github的3D打印/NO1.png" alt="NO1" title="NO1"></p>]]></content>
      
      
      <categories>
          
          <category> 读书V生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常碎碎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大排序</title>
      <link href="/2021/04/02/2021/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/04/02/2021/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>回顾排序</p><p>十大排序分别为：冒泡排序、选择排序、插入排序、快速排序、希尔排序、归并排序、堆排序、计数排序、桶排序、基数排序。<br>接下来我们一起回顾一下这十大排序吧。</p><a id="more"></a><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p><em>介绍：</em></p><blockquote><p>冒泡排序是一种简单的排序，它重复走访要排序的数组，一次比较两个元素，根据要求比较相应的大小，并且有需要的话将它们交换，重复的进行直到没用需要再交换。</p></blockquote><p><em>描述：</em></p><ol><li>比较相邻的元素，如果第一个比第二个大，就交换它们；</li><li>对每一个相邻元素作同样的工作，直到最后一对；</li><li>针对所有元素做以上步骤。</li></ol><p><img src="/2021/04/02/2021/十大排序/NO1.gif" alt="NO1" title="NO1"></p><p><em>代码实现</em></p><pre><code>function bubbleSOrt(arr) {    let len = arr.length;    for(let i = 0; i &lt; len - 1; i++) {        for(let j = 0; i &lt; len - 1 - i; j++) { // 在`i`遍历的过程中，后面的`i`个数已经是冒了泡的了            if(arr[j] &gt; arr[j+1]) {                let tmp = arr[j+1];                arr[j+1] = arr[j];                arr[j] = tmp;            }        }    }    return arr;}</code></pre><p><em>问题：</em></p><ol><li><p>什么时候最快？</p><blockquote><p>Q：已经是有序的情况下，最快了。</p></blockquote></li><li><p>什么时候最慢？</p><blockquote><p>Q：倒序的时候最慢。</p></blockquote></li><li><p>时空复杂度？<br>| 方法 | 时间复杂度(平均) | 时间复杂度(最坏) | 时间复杂度(最好) | 空间复杂度 | 稳定性 |<br>| — | — | — | — | — | — |<br>| 冒泡排序 | O(n^2) | O(n^2) | O(n) | O(1) | 稳定 |</p></li><li><p>为什么最好是O(n)？</p><blockquote><p>Q：O(n)是在进行了算法优化的情况下。</p></blockquote></li></ol><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p><em>介绍：</em></p><blockquote><p>选择排序是简单直观的排序，它的工作原理：首先在未排序的序列中找到最小（大）的元素，存放在排序序列的起始位置，然后再从未排序元素中继续寻找最小（大）元素，然后放在已排序序列的末尾，直到排序完毕。</p></blockquote><p><em>描述：</em></p><ol><li>初始状态：无序数据R[1…n]，有序区为空；</li><li>第i躺排序（i=1，2，3…n-1），当前有序区和无序区分别为R[1…i-1]和R[i,…n]。该躺排序从无序区选中关键字R[k]，将它与无序区第一个记录<code>i</code>交换，使得R[1…i]和R[i+1,…n]划分为新的有序与无序区；</li><li>直到结束</li></ol><p><img src="/2021/04/02/2021/十大排序/NO2.gif" alt="NO2" title="NO2"></p><p><em>代码实现：</em></p><pre><code>function selectSort(arr) {    let arrLen = arr.length - 1;    let tmp;    for(let i = 0; i &lt; arrLen - 1; i++) {        let nowIdx = i;        for(let j = i + 1; j &lt; arrLen; j++) {            if(arr[j] &lt; arr[nowIdx]) {                nowIdx = j;            }        }        tmp = arr[i];        arr[i] = arr[nowIdx];        arr[nowIdx] = tmp;    }    return arr;}</code></pre><p><em>问题：</em></p><ol><li><p>选择排序无论什么数据都是O(n^2)的复杂度。</p></li><li><p>时空复杂度？<br>| 方法 | 时间复杂度(平均) | 时间复杂度(最坏) | 时间复杂度(最好) | 空间复杂度 | 稳定性 |<br>| — | — | — | — | — | — |<br>| 冒泡排序 | O(n^2) | O(n^2) | O(n) | O(1) | 稳定 |</p></li></ol><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p><em>介绍：</em></p><blockquote><p>构建有序序列，对于未排序数据，在已排序序列中从后往前扫描，找到相应位置插入。</p></blockquote><p><em>描述：</em></p><ol><li>第一个元素可以认为是已经排序的；</li><li>取出下一个元素，在已排序的元素中从后向前扫描；</li><li>如果该元素大于新元素，则将该元素一道下一位置；</li><li>不断重复</li></ol><p><img src="/2021/04/02/2021/十大排序/NO3.gif" alt="NO3" title="NO3"></p><p><em>代码实现：</em></p><pre><code>function insertSort(arr) {    let arrLen = arr.length;    let prevIdx, curVal;    for(let i = 1; i &lt; arrLen; i++ ) {        prevIdx = i - 1;        curVal = arr[i];        while(prevIdx &gt;=0 &amp;&amp; arr[prevIdx] &gt; curVal ) {            arr[prevIdx + 1] = arr[prevIdx];            prevIdx--;        }        arr[prevIdx + 1] = curVal;    }    return arr;}</code></pre><p><em>问题：</em></p><ol><li>时空复杂度？</li></ol><table><thead><tr><th>方法</th><th>时间复杂度(平均)</th><th>时间复杂度(最坏)</th><th>时间复杂度(最好)</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n)</td><td>O(1)</td><td>稳定</td></tr></tbody></table><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><em>图解形象</em><br>👉： <a href="https://zhuanlan.zhihu.com/p/350934702" target="_blank" rel="noopener">快速排序</a> </p><p><em>代码实现：</em></p><pre><code>function quickSort (arr, L, R) {    if(L &gt;= R) {        return;    }    if(!L) L = begin = 0;                           // 左指针    if(!R) R = end = arr.length - 1;                //右指针    let temp = arr[L];                              //基准数，这里取数组第一个数    while(L &lt; R) {                                  //左右指针相遇的时候退出扫描循环        while(L &lt; R &amp;&amp; arr[R] &gt;= temp ) {           //右指针从右向左扫描，碰到第一个小于基准数的时候停住            R--;        }        while(L &lt; R &amp;&amp; arr[L] &lt; temp ){             //左指针从左向右扫描，碰到第一个大于基准数的时候停住            L++;        }        [arr[L], arr[R]] = [arr[R], arr[L]];        //交换左右指针所停位置的数    }    [arr[L], arr[begin]] = [arr[begin], arr[L]];    //最后交换基准数与指针相遇位置的数    //递归处理左右数组    quickSort(arr, begin, L - 1);    quickSort(arr, R + 1, end);}</code></pre><pre><code>var sortArray = function(nums) {    if(nums.length &lt;= 1) return nums;    let left = [],        right = [];    let pivoIdx = 0;    let pivoVal = nums[0];    nums = nums.slice(1);    for(let i = 0; i &lt; nums.length; i++) {        if(nums[i] &gt; pivoVal) {            right.push(nums[i]);        } else {            left.push(nums[i]);        }    }    return sortArray(left).concat(pivoVal, sortArray(right));};</code></pre><p><em>问题：</em></p><ol><li>时空复杂度？</li></ol><table><thead><tr><th>方法</th><th>时间复杂度(平均)</th><th>时间复杂度(最坏)</th><th>时间复杂度(最好)</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(nLog2n)</td><td>O(n^2)</td><td>O(nLog2n)</td><td>O(nLog2n)</td><td>不稳定</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS手写Promise</title>
      <link href="/2021/04/01/2021/JS%E6%89%8B%E5%86%99Promise/"/>
      <url>/2021/04/01/2021/JS%E6%89%8B%E5%86%99Promise/</url>
      
        <content type="html"><![CDATA[<p><em>转载至掘金文章，推荐查看原文</em></p><ol><li>👉：<a href="https://juejin.cn/post/6844903625769091079" target="_blank" rel="noopener">BAT前端经典面试问题：史上最最最详细的手写Promise教程</a></li><li>👉：<a href="https://juejin.cn/post/6945319439772434469" target="_blank" rel="noopener">从一道让我失眠的 Promise 面试题开始，深入分析 Promise 实现细节</a></li></ol><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h4 id="定义Promise"><a href="#定义Promise" class="headerlink" title="定义Promise"></a>定义Promise</h4><p>一般使用</p><pre><code>new Promise((resolve, reject) =&gt; {    xxx})</code></pre><p><em>so</em></p><pre><code>class Promise {    constructor(executor) {        executor(this.resolve, this.reject)    }    resolve = () =&gt; {};    reject = () =&gt; {};}</code></pre><a id="more"></a><h4 id="解决基本状态"><a href="#解决基本状态" class="headerlink" title="解决基本状态"></a>解决基本状态</h4><ol><li>pending， fulfilled， rejected</li><li>pending -&gt; fulfilled / rejected</li><li>其他不可互转</li><li>new Promise((resolve, reject) =&gt; {resolve(value)})，resolve成功时，接受参数value，状态改为fulfilled，且不可变。</li><li>new Promise((resolve, reject) =&gt; {reject(reason)})，reject失败时，接收reason，状态为rejected，且不可再变。</li><li>若executor报错，则直接rejected。</li></ol><p><em>so</em></p><pre><code>const PENDING = &#39;pending&#39;;const FULFILLED = &#39;fulfilled&#39;;const REJECTED = &#39;rejected&#39;;class Promise {    constructor(executor) {        executor(this.resolve, this.reject);    }    state = PENDING    value = undefined; // 存储成功值    reason = null; // 存储失败值    resolve = (value) =&gt; {        // 只有状态是等待，才执行状态修改        if (this.status === PENDING) {        // 状态修改为成功        this.status = FULFILLED;        // 保存成功之后的值        this.value = value;        }    }     reject = (reason) =&gt; {        // 只有状态是等待，才执行状态修改        if (this.status === PENDING) {        // 状态成功为失败        this.status = REJECTED;        // 保存失败后的原因        this.reason = reason;        }    }}</code></pre><h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><ol><li>Promise有一个then，里面有两个参数，onFulfilled，onRejected；</li><li>当state为fulfilled，则执行onFulfilled，并传入this.value；</li><li>当state为rejected，则执行onRejected，并传入this.reason。</li></ol><pre><code>class Promise{     constructor(executor) {        ...    }    then(onFulfilled, onRejected) {        if(this.state === &#39;fulfilled&#39;) {            onFulfilled(this.value); // 传入，并执行onFulfilled        }        if(this.state === &#39;rejected&#39;) {            onRejected(this.reason); // 传入，并执行onRejected        }    }}</code></pre><h4 id="暴露Promise"><a href="#暴露Promise" class="headerlink" title="暴露Promise"></a>暴露Promise</h4><pre><code>module.export = Promise;</code></pre><h2 id="加入异步"><a href="#加入异步" class="headerlink" title="加入异步"></a>加入异步</h2><h4 id="缓存成功失败回调"><a href="#缓存成功失败回调" class="headerlink" title="缓存成功失败回调"></a>缓存成功失败回调</h4><p>onFulfilledCallback = null;<br>onRejectedCallback = null;</p><h4 id="then中增加PENDING的处理"><a href="#then中增加PENDING的处理" class="headerlink" title="then中增加PENDING的处理"></a>then中增加PENDING的处理</h4><pre><code>then(onFulfilled, onRejected) {    if(this.state === FULFILLED) {        onFulfilled(this.value); // 传入，并执行onFulfilled    }    if(this.state === REJECTED) {        onRejected(this.reason); // 传入，并执行onRejected    }    if(this.state === PENDING) {        // 先缓存，等等后续状态变化后执行        this.onFulfilledCallback = onFulfilled;        this.onRejectedCallback  = onRejected;    }}</code></pre><h4 id="resolve-reject调用回调"><a href="#resolve-reject调用回调" class="headerlink" title="resolve\reject调用回调"></a>resolve\reject调用回调</h4><pre><code>resolve = value =&gt; {    if(this.state === PENDING) {        this.state = FULFILLED;        this.value = value;        this.onFulfilledCallback &amp;&amp; this.onFulfilledCallback(this.value)    }}reject = reason =&gt; {    if(this.state === PENDING) {        this.reason =reason;        this.state = REJECTED;        this.onRejectedCallback &amp;&amp; this.onFulfilledCallback(this.reason)    }}</code></pre><h2 id="then回调"><a href="#then回调" class="headerlink" title="then回调"></a>then回调</h2><p>多个then回调的话，需要保存不同的值，因为互不相同。</p><ol><li>Promise中回调处理为数组。</li></ol><pre><code>onFulfilledCallbacks = [];onnRejectedCallbacks = [];</code></pre><ol start="2"><li>回调函数存入数组</li></ol><pre><code>then(onFulfilled, onRejected) {    if(this.status === FULFILLED){        onFulfilled(this.value);    } else if (this.status === REJECTED) {        onRejected(this.reason);    } else if (this.status === PENDING) {        this.onFulfilledCallbacks.push(onFulfilled);        this.onRejectedCallbacks.push(onRejected);    }}</code></pre><pre><code>resolve = (value) =&gt; {          if (this.status === PENDING) {                  this.status = FULFILLED;                   this.value = value;                 // resolve里面将所有成功的回调拿出来执行              while (this.onFulfilledCallbacks.length) {                    // Array.shift() 取出数组第一个元素，然后（）调用，shift不是纯函数，取出后，数组将失去该元素，直到数组为空                    this.onFulfilledCallbacks.shift()(value)            }       } }</code></pre><pre><code>reject = reason =&gt; {    if(this.status === PENDING) {        this.status = REJECTED;        this.reason = reason;        while(this.onRejectedCallbacks.length) {            this.onRejectedCallbacks.shift()(reason);        }    }}</code></pre><p><em>so，截至目前我们的Promise是这样的</em></p><pre><code>const PENDING = &#39;pending&#39;;const FULFILLED = &#39;fulfilled&#39;;const REJECTED = &#39;rejected&#39;;onFulfilledCallbacks = [];onnRejectedCallbacks = [];class Promise {    constructor(executor) {        executor(this.resolve, this.reject);    }    state = PENDING    value = undefined; // 存储成功值    reason = null; // 存储失败值    resolve = (value) =&gt; {              if (this.status === PENDING) {                      this.status = FULFILLED;                       this.value = value;                     // resolve里面将所有成功的回调拿出来执行                  while (this.onFulfilledCallbacks.length) {                        // Array.shift() 取出数组第一个元素，然后（）调用，shift不是纯函数，取出后，数组将失去该元素，直到数组为空                        this.onFulfilledCallbacks.shift()(value)                }           }     }    reject = reason =&gt; {        if(this.status === PENDING) {            this.status = REJECTED;            this.reason = reason;            while(this.onRejectedCallbacks.length) {                this.onRejectedCallbacks.shift()(reason);            }        }    }    then(onFulfilled, onRejected) {        if(this.status === FULFILLED){            onFulfilled(this.value);        } else if (this.status === REJECTED) {            onRejected(this.reason);        } else if (this.status === PENDING) {            this.onFulfilledCallbacks.push(onFulfilled);            this.onRejectedCallbacks.push(onRejected);        }    }}module.export = Promise;</code></pre><h4 id="then的链式调用"><a href="#then的链式调用" class="headerlink" title="then的链式调用"></a>then的链式调用</h4><p>如何实现then的链式调用呢？<br>在then里面返回一个Promise对象吗</p><pre><code>class Promise() {    // ...    then(onFulfilled, onRejected) {        const promise2 = new Promise((resolve, reject) =&gt; {            if(this.status === PENDING ) {                this.onFulfilledCallbacks.push(onFulfilled);                this.onRejectedCallbacks.push(onRejected);            } else if (this.status === REJECTED) {                onRejected(this.reason);            } else if (this.status === FULFILLED) {                const x = onFulfilled(this.value);                resolvePromise(x, resolve, reject);            }        });        return promise2;    }}function resolvePromise(x, resolve, reject) {    // 判断是不是Promise的实例    if(x instanceof Promise) {        // 是的话，执行then        x.then(resolve, reject)    } else {        // 否则resolve        resolve(x);    }}</code></pre><p>如果x是自己的话，则应该有错误处理</p><pre><code>class Promise {  ......  then(onFulfilled, onRejected) {    const promise2 = new MyPromise((resolve, reject) =&gt; {      if (this.status === FULFILLED) {        // 创建一个微任务等待 promise2 完成初始化        queueMicrotask(() =&gt; {            const x = onFulfilled(this.value);            resolvePromise(promise2, x, resolve, reject);        })      } else if (this.status === REJECTED) {      ......    })     return promise2;  }}function resolvePromise(promise2, x, resolve, reject) {    if(promise2 === x) {        return reject(&#39;...&#39;)    }    //...}</code></pre><h2 id="错误捕获"><a href="#错误捕获" class="headerlink" title="错误捕获"></a>错误捕获</h2><p>try，catch就可以了</p><h4 id="捕获执行器错误"><a href="#捕获执行器错误" class="headerlink" title="捕获执行器错误"></a>捕获执行器错误</h4><pre><code>constructor(executor) {    try{        executor(this.resolve, this.reject);    } catch(e) {        this.reject(e)    } }</code></pre><h4 id="then执行错误"><a href="#then执行错误" class="headerlink" title="then执行错误"></a>then执行错误</h4><pre><code>then(onFulfilled, onRejected) {    const proimise2 = new Promise((resolve, reject) =&gt; {        if(this.status === PENDING) {            this.onFulfilledCallbacks.push(onFulfilled)            this.onRejectedCallbacks.push(onRejected)        } else if (this.status === REJECTED) {            onRejected(this.reason);        } else if (this.status === FULFILLED) {            queueMicrotask(() =&gt; {                // 增加 try 处理                try {                    const x = onFulfilled(this.value);                    resolvePromise(promise2, x, resolve, reject);                } catch(e) {                    reject(e);                }            })        }    });    return promise2;}</code></pre><p>整理一下：</p><pre><code>then(onFulfilled, onRejected) {  // 为了链式调用这里直接创建一个 MyPromise，并在后面 return 出去  const promise2 = new Promise((resolve, reject) =&gt; {    // 判断状态    if (this.status === FULFILLED) {      // 创建一个微任务等待 promise2 完成初始化      queueMicrotask(() =&gt; {        try {          // 获取成功回调函数的执行结果          const x = onFulfilled(this.value);          // 传入 resolvePromise 集中处理          resolvePromise(promise2, x, resolve, reject);        } catch (error) {          reject(error)        }       })      } else if (this.status === REJECTED) {       // ==== 新增 ====      // 创建一个微任务等待 promise2 完成初始化      queueMicrotask(() =&gt; {        try {          // 调用失败回调，并且把原因返回          const x = onRejected(this.reason);          // 传入 resolvePromise 集中处理          resolvePromise(promise2, x, resolve, reject);        } catch (error) {          reject(error)        }       })     } else if (this.status === PENDING) {      // 等待      // 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来      // 等到执行成功失败函数的时候再传递      this.onFulfilledCallbacks.push(() =&gt; {        // ==== 新增 ====        queueMicrotask(() =&gt; {          try {            // 获取成功回调函数的执行结果            const x = onFulfilled(this.value);            // 传入 resolvePromise 集中处理            resolvePromise(promise2, x, resolve, reject);          } catch (error) {            reject(error)          }         })       });      this.onRejectedCallbacks.push(() =&gt; {        // ==== 新增 ====        queueMicrotask(() =&gt; {          try {            // 调用失败回调，并且把原因返回            const x = onRejected(this.reason);            // 传入 resolvePromise 集中处理            resolvePromise(promise2, x, resolve, reject);          } catch (error) {            reject(error)          }         })       });    }  })   return promise2;}</code></pre><h2 id="其余优化"><a href="#其余优化" class="headerlink" title="其余优化"></a>其余优化</h2><h4 id="实现resolve，reject的静态调用"><a href="#实现resolve，reject的静态调用" class="headerlink" title="实现resolve，reject的静态调用"></a>实现resolve，reject的静态调用</h4><p>Promise支持如下执行：</p><pre><code>Promise.resolve().then(value =&gt; {    xxx});</code></pre><p>因此还需要修改一下，增加静态方法</p><pre><code>static resolve(param) {    if(param instanceof Promise) {        return param;    }    return new Promise(resolve =&gt; {        resolve(param)    })}static reject (reason) {    return new MyPromise((resolve, reject) =&gt; {      reject(reason);    });}</code></pre><h2 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h2><pre><code>// Promise.js// 先定义三个常量表示状态const PENDING = &#39;pending&#39;;const FULFILLED = &#39;fulfilled&#39;;const REJECTED = &#39;rejected&#39;;// 新建 Promise 类class Promise {  constructor(executor){    // executor 是一个执行器，进入会立即执行    // 并传入resolve和reject方法    try {      executor(this.resolve, this.reject)    } catch (error) {      this.reject(error)    }  }  // 储存状态的变量，初始值是 pending  status = PENDING;  // 成功之后的值  value = null;  // 失败之后的原因  reason = null;  // 存储成功回调函数  onFulfilledCallbacks = [];  // 存储失败回调函数  onRejectedCallbacks = [];  // 更改成功后的状态  resolve = (value) =&gt; {    // 只有状态是等待，才执行状态修改    if (this.status === PENDING) {      // 状态修改为成功      this.status = FULFILLED;      // 保存成功之后的值      this.value = value;      // resolve里面将所有成功的回调拿出来执行      while (this.onFulfilledCallbacks.length) {        // Array.shift() 取出数组第一个元素，然后（）调用，shift不是纯函数，取出后，数组将失去该元素，直到数组为空        this.onFulfilledCallbacks.shift()(value)      }    }  }  // 更改失败后的状态  reject = (reason) =&gt; {    // 只有状态是等待，才执行状态修改    if (this.status === PENDING) {      // 状态成功为失败      this.status = REJECTED;      // 保存失败后的原因      this.reason = reason;      // resolve里面将所有失败的回调拿出来执行      while (this.onRejectedCallbacks.length) {        this.onRejectedCallbacks.shift()(reason)      }    }  }  then(onFulfilled, onRejected) {    const realOnFulfilled = typeof onFulfilled === &#39;function&#39; ? onFulfilled : value =&gt; value;    const realOnRejected = typeof onRejected === &#39;function&#39; ? onRejected : reason =&gt; {throw reason};    // 为了链式调用这里直接创建一个 MyPromise，并在后面 return 出去    const promise2 = new Promise((resolve, reject) =&gt; {      const fulfilledMicrotask = () =&gt;  {        // 创建一个微任务等待 promise2 完成初始化        queueMicrotask(() =&gt; {          try {            // 获取成功回调函数的执行结果            const x = realOnFulfilled(this.value);            // 传入 resolvePromise 集中处理            resolvePromise(promise2, x, resolve, reject);          } catch (error) {            reject(error)          }         })        }      const rejectedMicrotask = () =&gt; {         // 创建一个微任务等待 promise2 完成初始化        queueMicrotask(() =&gt; {          try {            // 调用失败回调，并且把原因返回            const x = realOnRejected(this.reason);            // 传入 resolvePromise 集中处理            resolvePromise(promise2, x, resolve, reject);          } catch (error) {            reject(error)          }         })       }      // 判断状态      if (this.status === FULFILLED) {        fulfilledMicrotask()       } else if (this.status === REJECTED) {         rejectedMicrotask()      } else if (this.status === PENDING) {        // 等待        // 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来        // 等到执行成功失败函数的时候再传递        this.onFulfilledCallbacks.push(fulfilledMicrotask);        this.onRejectedCallbacks.push(rejectedMicrotask);      }    })     return promise2;  }  // resolve 静态方法  static resolve (parameter) {    // 如果传入 Promise 就直接返回    if (parameter instanceof Promise) {      return parameter;    }    // 转成常规方式    return new Promise(resolve =&gt;  {      resolve(parameter);    });  }  // reject 静态方法  static reject (reason) {    return new Promise((resolve, reject) =&gt; {      reject(reason);    });  }}function resolvePromise(promise2, x, resolve, reject) {  // 如果相等了，说明return的是自己，抛出类型错误并返回  if (promise2 === x) {    return reject(new TypeError(&#39;Chaining cycle detected for promise #&lt;Promise&gt;&#39;))  }  // 判断x是不是 Promise 实例对象  if(x instanceof Promise) {    // 执行 x，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected    // x.then(value =&gt; resolve(value), reason =&gt; reject(reason))    // 简化之后    x.then(resolve, reject)  } else{    // 普通值    resolve(x)  }}module.exports = Promise;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP缓存</title>
      <link href="/2021/02/26/2021/HTTP%E7%BC%93%E5%AD%98/"/>
      <url>/2021/02/26/2021/HTTP%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><p>Http缓存的主要三个角色：浏览器、浏览器缓存数据库、服务器；</p><p>缓存类型：<code>强缓存</code>、<code>协商缓存</code>。</p><a id="more"></a><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>两个规则字段，基本原理：所请求的数据在缓存数据库中尚未过期时，不与服务器进行交互，直接使用缓存数据库中的数据。</p><p>当缓存未过期时基本流程如下</p><ol><li>Expire(http1.0字段)</li><li>Cache-Control(通用消息头，通过指定指令实现缓存机制)<ul><li>private：客户端可以缓存；</li><li>public：客户端和代理服务器都可以缓存；</li><li>max-age=xxx：缓存内容将在XXX秒后失效；</li><li>s-max-age=xxx：仅适用共享缓存，并且私有缓存中忽略；</li><li>no-cache：需要使用协商缓存来验证缓存数据；</li><li>no-store：所有内容都不缓存，强缓存和协商缓存都不生效；</li><li>must-revalidate：缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源。</li></ul></li></ol><p>命中强缓存：<strong>200</strong>，<em>from cache</em></p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>基本原理：</p><ol><li>浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将两者备份至缓存数据库中；</li><li>再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功返回304状态码，通知客户端使用缓存数据。</li><li>若缓存失效，则返回<strong>200</strong>，并且返回请求的资源。</li></ol><p><em>规则字段：</em></p><ol><li>Last-Modified</li></ol><ul><li>服务器在响应请求时，告诉浏览器的最后修改时间。</li></ul><ol start="2"><li>If-Modified-Since规则：</li></ol><ul><li>再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。</li><li>服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。</li><li>若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；</li><li>若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。</li></ul><p><em>以下优先级高于上面两者！</em></p><ol><li>Etag：</li></ol><ul><li>服务器资源的唯一标识符, 浏览器可以根据ETag值缓存数据, 节省带宽. 如果资源已经改变, etag可以帮助防止同步更新资源的相互覆盖. ETag 优先级比 Last-Modified 高.</li></ul><ol start="2"><li>If-None-Match</li></ol><ul><li>再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。</li><li>服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，</li><li>不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；</li><li>相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。</li></ul><p><img src="/2021/02/26/2021/HTTP缓存/NO1.png" alt="NO1" title="NO1"></p><h3 id="Q？"><a href="#Q？" class="headerlink" title="Q？"></a>Q？</h3><ul><li>哪些不能缓存？<ol><li>不能被缓存的请求HTTP 信息头中包含Cache-Control:no-cache，pragma:no-cache，或Cache-Control:max-age=0 等告诉浏览器不用缓存的请求</li><li>需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的</li><li>经过HTTPS安全加密的请求（有人也经过测试发现，ie 其实在头部加入 Cache-Control：max-age 信息，firefox 在头部加入 Cache-Control:Public 之后，能够对HTTPS的资源进行缓存）</li><li>HTTP 响应头中不包含 Last-Modified/Etag，也不包含 Cache-Control/Expires 的请求无法被缓存</li><li>目前浏览器的实现是不会对POST请求的响应做缓存的（从语义上来说也不应该），并且规范中也规定了返回状态码不允许是304。不过这并不表示POST的响应不能被缓存，根据RFC 7231 - Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content中描述的，如果在POST请求对应的响应中包含Freshness相关信息的话，这次响应也是可以被缓存，具体可以参考上面的那个链接</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP与UDP的区别</title>
      <link href="/2021/02/21/2021/TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/02/21/2021/TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。<br>一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂， 只简单的描述下这三次对话的简单过程：</p><p>👉： <a href="/2020/07/09/2020/三次握手四次挥手">三次握手四次挥手复习</a> </p><a id="more"></a><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><ol><li>UDP是一个非连接的协议，传输数据之前源头与终端不建立连接，当它想传送时就简单的抓取来自应用的程序的数据，并尽可能快的扔向网络；</li><li>在发送端，UDP传送数据的速度仅仅是受程序生成数据的速度，计算机能力及带宽的限制，在接收端，UDP将消息放在队列中，并每次从队列中读一个消息段；</li><li>UDP信息包标题很短，只有8个字节，相对于TCP的20个字节，开销小；</li><li>UDP尽最大努力交付，不保证可靠交付，因此主机不需要维持复制的连接状态；</li><li>UDP面向报文，发送方的应用程序交下来的报文，添加首部后就交付给IP层，不拆分也不合并。</li></ol><p><em>我们时常使用：ping命令，就是向对方发送UDP数据包，然后确认对方是否接收到数据包，来确认网络是否联通。</em></p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol><li>TCP是基于连接的，而UDP则是无连接的。</li><li>对系统资源的要求，TCP较多，UDP较少。</li><li>UDP程序简单。</li><li>TCP保证数据正确定，UDP可能丢包。</li><li>TCP保证数据顺序，UDP不保证。</li><li>TCP只能点对点全双工通信，UDP支持一对多，多对一，一对一，多对多的通信。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS与stylus与CSSVar的相互作用</title>
      <link href="/2021/01/08/2021/JS%E4%B8%8Estylus%E4%B8%8ECSSVar%E7%9A%84%E7%9B%B8%E4%BA%92%E4%BD%9C%E7%94%A8/"/>
      <url>/2021/01/08/2021/JS%E4%B8%8Estylus%E4%B8%8ECSSVar%E7%9A%84%E7%9B%B8%E4%BA%92%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>场景是这样的：<br>使用stylus给所有的stylus文件混入一个”是否适配”的变量，<br>从而达到改变这个CSS变量，同时可以影响JS中的rem设定，以及Sylus的响应。</p><p><em>stylusVariableMixin.styl</em></p><pre><code>$mediaVersion = false;</code></pre><a id="more"></a><p>而本身在JS中需要设置font-size<br><em>mixin.ts</em></p><pre><code>/** 菜单定义等应用会设置font-size,故需要重置一下,不能在目录直接一次设置 */import { Vue, Component, Watch } from &#39;vue-property-decorator&#39;;@Componentexport default class fontSizeMixin extends Vue {    // 计算rem    private setFontSize() {        let htmlDOM = document.documentElement,        clientWidth = htmlDOM.offsetWidth;        if (!clientWidth) {            return;        }         htmlDOM.style.fontSize = 10 * (clientWidth / 1366) + &#39;px&#39;;// ...    }    private created() {        this.setFontSize();    }    private activated() {        this.setFontSize();    }}</code></pre><p>所以思考着能不能将stylus中的”适配标识“让JS能操作到</p><p>后来查阅多重资料发现，JS并不能对stylus预处理器做什么操作</p><p>再后来，希望借由  CSS,达到这个目的</p><p>stylus — css — JS</p><p>借助CSS之手，让JS实现读取这一变量</p><p>实现如下：<br>①定义全局变量<br><em>stylusVariableMixin.styl</em></p><pre><code>$mediaVersion = false;</code></pre><p>②在打包时混入，（这一步还有给其他stylus文件使用的原因）</p><p><em>webpack_dev_xxx.config.js</em></p><pre><code>{      test: /\.styl(us)?$/,      use: [&quot;style-loader&quot;, &quot;vue-style-loader&quot;, &quot;css-loader&quot;, &quot;stylus-loader&quot;,          {              loader: &#39;style-resources-loader&#39;,              options: {                  patterns: [                      path.resolve(__dirname, &#39;./css/stylusVariableMixin.styl&#39;)                  ]              }          }      ]  },</code></pre><p>③自定义CSS变量接收全局变量<br><em>common.stylus</em></p><pre><code>:root {    --global-bool: $mediaVersion;}</code></pre><p>④JS读取<br><em>mixin.ts</em></p><pre><code>private setFontSize() {        let htmlDOM = document.documentElement,        clientWidth = htmlDOM.offsetWidth;        if (!clientWidth) {            return;        }        // 根据  stylusVariableMixin.styl 及 common.stylus 混入的变量进行的适配判断        let rootStyle = getComputedStyle(document.documentElement);         let judgeBool = rootStyle.getPropertyValue(&#39;--global-bool&#39;).trim();        if(judgeBool === &#39;true&#39;) {            htmlDOM.style.fontSize = 10 * (clientWidth / 1366) + &#39;px&#39;;        } else {            htmlDOM.style.fontSize = 10  + &#39;px&#39;;        }    }</code></pre><p>—-结束—<br>写的匆忙，可能描述不够细致，见谅。</p><p>读取CSS中自定义变量的方法</p><pre><code>let rootStyle = getComputedStyle(document.documentElement);         let judgeBool = rootStyle.getPropertyValue(&#39;--global-bool&#39;).trim();</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> CSS </tag>
            
            <tag> Stylus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS&amp;HTML</title>
      <link href="/2021/01/01/web/CSS/"/>
      <url>/2021/01/01/web/CSS/</url>
      
        <content type="html"><![CDATA[<h3 id="一、重绘回流"><a href="#一、重绘回流" class="headerlink" title="一、重绘回流"></a>一、重绘回流</h3><p>👉： <a href="/2020/02/03/2020/重绘回流">浏览器重绘回流复习</a> </p><h3 id="二、em-px-rem-vw-vh的区别"><a href="#二、em-px-rem-vw-vh的区别" class="headerlink" title="二、em/px/rem/vw/vh的区别"></a>二、em/px/rem/vw/vh的区别</h3><ol><li><strong>px：</strong>绝对单位，按照页面精确像素展示</li><li><strong>em：</strong>相对单位，基准是按照父节点的字体大小，如果自身有定义<code>font-size</code>则按自身的来计算，整个页面<code>1em</code>不是一个固定值</li><li><strong>rem：</strong>相对单位，按照<code>html</code>的字体大小换算得到</li><li><strong>vw、vh：</strong>页面的窗口大小</li></ol><h3 id="三、BFC"><a href="#三、BFC" class="headerlink" title="三、BFC"></a>三、BFC</h3><p>这个真的经常遇到，但是概念没有整理过，总是漏那么一点🤦‍♂️</p><ol><li><p>概念</p><p> <code>BFC</code>，块级格式化上下文，它是页面中的一块渲染区域，有自己的一套渲染规则：</p><ul><li>内部的盒子会在垂直方向上一个接一个放置；</li><li>对于同一个<code>BFC</code>的两个相邻盒子<code>margin</code>会重叠，与方向无关；</li><li><code>BFC</code>的区域不会与<code>float</code>的区域重叠；</li><li>计算<code>BFC</code>高度时，浮动子元素也会计算进去；</li><li><p><code>BFC</code>就是一个页面的隔离容器，让内部子元素不会影响到外部的元素。</p><p><em>目的</em>：形成一个与外界独立的空间，让内部子元素不影响外部元素。</p></li></ul></li><li><p>触发条件</p><ul><li>根元素，<code>&lt;html&gt;</code></li><li>浮动元素，设置了<code>float</code></li><li><code>overflow</code>值不为<code>visible</code></li><li><code>display</code>的值为<code>inline-block</code>、<code>table</code>、<code>flex</code>、<code>grid</code>等</li><li><code>position</code>的值为<code>absolute</code>、<code>fixed</code></li></ul></li></ol><h3 id="四、CSS定位详解"><a href="#四、CSS定位详解" class="headerlink" title="四、CSS定位详解"></a>四、CSS定位详解</h3><p><code>position</code>属性有五个值：</p><ul><li>static<ul><li>如果省略position属性，那么默认就是<code>static</code>定位</li></ul></li><li>relative<ul><li>设置了<code>relative</code>属性值后，会相对于默认属性进行偏移，即定位的基点是元素的默认位置</li></ul></li><li>position<ul><li><code>absolute</code>会相对于上级元素进行偏移，但是这个父元素不能是<code>static</code>定位，否则定位基点将变成<code>html</code></li></ul></li><li>fixed<ul><li><code>fixed</code>将相对于视口进行偏移，即定位的基点是浏览器窗口，这样导致元素位置不随页面滚动，像是固定在页面上一样，例如一些广告位</li></ul></li><li>sticky<ul><li><code>sticky</code>，它会产生动态效果，像是<code>relative</code>和<code>fixed</code>的结合，需要配合<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>进行</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Web </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="/2021/01/01/web/HTTP/"/>
      <url>/2021/01/01/web/HTTP/</url>
      
        <content type="html"><![CDATA[<h4 id="三次握手-amp-四次挥手"><a href="#三次握手-amp-四次挥手" class="headerlink" title="三次握手&amp;四次挥手"></a>三次握手&amp;四次挥手</h4><p>👉： <a href="/2020/07/09/2020/三次握手四次挥手">三次握手四次挥手复习</a> </p><h4 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h4><p>👉： <a href="/2020/10/28/2020/HTTP常见状态码">HTTP常见状态码</a> </p><h4 id="输入URL到页面构建"><a href="#输入URL到页面构建" class="headerlink" title="输入URL到页面构建"></a>输入URL到页面构建</h4><p>👉： <a href="/2021/04/12/2021/浏览器的多线程">输入URL到页面构建，向后翻一点</a> </p><h4 id="HTTPS连接过程"><a href="#HTTPS连接过程" class="headerlink" title="HTTPS连接过程"></a>HTTPS连接过程</h4><p>👉： <a href="/2020/07/09/2020/HTTPS连接过程">HTTPS连接过程</a> </p><h4 id="HTTP缓存机制"><a href="#HTTP缓存机制" class="headerlink" title="HTTP缓存机制"></a>HTTP缓存机制</h4><p>👉： <a href="/2021/02/26/2021/HTTP缓存">HTTP缓存机制</a> </p><h4 id="HTTP1、HTTP1-1、HTTP2、HTTPS、HTTP3的区别及特定"><a href="#HTTP1、HTTP1-1、HTTP2、HTTPS、HTTP3的区别及特定" class="headerlink" title="HTTP1、HTTP1.1、HTTP2、HTTPS、HTTP3的区别及特定"></a>HTTP1、HTTP1.1、HTTP2、HTTPS、HTTP3的区别及特定</h4><p>👉： <a href="/2021/04/07/2021/HTTP1-HTTP1-1-HTTP2-HTTPS-HTTP3的区别特点">HTTP</a> </p><h4 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h4><p>👉： <a href="/2021/02/21/2021/TCP与UDP的区别">TCP与UDP的区别</a> </p><h4 id="网络的七层结构"><a href="#网络的七层结构" class="headerlink" title="网络的七层结构"></a>网络的七层结构</h4><p>👉： <a href="/2020/11/05/2020/网络七层结构">网络的七层结构</a> </p><h4 id="一个-tcp-连接能发几个-http-请求？"><a href="#一个-tcp-连接能发几个-http-请求？" class="headerlink" title="一个 tcp 连接能发几个 http 请求？"></a>一个 tcp 连接能发几个 http 请求？</h4><ol><li>如果是<code>HTTP1.0</code>协议，不支持长连接，每次请求完毕，<code>TCP</code>连接即会断开；</li><li>如果是<code>HTTP1.1</code>协议，支持长连接，只要TCP不断开，便可以一直发送<code>HTTP</code>请求，持续不断；</li><li>如果是<code>HTTP2</code>协议，支持多路复用，持续不断，一个<code>TCP</code>连接是可以并发多个<code>HTTP</code>请求的，并且<code>TCP</code>不断开，也可以不断的发送。</li></ol><h4 id="get和Post的区别？"><a href="#get和Post的区别？" class="headerlink" title="get和Post的区别？"></a>get和Post的区别？</h4><ol><li>get请求的数据是可缓存的，post不可；</li><li>get请求的参数是在<code>URL</code>中的，post的请求数据在<code>body</code>中；</li><li>在url上的传参可能会容易泄露信息，但是post和get在安全上都不是主导方向、决定因素；</li><li>get与post的请求大小不同；</li></ol><h4 id="Session和Cookie"><a href="#Session和Cookie" class="headerlink" title="Session和Cookie"></a>Session和Cookie</h4><p>因为<code>HTTP</code>协议是无状态的，客户请求-关闭，再请求是不会识别或者判断出是谁的，因此需要用这种机制进行记录和判断。</p><p><em>概念</em></p><ol><li>Session：<code>Session</code>是在服务端保存的一个数据结构，用来跟踪用户状态，这个数据可以保存在集群、数据库、文件中。</li><li>Cookie：是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现<code>Session</code>的一种方式。</li></ol><p><em>时长</em></p><ol><li>服务器一般会把长时间没有活动的<code>Session</code>从服务器内存清除，这个时长就看服务器自己的设置。</li><li><code>cookie</code>的内容可以包括：名字、值、过期时间、路径、域等，设置过期时间可以设置<code>cookie</code>的有效时长。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> Web </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue</title>
      <link href="/2021/01/01/web/Vue/"/>
      <url>/2021/01/01/web/Vue/</url>
      
        <content type="html"><![CDATA[<h3 id="一、首屏加载，性能优化"><a href="#一、首屏加载，性能优化" class="headerlink" title="一、首屏加载，性能优化"></a>一、首屏加载，性能优化</h3><h4 id="1-首屏时间"><a href="#1-首屏时间" class="headerlink" title="1. 首屏时间"></a>1. 首屏时间</h4><p>首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容</p><h4 id="2-如何计算"><a href="#2-如何计算" class="headerlink" title="2. 如何计算"></a>2. 如何计算</h4><p>利用<code>performance.timing</code>提供的数据，通过<code>DOMContentLoad</code>或者<code>performance</code>计算。</p><pre><code>// 方案一：document.addEventListener(&#39;DOMContentLoaded&#39;, (event) =&gt; {    console.log(&#39;first contentful painting&#39;);});// 方案二：performance.getEntriesByName(&quot;first-contentful-paint&quot;)[0].startTime</code></pre><h4 id="3-加载慢的可能"><a href="#3-加载慢的可能" class="headerlink" title="3. 加载慢的可能"></a>3. 加载慢的可能</h4><ol><li>网络延时；</li><li>资源体积过大；</li><li>代码问题，是否重复发送某些东西，重复发送请求；</li><li>加载脚本时，执行脚本是不是过久，堵塞渲染线程了；</li></ol><h4 id="4-解决方法"><a href="#4-解决方法" class="headerlink" title="4. 解决方法"></a>4. 解决方法</h4><ol><li>减少入口文件体积<ul><li>从<code>webpack</code>等构建工具可以入手，切分代码，<code>splitChunk</code>等</li><li>按需加载组件<code>import</code>引入</li></ul></li><li>静态资源本地缓存<ul><li>后端返回缓存，配合浏览器缓存机制进行缓存，强缓存或协商缓存<ul><li>回顾缓存机制：<a href="/2021/02/26/web/HTTP缓存">👉HTTP面试相关</a></li></ul></li><li>合理利用<code>Storage</code>机制，存储一些数据</li><li>CDN分发等机制进行</li></ul></li><li>UI框架按需加载<ul><li>例如加载<code>element-ui</code>、<code>ant-design-vue</code>这些组件的时候，是可以按需加载的</li></ul></li><li>图片资源压缩<ul><li>合并雪碧图等</li><li>webpack的<code>image-webpack-loader</code>进行压缩</li></ul></li><li>组件重复打包<ul><li><code>minChunks</code>可以将重复的文件，进行抽离，作为公共依赖</li></ul></li><li>开启<code>gzip</code><ul><li><code>nginx</code>可以进行gzip的压缩，及指定</li></ul></li></ol><h3 id="二、vue-diff"><a href="#二、vue-diff" class="headerlink" title="二、vue-diff"></a>二、vue-diff</h3><p><a href="/2020/01/17/2020/Vue-Diff">👉Vue-Diff</a></p><h3 id="三、defineProperty和Proxy"><a href="#三、defineProperty和Proxy" class="headerlink" title="三、defineProperty和Proxy"></a>三、defineProperty和Proxy</h3><h4 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h4><p>通过<code>defineProperty</code>设置<code>get</code>、<code>set</code>实现响应式</p><ol><li>监听不到对象属性的添加修改，因此需要使用<code>$set</code>；</li><li>数组API无法监听，Vue重写了Array才做到</li><li>需要对每个属性进行遍历监听，深层对象还要依次进行。</li></ol><h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p><code>Proxy</code>的监听是针对对象的，会对对象所有的操作进行监听，就完全可以代理所有属性。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li><code>defineProperty</code>只能对对象属性劫持</li><li><code>Proxy</code>可以劫持整个对象，并返回一个新对象</li><li><code>Proxy</code>可以监听数组的变化，有多达13中方法</li><li><code>Proxy</code>兼容性较差</li></ul><h3 id="四、keep-alive"><a href="#四、keep-alive" class="headerlink" title="四、keep-alive"></a>四、keep-alive</h3><p><a href="/2020/01/27/2020/Vue的Keep-alive">👉Vue, Keep-alive</a></p><h3 id="五、父子组件的生命周期"><a href="#五、父子组件的生命周期" class="headerlink" title="五、父子组件的生命周期"></a>五、父子组件的生命周期</h3><ol><li>加载过程</li></ol><ul><li>父<code>beforeCreate</code> -&gt; 父<code>created</code> -&gt; 父<code>beforeMount</code></li><li>子<code>beforeCreate</code> -&gt; 子<code>created</code> -&gt; 子<code>beforeMount</code> -&gt; 子<code>mounted</code></li><li>父<code>mounted</code></li></ul><ol start="2"><li>更新过程</li></ol><ul><li>父<code>beforeUpdate</code></li><li>子<code>beforeUpdate</code> -&gt; 子<code>updated</code></li><li>父<code>updated</code></li></ul><ol start="3"><li>销毁过程</li></ol><ul><li>父<code>beforeDestroy</code></li><li>子<code>beforeDestroy</code> -&gt; 子<code>destroyed</code></li><li>父<code>destroyed</code></li></ul><h3 id="六、Vue组件间的通信"><a href="#六、Vue组件间的通信" class="headerlink" title="六、Vue组件间的通信"></a>六、Vue组件间的通信</h3><ol><li>通过<code>props</code>传递</li><li>通过<code>$emit</code>触发事件</li><li>使用<code>ref</code><ul><li>父组件通过<code>ref</code>获取子组件实例，然后设置值</li></ul></li><li><p><code>EventBus</code></p><ul><li><p>兄弟组件间通信</p><pre><code>// 创建一个中央时间总线类  class Bus {   constructor() {     this.callbacks = {};   // 存放事件的名字   }   $on(name, fn) {     this.callbacks[name] = this.callbacks[name] || [];     this.callbacks[name].push(fn);   }   $emit(name, args) {     if (this.callbacks[name]) {       this.callbacks[name].forEach((cb) =&gt; cb(args));     }   }  }  // main.js  Vue.prototype.$bus = new Bus() // 将$bus挂载到vue实例的原型上  // 另一种方式  Vue.prototype.$bus = new Vue() // Vue已经实现了Bus的功能  </code></pre><p><code>Children1.vue</code>的使用</p><pre><code>this.$bus.$emit(&#39;foo&#39;)  </code></pre><p><code>Children2.vue</code>的使用</p><pre><code>this.$bus.$on(&#39;foo&#39;, this.handle)  </code></pre></li></ul></li><li><code>$parent</code>或<code>$root</code><ul><li>通过共同的祖辈，协调</li></ul></li><li><code>Provide</code>与<code>inject</code><ul><li>祖辈定义<code>provide</code>属性，返回传递的值<pre><code> provide(){       return {           foo:&#39;foo&#39;       }   } </code></pre></li><li>后代组件通过<code>inject</code>接收<pre><code>inject:[&#39;foo&#39;]</code></pre></li></ul></li><li><code>Vuex</code></li></ol><h3 id="七、为什么data属性是函数不是一个对象"><a href="#七、为什么data属性是函数不是一个对象" class="headerlink" title="七、为什么data属性是函数不是一个对象"></a>七、为什么<code>data</code>属性是函数不是一个对象</h3><p>在<code>initData</code>中，其实可以函数也可以对象</p><pre><code>function initData (vm: Component) {  let data = vm.$options.data  data = vm._data = typeof data === &#39;function&#39;    ? getData(data, vm)    : data || {}    ...}</code></pre><ul><li>原因：<ul><li><em>根实例对象</em>data可以是对象也可以是函数（根实例是单例），不会产生数据污染情况</li><li><em>组件实例对象</em>data必须为函数，目的是为了防止<em>多个组件实例对象之间共用一个data</em>，产生数据污染。采用函数的形式，initData时会将其作为工厂函数都会返回全新data对象</li></ul></li></ul><h3 id="八、new-Vue过程"><a href="#八、new-Vue过程" class="headerlink" title="八、new Vue过程"></a>八、new Vue过程</h3><p><code>new Vue</code> -&gt; <code>init</code> -&gt; <code>$mount</code> -&gt; <code>compile</code> -&gt; <code>render</code> -&gt; <code>vnode</code> -&gt; <code>patch</code> -&gt; <code>DOM</code></p><ol><li><p>init: 初始化一系列属性和方法，<code>initLifecycle(vm)</code>、<code>initEvents(vm)</code>、<code>initRender(vm)</code>、<code>callHook(vm, &#39;beforeCreate&#39;)</code>、<code>initInjections(vm)</code>、<code>initState(vm)</code>、<code>initProvide(vm)</code>、<code>callHook(vm, &#39;created&#39;)</code>…然后调用<code>$mount</code>挂载<code>el</code>元素。</p></li><li><p>$mount: 调用<code>compileToFunctions</code>生成<code>render</code>函数，然后再调用<code>mount</code>函数，执行<code>mountComponent</code>。</p></li><li><p>mountComponent: 完成整个渲染工作，使用<code>vm._render</code>、<code>vm._update</code></p></li><li><p>_render: 通过执行<code>createElement</code>并返回<code>vnode</code>，将DOM形成一个VNode Tree。</p><ul><li><em>VNode？</em>：<ul><li>VNode是对真实DOM的一种抽象描述，定义了一些关键属性，标签名，数据，子节点，数值等，用这种方式映射到真实DOM的渲染。</li><li>VNode映射到真实DOM还需要经历，<code>create</code>、<code>diff</code>、<code>patch</code>等过程，<code>create</code>是通过<code>createElement</code>创建的。</li></ul></li></ul></li><li><p>_update: 首次渲染或者数据更新时调用，核心是调用了<code>_patch_</code></p></li></ol><h3 id="九、Vue的响应式原理"><a href="#九、Vue的响应式原理" class="headerlink" title="九、Vue的响应式原理"></a>九、Vue的响应式原理</h3><p><a href="/2020/06/21/2020/Vue数据双向绑定原理">👉Vue, Vue数据双向绑定原理</a></p><p>三个概念: <code>Observer</code>、<code>Dep</code>、<code>Watcher</code></p><h4 id="发布者Observer"><a href="#发布者Observer" class="headerlink" title="发布者Observer"></a>发布者Observer</h4><p><code>Observer</code>扮演的角色是发布者，在<code>defineReactive</code>函数，使用<code>defineProperty</code>对对象的每一个子属性进行劫持\监听，为他们添加<code>get</code>、<code>set</code>，使之变成响应式。</p><p>初始化时<code>initState</code>函数，内部会执行<code>initState</code>、<code>initProps</code>、<code>initComputed</code>，分别对<code>data</code>、<code>prop</code>、<code>computed</code>进行初始化，响应。</p><ul><li><code>initProps</code>：遍历<code>props</code>进行遍历，调用<code>defineReactive</code>函数，并且通过<code>_proxy</code>将代理到<code>vm.xx</code>上，这样可以用<code>this</code>访问到。</li><li><code>data</code>：和<code>prop</code>相同，</li><li><code>initComputed</code>：创建一个观察者对象，对<code>computed</code>的属性，调用<code>defineComputed</code>方法，最终也是使用<code>defineProperty</code>使之变成响应式。</li></ul><h4 id="调度中心Dep"><a href="#调度中心Dep" class="headerlink" title="调度中心Dep"></a>调度中心Dep</h4><p><code>Dep</code>，在调用<code>defineReactive</code>将属性值变成响应式过程中，每个属性都实例化了一个<code>Dep</code>，主要是对<code>Watcher</code>进行管理，收集观察者和通知更新，当属性值改变的时候，会遍历观察者列表，<code>dep.subs</code>，通知所有的<code>watcher</code>，执行<code>update</code>逻辑。</p><ul><li><code>get</code>方法中，调用<code>dep.depend</code>方法，将观察者<code>Watcher</code>保存在内部，完成依赖收集。</li><li><code>set</code>方法中，调用<code>dep.notify</code>方法，通知观察者执行更新。</li></ul><h4 id="观察者-Watcher"><a href="#观察者-Watcher" class="headerlink" title="观察者-Watcher"></a>观察者-Watcher</h4><p><code>Watcher</code>角色是订阅者\观察者，会接收到调度中心<code>dep</code>的通知，触发回调行数。</p><h3 id="十、hash和history的区别"><a href="#十、hash和history的区别" class="headerlink" title="十、hash和history的区别"></a>十、hash和history的区别</h3><ol><li><code>hash</code>模式中，刷新页面的话，会看到请求的url不会携带<code>#</code>后的内容；而<code>history</code>模式下会将完整的url进行请求。</li><li><code>hash</code>模式下，修改<code>hash</code>浏览器并不会重新请求后端，只对前端自己的路由生效；而<code>history</code>模式下，会重新发起请求，容易出现错误，或者404，应该配合后台进行重定向处理。</li></ol><h3 id="十一、Vue-router原理"><a href="#十一、Vue-router原理" class="headerlink" title="十一、Vue-router原理"></a>十一、Vue-router原理</h3><p>拥有两种模式：</p><ol><li>hash</li><li>history</li></ol><p>核心：通过<code>Vue.use</code>注册插件，在插件的<code>install</code>中获取用户配置的<code>router</code>对象，当地址发生改变时，通过<code>router</code>对象匹配相应路由，获取组件，并渲染在视图上。</p><h3 id="十二、Vue的-router和-route区别"><a href="#十二、Vue的-router和-route区别" class="headerlink" title="十二、Vue的$router和$route区别"></a>十二、Vue的$router和$route区别</h3><ul><li><code>this.$route</code>：当前激活的路由信息对象，每个对象都是局部的，可以获取当前路由的<code>path</code>、<code>name</code>、<code>query</code>。</li><li><code>this.$router</code>：全局的<code>router</code>实例，通过Vue根实例注入，再注入每一个子组件，里面包括了很多属性和对象，例如<code>push()</code>、<code>replace()</code>等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Web </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS</title>
      <link href="/2021/01/01/web/JS/"/>
      <url>/2021/01/01/web/JS/</url>
      
        <content type="html"><![CDATA[<h4 id="call、apply、bind、new函数模拟"><a href="#call、apply、bind、new函数模拟" class="headerlink" title="call、apply、bind、new函数模拟"></a>call、apply、bind、new函数模拟</h4><p>👉： <a href="/2019/01/24/2019/手写new-call-apply-bind">函数模拟</a></p><a id="more"></a><h4 id="柯里化函数"><a href="#柯里化函数" class="headerlink" title="柯里化函数"></a>柯里化函数</h4><pre><code>function curry(fn, args) {    var length = fn.length; // function.length即参数个数, 此处为3    var args_ = args || [];    return function() {        var _args = args_.slice(0), args, i;        for(i = 0; i &lt; arguments.length; i++) {            args = arguments[i];            _args.push(args);        }        if(_args.length &lt; length) { // 与预设参数个数的比较            return curry.call(this, fn, _args);        } else {            return fn.apply(this, _args);        }    }}var fn = curry(function(a, b, c) {    console.log([a, b, c]);})fn(2, 3, 4, 5);fn(2)(3)(4);</code></pre><h4 id="函数合成Compose"><a href="#函数合成Compose" class="headerlink" title="函数合成Compose"></a>函数合成Compose</h4><blockquote><p>示例：</p><pre><code>var add = function (x) { return x + 5; }  //加法允许var mul= function (x) { return x * 5; }  //乘法运算var sub= function (x) { return x - 5; }  //减法运算var div = function (x) { return x / 5; }  //除法运算var fn = compose(add, mul, sub, div);</code></pre></blockquote><p><em>解答：</em></p><pre><code>var compose = function () {    var _arguments = arguments;  //缓存外层函数    var length = _arguments.length;  //缓存长度    var index = length;  //定义游标变量    //检测函数，如果存在非函数参数，则抛出异常    while (index --) {        if (typeof _arguments[index] !== &#39;function&#39;) {            throw new TypeError(&#39;参数必须为函数！&#39;);        }    }    return function () {        var index = length - 1;  //定位到最后一个参数下标        //如果存在两个及以上参数，则调用最后一个参数函数，并传入内层函数；否则直接返回第 1 个参数函数。        var result = length ? _arguments[index].apply(this, arguments) : arguments[0];        //迭代参数函数        while (index -- ) {            //把右侧函数的执行结果作为参数传给左侧参数函数，并调用。            result = _arguments[index].call(this, result);        }        return result;  //返回最左侧参数函数的执行结果    }}</code></pre><h4 id="JS-EventLoop"><a href="#JS-EventLoop" class="headerlink" title="JS EventLoop"></a>JS EventLoop</h4><p>👉：<a href="/2020/06/12/2020/EventLoop">EventLoop</a></p><h4 id="节流-防抖"><a href="#节流-防抖" class="headerlink" title="节流? 防抖?"></a>节流? 防抖?</h4><p>防抖: 在事件被触发n秒内再执行回调，若n秒内再次触发，则重新开始计时。<br>节流: 每隔一段时间，只执行一次函数。<br>区别：</p><ul><li>在timer存在时，处理方式不同</li><li>执行结束后，节流会使timer = null;</li></ul><p>防抖：</p><pre><code>function debounce(fn, delay) {    var timer;    return funtion() {        var _this = this;        var args = arguments;        if(timer) {            clearTimeout(timer);        }        timer = setTimeout(function() {            fn.apply(_this, args);        }, delay);    }}</code></pre><p>节流：</p><pre><code>function throttle(fn, delay) {    var timer;    return function() {        var _this = this;        var args = arguments;        if(timer) {            return; // return         }        timer = setTimeout(function() {            fn.apply(_this, args);            timer = null;        }, delay);    }}</code></pre><h4 id="async函数原理"><a href="#async函数原理" class="headerlink" title="async函数原理"></a>async函数原理</h4><p>👉：<a href="/2020/06/30/2020/async-await原理">Async/await原理</a></p><h4 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h4><p>👉：<a href="/2020/05/11/2020/cors跨域">跨域请求</a></p><h4 id="XSS、CSRF"><a href="#XSS、CSRF" class="headerlink" title="XSS、CSRF"></a>XSS、CSRF</h4><p>👉：<a href="/2020/08/11/2020/XSS-CSRF">XSS、CSRF相关</a></p><h4 id="JS类型判断"><a href="#JS类型判断" class="headerlink" title="JS类型判断"></a>JS类型判断</h4><ol><li><p>typeof</p><pre><code>tyepof &#39;&#39;; // stringtypeof 1; // numbertypeof Symbol(); // Symboltypeof true; // booleantypeof undefined; // undefinedtypeof null; // object(无效)typeof []; // object(无效)typeof new Function(); // object(无效)typeof new Date(); // object(无效) </code></pre></li><li><p>instanceof<br>instanceof的机制是检测构造函数的prototype属性是否出现在某个实例对象的原型链上，是则返回true，否则false。</p></li><li><p>constructor<br>函数的constructor是不稳定的，这个主要是如果是自定义对象，重写prototype之后，原有的constructor会丢失。</p><pre><code>&#39;&#39;.constructor == String // truenew Number(1).constructor == Number // truetrue.constructor == Boolean // truenew Function().constructor == Function // truenew Date().constructor == Date // truenew Error().constructor == Error // true[].constructor == Array // true</code></pre></li><li>toString<br>toString()是调用Object的原型方法，调用该方法，但会当前对象Class</li></ol><pre><code>Object.prototype,toString.call(&#39;&#39;); // [object String]Object.prototype,toString.call(1); // [object Number]Object.prototype,toString.call(true); // [object Boolean]Object.prototype,toString.call(Symbol()); // [object Symbol]Object.prototype,toString.call(undefined); // [object Undefined]Object.prototype,toString.call(null); // [object Null]Object.prototype,toString.call(new Function()); // [object Function]Object.prototype,toString.call(new Date()); // [object Date]Object.prototype,toString.call([]); // [object Array]Object.prototype,toString.call(new Error()); // [object Error]Object.prototype,toString.call(document); // [object HTMLDocument]</code></pre><h4 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h4><p>👉：<a href="/2019/10/17/2019/this指向">this指向</a></p><h4 id="JS垃圾回收机制"><a href="#JS垃圾回收机制" class="headerlink" title="JS垃圾回收机制"></a>JS垃圾回收机制</h4><p>👉：<a href="/2020/09/23/2020/垃圾回收机制">垃圾回收机制</a></p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。<br>其实简单了讲就是：在函数外拿到了函数内的变量(个人理解)。</p><pre><code>function makeFun() {    var name = &#39;haveFun&#39;;    function displayName() {        console.log(name);    }    return displayName;}var test = makeFun();test();</code></pre><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>👉：<a href="/2019/12/15/2019/JS原型链">原型链</a></p><h4 id="JS模块化演进"><a href="#JS模块化演进" class="headerlink" title="JS模块化演进"></a>JS模块化演进</h4><p>👉：<a href="/2020/09/28/2020/JS模块化演进">模块化</a></p><h4 id="JS继承"><a href="#JS继承" class="headerlink" title="JS继承"></a>JS继承</h4><p>👉：<a href="/2019/01/23/2019/JavaScript继承">JS继承</a></p><h4 id="JS手写Promise"><a href="#JS手写Promise" class="headerlink" title="JS手写Promise"></a>JS手写Promise</h4><p>👉：<a href="/2021/04/01/2021/JS手写Promise">JS手写Promise</a></p><h4 id="浏览器进程相关"><a href="#浏览器进程相关" class="headerlink" title="浏览器进程相关"></a>浏览器进程相关</h4><p>👉：<a href="/2021/04/12/2021/浏览器的多线程">浏览器的多线程</a></p><h4 id="JS设计模式相关"><a href="#JS设计模式相关" class="headerlink" title="JS设计模式相关"></a>JS设计模式相关</h4><p>👉：<a href="/2020/09/29/2020/JS设计模式">JS设计模式</a></p><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p>👉： <a href="/2021/04/02/2021/十大排序">JSer要了解的排序</a> </p><h4 id="WeakSet、WeakMap、Set、Map"><a href="#WeakSet、WeakMap、Set、Map" class="headerlink" title="WeakSet、WeakMap、Set、Map"></a>WeakSet、WeakMap、Set、Map</h4><ol><li><p>WeakSet与Set的区别：</p><ul><li><code>WeakSet</code>只能存储对象的引用，不能存放值，存放值会报错❗<ul><li>例如，<code>a = new WeakSet(); a.add(1);</code> 报错❗</li></ul></li><li><code>WeakSet</code>对象中存储的对象值都是弱引用，即垃圾回收机制不考虑<code>WeakSet</code>对该对象的引用，如果对象没别的引用，垃圾回收机制启动后，成员可能会被清；</li><li><code>WeakSet</code>对象是无法遍历的，也没办法它包含的所有元素。</li></ul></li><li><p>WeakMap与Map的区别：</p><ul><li><code>WeakMap</code>的弱引用只是键名字，而不是键值；</li><li><code>WeakMap</code>的key是不可枚举的。</li></ul></li></ol><h4 id="ESLint的运行原理"><a href="#ESLint的运行原理" class="headerlink" title="ESLint的运行原理"></a>ESLint的运行原理</h4><p>每一条规则都是一个暴露的<code>node</code>模块，包含两个属性<code>meta</code>、<code>create</code></p><ol><li>将代码解析成<code>AST</code></li><li>深度遍历<code>AST</code>，监听匹配过程<ul><li>拿到<code>AST</code>之后，<code>ESLint</code>会<em>从上到下</em>再<em>从下到上</em>的顺序遍历每个选择器</li></ul></li><li>触发监听选择器的<code>rule</code>回调<ul><li>生效的规则会对一个或多个选择器进行监听，匹配到选择器，就会触发对应的回调</li></ul></li></ol><h4 id="JS的严格模式"><a href="#JS的严格模式" class="headerlink" title="JS的严格模式"></a>JS的严格模式</h4><ol><li>消除<code>JS</code>语法的一些不合理、不严谨的地方，减少怪异行为；</li><li>消除代码运行的不安全地方；</li><li>提高编译器效率，增加运行速度；</li></ol><p><em>注意</em></p><ul><li>变量必须声明后再使用</li><li>函数参数不能有同名属性</li><li>不能使用<code>with</code>语句</li><li>不能使用前缀0表示八进制数</li><li><code>eval</code>和<code>arguments</code>不能被重新赋值</li><li>禁止<code>this</code>指向全局对象</li><li>…</li></ul><h4 id="JS深拷贝"><a href="#JS深拷贝" class="headerlink" title="JS深拷贝"></a>JS深拷贝</h4><p><em>转载</em>：<a href="https://juejin.cn/post/6889327058158092302#heading-3" target="_blank" rel="noopener">这一次彻底掌握深拷贝</a></p><ul><li>基本数据类型：直接存储在栈内存中的数据。</li><li>引用数据类型：在栈中存储了指针，指针指向堆中的实体内存地址。</li></ul><p>浅拷贝只是复制了指向内存地址的指针，但是并不会复制对象本身。</p><ol><li>一些库函数进行，例如：<code>lodash</code></li><li><code>JSON.parse(JSON.stringify)</code><ul><li>不足之处：<ul><li>拷贝对象中不能有函数</li><li>对象中不能有<code>undefined</code></li><li>对象中不能有正则<code>RegExp</code></li><li>Date类型会被转化为字符串类型</li><li>对象不能有环，会报错</li></ul></li></ul></li><li><p>实现</p><ul><li>简单类型拷贝<pre><code>  function deepClone(target) {      return target;  }</code></pre></li><li>拷贝简单对象，有局限，要么是对象，要是是简单数据<pre><code>  function deepClone(target) {      if(target instanceof Object) {          let dist = {};          for(let key in target) {              dist[key] = deepClone(target[key]);          }          return dist;      } else {          return target;      }  }</code></pre></li><li>拷贝数组对象<pre><code>  function deepClone(target) {      if(target instanceof Object) {          let dist = {};          // 数组的情况          if(target instanceof Array) {              dist = [];          }          for(let key in target) {              dist[key] = deepClone(target[key]);          }          return dist;      } else {          return target;      }  }</code></pre></li><li>拷贝函数<pre><code>  function deepClone(target) {      if(target instanceof Object) {          let dist = {};          // 数组的情况          if(target instanceof Array) {              dist = [];          } else if(target instanceof Function) {              dist = function() {                  return target.call(this, ...arguments);              }          }          for(let key in target) {              dist[key] = deepClone(target[key]);          }          return dist;      } else {          return target;      }  }</code></pre></li><li>拷贝正则<pre><code>  function deepClone(target) {      if(target instanceof Object) {          let dist = {};          // 数组的情况          if(target instanceof Array) {              dist = [];          } else if (target instanceof Function) { // 函数的情况              dist = function() {                  return target.call(this, ...arguments);              }          } else if (target instanceof RegExp) { // 正则的情况              dist = new RegExp(target.source, target.flags);          }          for(let key in target) {              dist[key] = deepClone(target[key]);          }          return dist;      } else {          return target;      }  }</code></pre></li><li>拷贝日期<pre><code>  function deepClone(target) {      if(target instanceof Object) {          let dist = {};          // 数组的情况          if(target instanceof Array) {              dist = [];          } else if (target instanceof Function) { // 函数的情况              dist = function() {                  return target.call(this, ...arguments);              }          } else if (target instanceof RegExp) { // 正则的情况              dist = new RegExp(target.source, target.flags);          } else if (target instanceof Date){              dist = new Date(target);          }          for(let key in target) {              dist[key] = deepClone(target[key]);          }          return dist;      } else {          return target;      }  }</code></pre></li><li>…</li></ul></li><li><p>环形，循环引用的问题</p><ul><li><p>可以引入<code>map</code>做缓存记录，<code>Map</code>可以用复杂对象作为<code>key</code></p><pre><code>  let cache = new Map();  function deepClone(target){      // 判断是否缓存      if(cache.get(target)){          return cache.get(target)      }      if(target instanceof Object){          // ...省略          // 将属性和拷贝后的值作为一个map          cache.set(target, dist);          for(let key in target){              // 过滤掉原型身上的属性              if (target.hasOwnProperty(key)) {                  dist[key] = deepClone(target[key]);              }          }          return dist;      }else{          return target;      }  }</code></pre></li></ul></li></ol><h4 id="let、var、const"><a href="#let、var、const" class="headerlink" title="let、var、const"></a>let、var、const</h4><ol><li><p><code>var</code>: </p><ul><li>在最外层声明时，作用域是全局的；在函数中声明时，作用域是局部的</li><li><code>var</code>可以重新声明与修改</li><li><code>var</code>的变量提升，前面的执行到了，会变成<code>undefined</code></li></ul></li><li><p><code>let</code></p><ul><li><code>let</code>是块级作用域</li><li><code>let</code>可以修改，但是不能重新声明</li><li><code>let</code>也会被提升，提升到作用域顶部，但不会赋予初始值，如果声明前使用，会报错</li></ul></li><li><code>const</code><ul><li><code>const</code>声明在作用域内</li><li><code>const</code>不能被修改，也不能重新声明</li><li>声明<code>const</code>时候必须初始化</li></ul></li></ol><h4 id="instanceof原理"><a href="#instanceof原理" class="headerlink" title="instanceof原理"></a>instanceof原理</h4><p><code>instanceof</code>主要是判断一个实例是否属于某一个类型，原理类似于取左表达式<code>__proto__</code>与右表达式<code>prototype</code>进行相等判断</p><pre><code>function new_instance_of(leftVaule, rightVaule) {     let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值    leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值    while (true) {        if (leftVaule === null) {            return false;            }        if (leftVaule === rightProto) {            return true;            }         leftVaule = leftVaule.__proto__     }}</code></pre><h4 id="e-target与e-currentTarget的区别"><a href="#e-target与e-currentTarget的区别" class="headerlink" title="e.target与e.currentTarget的区别"></a>e.target与e.currentTarget的区别</h4><ol><li><code>e.target</code>指向触发事件的元素</li><li><code>e.currentTarget</code>指向添加监听事件的元素</li></ol><p><em>未完待续…</em></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Web </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>interview</title>
      <link href="/2021/01/01/web/interview/"/>
      <url>/2021/01/01/web/interview/</url>
      
        <content type="html"><![CDATA[<p>收集整理的前端面试相关…</p><p><img src="/2021/01/01/web/interview/MO1.png" alt="NO1" title="NO1"></p><a id="more"></a><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><p>👉： <a href="/2021/01/01/web/JS">JS面试相关</a></p><h2 id="CSS-amp-HTML"><a href="#CSS-amp-HTML" class="headerlink" title="CSS&amp;HTML"></a>CSS&amp;HTML</h2><p>👉： <a href="/2021/01/01/web/CSS">CSS、HTML面试相关</a></p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>👉： <a href="/2021/01/01/web/HTTP">HTTP面试相关</a></p><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>👉： <a href="/2021/01/01/web/webpack">webpack面试相关</a></p><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>👉： <a href="/2021/01/01/web/Vue">Vue面试相关</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebPack</title>
      <link href="/2021/01/01/web/webpack/"/>
      <url>/2021/01/01/web/webpack/</url>
      
        <content type="html"><![CDATA[<h2 id="一、tree-Shaking"><a href="#一、tree-Shaking" class="headerlink" title="一、tree Shaking"></a>一、tree Shaking</h2><p>树摇，在保持代码运行结果不变的情况下，去除无用代码。<code>webpack</code>生产模式下会自动启用</p><ul><li>借助了<code>ES6</code>模块的静态编译，在编译时确定模块的依赖关系。</li></ul><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><ol><li>只能作为模块顶层语句出现；</li><li><code>import</code>的模块名只能是字符串常量；</li><li>依赖<code>ES6 Module</code>特性。</li></ol><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><ol><li>编译阶段利用<code>es6 Module</code>判断哪些模块已经加载；</li><li>判断那些模块和变量未被使用或者引用，进而删除对应代码。</li></ol><h2 id="二、借助Webpack优化前端性能"><a href="#二、借助Webpack优化前端性能" class="headerlink" title="二、借助Webpack优化前端性能"></a>二、借助Webpack优化前端性能</h2><ol><li>JS代码压缩<ul><li>webpack可以默认使用<code>TerserPlugin</code>处理</li></ul></li><li>CSS代码压缩<ul><li>可以使用<code>css-minimizer-webpack-plugin</code>插件去除无用空格</li></ul></li><li>HTML文件代码压缩</li><li>文件大小压缩<ul><li>使用<code>compression-webpack-plugin</code>文件的压缩，压缩方式，大小等</li></ul></li><li>图片压缩<ul><li><code>image-webpack-loader</code>图片压缩也较为重要，一般图片都比较大</li></ul></li><li>TreeShaking<ul><li>webpack实现<code>tree shaking</code>有两种方案<ul><li><code>usedExports</code>: 通过标记某些函数是否被使用，之后通过Terser来进行优化的；</li><li><code>sideEffects</code>: 跳过整个模块/文件，直接查看该文件是否有副作用。<pre><code>  {      &quot;name&quot;: &quot;your-project&quot;,      &quot;sideEffects&quot;: false  }</code></pre><ul><li>如果所有代码都不包含副作用，我们就可以简单地将该属性标记为 false，来告知 webpack 它可以安全地删除未用到的 export</li></ul></li></ul></li><li><a href="https://webpack.js.org/guides/tree-shaking/" target="_blank" rel="noopener">👉Webpack-tree-shaking介绍</a></li></ul></li><li>代码分离<ul><li>可以通过配置<code>splitChunksPlugin</code>实现，分割例如element呀之类的…<pre><code>  config.optimization.splitChunks({      cacheGroups: {          elementUI: {              name: &#39;element&#39;,              priority: 20,              test: /[\\/]node_modules[\\/]_?element-ui(.*)/,              chunks: &#39;all&#39;          },          highcharts: {              name: &#39;highcharts&#39;,              priority: 20,              test: /[\\/]node_modules[\\/]_?highcharts(.*)/,              chunks: &#39;all&#39;          }      }  })</code></pre></li><li>splitChunks主要有以下属性:<ul><li><code>Chunks</code>: 对同步代码还是异步代码进行处理；</li><li><code>minSize</code>: 拆分包的大小, 至少为minSize，如何包的大小不超过minSize，这个包不会拆分；</li><li><code>maxSize</code>:  将大于maxSize的包，拆分为不小于minSize的包；</li><li><code>minChunks</code>: 被引入的次数，默认是1。</li><li><code>cacheGroups</code>: 包含<code>name</code>、<code>chunks</code>两个属性：<ul><li>name：提取出来的公共模块将会以这个来命名，可以不配置；</li><li>chunks：指定哪些类型的chunk参与拆分，<code>all</code>、<code>async</code>、<code>initial</code>。</li><li>priority：priority属性的值为数字，可以为负数。作用是当缓存组中设置有多个拆分规则，而某个模块同时符合好几个规则的时候，则需要通过优先级属性priority来决定使用哪个拆分规则</li><li>test: test的值可以是一个正则表达式，也可以是一个函数。它可以匹配模块的绝对资源路径或chunk名称</li></ul></li></ul></li></ul></li><li>内联chunk</li></ol><h2 id="三、提高webpack的构建速度（dev）"><a href="#三、提高webpack的构建速度（dev）" class="headerlink" title="三、提高webpack的构建速度（dev）"></a>三、提高webpack的构建速度（dev）</h2><ol><li>优化loader配置<ul><li>通过<code>include</code>、<code>exclude</code>、<code>test</code>属性配置文件，优化loader的一些查找</li></ul></li><li>合理使用<code>resolve.extensions</code><ul><li>通过配置合适的文件扩展名，加快文件寻找匹配的速度</li></ul></li><li>优化<code>resolve.modules</code><ul><li>默认是<code>node_modules</code>，配置的目录也可以减少寻找</li></ul></li><li>优化<code>resolve.alias</code><ul><li><code>alias</code>可以给常用路径起别名，可以减少查找过程</li></ul></li><li>使用<code>cache-loader</code><ul><li>可以在loader之前添加<code>cache-loader</code>，将结果缓存在磁盘中，显著提升二次构建速度<pre><code>  module.exports = {      module: {          rules: [              {                  test: /\.ext$/,                  use: [&#39;cache-loader&#39;, ...loaders],                  include: path.resolve(&#39;src&#39;),              },          ],      },  };</code></pre></li></ul></li><li><code>terser</code>启动多线程<ul><li><code>terser</code>启动多线程<pre><code>  module.exports = {      optimization: {          minimizer: [              new TerserPlugin({                  parallel: true,              }),          ],      },  };</code></pre></li></ul></li><li>合理使用<code>sourceMap</code><ul><li>source-map(build)</li><li>inline-source-map(dev)</li><li>none(build)</li><li>eval(dev)</li><li>…</li></ul></li><li>可以使用<code>externals</code>不将文件打包入bundle，而采用引入cdn的方式。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> Interview </tag>
            
            <tag> WebPack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stylus_media</title>
      <link href="/2020/12/26/2020/stylus-media/"/>
      <url>/2020/12/26/2020/stylus-media/</url>
      
        <content type="html"><![CDATA[<p>渲染字体响应</p><pre><code>media_queries = {  small: &quot;only screen and (width: 1366px)&quot;,  big: &quot;only screen and (width: 1920px)&quot;}fontSizeIter(smallSize, bigSize)    +for_fontSize(small)        fontSize(smallSize)    +for_fontSize(big)        fontSize(bigSize)for_fontSize(breakpoints)  conditions = ()  for breakpoint in breakpoints    push(conditions, media_queries[breakpoint])  conditions = join(&quot;&quot;, conditions)  @media conditions    {block}fontSize($size)  font-size $size#unicomView    .font-12-17        fontSizeIter(12px, 17px)    .font-14-20        fontSizeIter(14px, 20px)    .font-16-22        fontSizeIter(16px, 22px)    .font-24-34        fontSizeIter(24px, 34px)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Stylus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My</title>
      <link href="/2020/12/01/2020/My/"/>
      <url>/2020/12/01/2020/My/</url>
      
        <content type="html"><![CDATA[<p>今年，最大的收获，就是，疫情期间，开始给自己做大厨了…</p><p><img src="/2020/12/01/2020/My/NO12.jpg" alt="NO12" title="NO12"></p><p><strong>丢人现菜😏</strong></p><a id="more"></a><p><img src="/2020/12/01/2020/My/NO1.jpg" alt="NO1" title="NO1"></p>]]></content>
      
      
      <categories>
          
          <category> 读书V生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常碎碎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络七层结构</title>
      <link href="/2020/11/05/2020/%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82%E7%BB%93%E6%9E%84/"/>
      <url>/2020/11/05/2020/%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>网络的七层结构指OSI七层协议模型，分别是：应用层、表示层、会话层、传输层、网络层、链路层、物理层。</p><a id="more"></a><table><thead><tr><th>模型层</th><th>主要协议</th><th>单位</th></tr></thead><tbody><tr><td>应用层</td><td>FTP、HTTP…</td><td>数据流</td></tr><tr><td>表示层</td><td>HTML、JSON、XML..</td><td>数据流</td></tr><tr><td>会话层</td><td>FTP、SSH、TLS…</td><td>数据流</td></tr><tr><td>传输层</td><td>TCP、UDP</td><td>数据段</td></tr><tr><td>网络层</td><td>IP、ICMP..</td><td>数据包</td></tr><tr><td>链路层</td><td>HDLC..</td><td>帧</td></tr><tr><td>物理层</td><td>V.35 …</td><td>比特流</td></tr></tbody></table><p><em>主要</em></p><table><thead><tr><th>结构名</th><th>功能</th><th>主要设备</th></tr></thead><tbody><tr><td>应用层</td><td>确定通信对象，提供访问网络服务的接口</td><td>网关</td></tr><tr><td>表示层</td><td>负责数据的编码，转化，压缩，解压，加密解密等</td><td>网关</td></tr><tr><td>会话层</td><td>负责建立、维护、控制会话单工、双工、半双工等模式</td><td>网关</td></tr><tr><td>传输层</td><td>负责分割、组合数据，实现端到端的逻辑连接及三次握手…</td><td>网关</td></tr><tr><td>网络层</td><td>负责管理网络地址，定位设备，决定路由</td></tr><tr><td>链路层</td><td>负责物理传输， CRC校验，错误通知</td><td>交换机，网桥，网卡</td></tr><tr><td>物理层</td><td>实实在在的物理链路</td><td>电缆等</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP常见状态码</title>
      <link href="/2020/10/28/2020/HTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>/2020/10/28/2020/HTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p>在XMLHttpRequest请求中，也有五个状态码:</p><p>XMLHttpRequest的状态码：<br>0— 未初始化，尚未调用open()方法<br>1—启动，已经调用open()方法，并未send()<br>2—发送，已经send,但未收到响应<br>3—接收<br>4—完成</p><p>HTTP的状态码：</p><a id="more"></a><h4 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h4><p>表示请求已经接受，需要继续处理，HTTP/1.0协议中没有定义1xx状态码，除非在某些实验下，否则服务器禁止发送1xx响应</p><h5 id="100-Continue"><a href="#100-Continue" class="headerlink" title="100 Continue"></a>100 Continue</h5><p>服务端已经接收，且仍未拒绝，客户端应该继续请求</p><h4 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h4><h5 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h5><p>请求已经成功，响应与数据都随此返回。</p><h5 id="202-Accepted"><a href="#202-Accepted" class="headerlink" title="202 Accepted"></a>202 Accepted</h5><p>服务器已经接收请求，但尚未处理；<br>返回目的是允许服务器执行其他过程请求，例如每天执行一次的批请求，不必让客户端与服务器一直连接等待完成，所有可以先返回202。</p><h5 id="204-Not-Content"><a href="#204-Not-Content" class="headerlink" title="204 Not Content"></a>204 Not Content</h5><p>服务器已经处理请求，但没有返回任何实体内容，浏览器显示的页面不会发生更新</p><h5 id="205-Reset-Content"><a href="#205-Reset-Content" class="headerlink" title="205 Reset Content"></a>205 Reset Content</h5><p>服务器成功处理请求，且没有返回任何实体内容，但希望请求者重置文档视图，更新浏览器页面，这一点与204不同，例如重置表单</p><h5 id="Partial-Content"><a href="#Partial-Content" class="headerlink" title="Partial Content"></a>Partial Content</h5><p>服务器成功处理部分GET请求，类似FlashGet或者迅雷这里HTTP下载工具，使用这种响应断点续传或者下载，返回之后让用户自行选择下载之类的行为</p><h4 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h4><p>3xx这类状态码需要客户端采取进一步操作，才能完成请求，一般是重定向问题，当且请求的方法是GET或者HEAD时，浏览器才会自动提交执行后续操作，一般尝试次数不超过五次</p><h5 id="301-Moved-Permanently-永久重定向"><a href="#301-Moved-Permanently-永久重定向" class="headerlink" title="301 Moved Permanently    永久重定向"></a>301 Moved Permanently    永久重定向</h5><p>请求资源已经永久移动到新位置，返回的是新URI在响应的location域，如果不是<code>GET</code>或<code>HEAD</code>，浏览器将禁止重定向</p><h5 id="302-Found-临时重定向"><a href="#302-Found-临时重定向" class="headerlink" title="302 Found    临时重定向"></a>302 Found    临时重定向</h5><p>请求的资源临时从不同的URL中请求，这样的重定向是临时的</p><h5 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h5><p>请求的资源中存在另一个URL，将重定向使用GET方法获取，与302的区别是302不会改变请求的方法，对于303使用POST请求后，重定向会转为GET方法</p><h5 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h5><p>客户端发送附带条件的GET请求后，服务器处理而返回的文档内容自从上次访问依赖没有改变，则服务器返回这个状态码，例如在协商缓存的情况下，获取资源</p><p><em>浏览器缓存复习</em></p><p>👉：<a href="/2021/02/26/2021/HTTP缓存">HTTP缓存机制</a></p><h5 id="307-Temporart-Redirect"><a href="#307-Temporart-Redirect" class="headerlink" title="307 Temporart Redirect"></a>307 Temporart Redirect</h5><p>请求的资源临时从不同URL中响应，这样的重定向是临时的<br>307不指定客户端用什么样的请求方法，与302、303不同，不改变方法</p><h4 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h4><p>客户端发生错误</p><h5 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h5><p>包含语法错误，当前请求无法被理解，客户端修改后再试</p><h5 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h5><p>需要认证？</p><h5 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h5><p>服务器理解客户请求，但拒绝处理它，资源不可用，通常服务器上文件或者目录设置导致，例如在nginx转发，上次文件超过nginx大小限制时。</p><h5 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h5><p>服务器找不到指定资源，通常被用于不想透露拒绝请求的原因，可参看403</p><h5 id="405-Method-Not-Allowed"><a href="#405-Method-Not-Allowed" class="headerlink" title="405 Method Not Allowed"></a>405 Method Not Allowed</h5><p>请求的方法无法同于请求响应的资源，返回的响应会指明Allow接受的请求方法</p><h4 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h4><p>服务器本身出错，或者没有足够的能力来处理请求，有异常状态</p><h5 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h5><p>服务器遇到未曾预料的状态，导致无法完成请求处理</p><h5 id="501-Not-Implemented"><a href="#501-Not-Implemented" class="headerlink" title="501 Not Implemented"></a>501 Not Implemented</h5><p>服务器不支持当前请求所需要的功能，服务器无法识别请求的方法</p><h5 id="502-Bad-Gateway"><a href="#502-Bad-Gateway" class="headerlink" title="502 Bad Gateway"></a>502 Bad Gateway</h5><p>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应，也就是中转的那个服务器收到更上层服务器的无效响应，例如在nginx代理的时候，断网的时候。</p><h5 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h5><p>服务器临时维护，服务器当前无法处理请求，在一段时间后恢复；</p><h5 id="504-Gateway-Timeout"><a href="#504-Gateway-Timeout" class="headerlink" title="504 Gateway Timeout"></a>504 Gateway Timeout</h5><ol><li>作为网关或代理工作的服务器尝试执行请求时，<strong>未能及时</strong>从上游服务器接收到响应；</li><li><strong>与502的区别</strong>，502已经建立了连接，但超时，504与后端连接未建立，超时。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS设计模式</title>
      <link href="/2020/09/29/2020/JS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/09/29/2020/JS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h3><p>本篇将介绍以下几种设计模式：</p><ol><li>构造器模式</li><li>模块化模式</li><li>暴露模块模式</li><li>单例模式</li><li>观察者模式</li><li>发布订阅模式</li><li>中介者模式</li><li>原型模式</li><li>命令模式</li><li>外观模式</li><li>工厂模式</li><li>Mixin模式</li><li>装饰模式</li><li>MVC模式</li><li>创建者模式</li></ol><a id="more"></a><p>对于JSer来说，可能实际开发上用到的可能会没有那么多，但是学学也不错😭，（本菜可能接触的也不过几种）。</p><h4 id="构造器模式"><a href="#构造器模式" class="headerlink" title="构造器模式"></a>构造器模式</h4><ol><li>构造函数：<br>在这个构造器内部，关键字this引用到刚被创建的对象。回到对象创建，一个基本的构造函数看起来像这样:</li></ol><pre><code>function Car(model, year, miles) {    this.model = model;    this.year = year;    this.miles = miles;    this.toString = function() {        return `${this.model} + ${this.year} + ${this.miles}`;    }}var civic = new Car( &quot;Honda Civic&quot;, 2009, 20000 );var mondeo = new Car( &quot;Ford Mondeo&quot;, 2010, 5000 );console.log(civic.toString());</code></pre><p>缺陷: 每个对象都会带上 <code>toString</code> 之类的函数</p><ol start="2"><li>原型链版构造器</li></ol><pre><code>function Car_prop( model, year, miles ) {    this.model = model;    this.year = year;    this.miles = miles;}Car_prop.prototype.toString = function () {    return this.model + &quot; has done &quot; + this.miles + &quot; miles&quot;;};var civic_prop = new Car_prop( &quot;Honda Civic&quot;, 2009, 20000 );var mondeo_prop = new Car_prop( &quot;Ford Mondeo&quot;, 2010, 5000 );console.log(civic_prop.toString());</code></pre><h4 id="模块化模式"><a href="#模块化模式" class="headerlink" title="模块化模式"></a>模块化模式</h4><ol><li>模块化模式最初被定义为一种对传统软件工程中的类提供私有和公共封装的方法。</li><li>通过这种方式 可以在单一对象中包含公共/私有方法和变量</li></ol><pre><code>var testModuleMode = (function() {    var counter = 0;    return {        incrementCounter: function() {            return counter++;        },        resetCounter: function() {            console.log(`reset counter`);            counter = 0;        }    }})();testModule.incrementCounter();testModule.resetCounter();</code></pre><p><em>进阶</em></p><p>包含了命名控件，公共变量，私有变量，潜藏闭包的形式</p><pre><code>var mySpaceName = (function() {    var myPrivateVar = 0;    var myPrivateMethod = function(foo) {        console.log(foo);    }    return {        myPublicVar: &#39;Foo&#39;,        muPubliceMethod: function(bar) {            myPrivateVar++;            myPrivateMethod(bar)        }    }})</code></pre><p>缺陷：定义了公共/私用成员 但是要改的时候 就得在成员的方法上修改代码</p><h4 id="暴露模块模式"><a href="#暴露模块模式" class="headerlink" title="暴露模块模式"></a>暴露模块模式</h4><ol><li>我们可以简单地在私有域中定义我们所有的函数和变量，并且返回一个匿名对象，这个对象包含有一些指针，这些指针指向我们想要暴露出来的私有成员，使这些私有成员公有化</li><li>这个模式可以用于将私有函数和属性以更加规范的命名方式展现出来。</li></ol><pre><code>var myRevealingModule = function () {    var privateVar = &quot;Ben Cherry&quot;,        publicVar  = &quot;Hey there!&quot;;    function privateFunction() {        console.log( &quot;Name:&quot; + privateVar );    }    function publicSetName( strName ) {        privateVar = strName;    }    function publicGetName() {        privateFunction();    }    // Reveal public pointers to     // private functions and properties    return {        setName: publicSetName,        greeting: publicVar,        getName: publicGetName    };}();myRevealingModule.setName( &quot;Paul Kinlan&quot; );</code></pre><ul><li>优势: 使脚本语法更加一致 公共访问更加清晰 增强了可读性</li><li>缺陷: <ol><li>这个模式的一个缺点是如果私有函数需要使用公有函数，那么这个公有函数在需要打补丁的时候就不能被重载。因为私有函数仍然使用的是私有的实现，并且这个模式不能用于公有成员，只用于函数。</li><li>公有成员使用私有成员也遵循上面不能打补丁的规则。因为上面的原因，使用暴露式模块模式创建的模块相对于原始的模块模式更容易出问题，因此在使用的时候需要小心。</li></ol></li></ul><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><ul><li>特点：唯一、全局访问</li></ul><ol><li>简单版单例</li></ol><pre><code>let singleton = function(name) {    this.name = name;    this.instance = null;}singleton.prototype.getName = function() {    console.log(this.name);}singleton.getInstance = function(name){    if(this.instace){        return this.instance;     }    return this.instance = new Singleton(name);}let sunner = Singleton.getInstance(&quot;sunner&quot;);   //winnerconsole.log(sunner.getName())</code></pre><p>不足：创建对象和实例操作耦合在一起 不符合 单一职责</p><ol start="2"><li><p>改良版，使用闭包</p><pre><code>let createSingleton = (function() { let instance = null; return function(name) {     this.name = name;     if(instance) {         return instance;     }     return instance = this; }})();createSingleton.prototype.getName = function(){ console.log(this.name);}let winner = new createSingleton(&quot;winner&quot;);  //winnerconsole.log(winner.getName());</code></pre></li><li><p>代理版单例</p></li></ol><pre><code>let proxyCreateSingleton = function() {    let instance = null;    return function(name) {        if(instance) { return instance }        return instance = new singleProxy(name);    }}function singleProxy(name) {    this.name = name;}singleProxy.prototype.getName = function() {    console.log(this.name);}let winner_Proxy = new proxyCreateSingleton(&quot;winner&quot;);console.log(winner_Proxy.getName());</code></pre><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>被观察者 - 观察者</p><ol><li>一个或者更多的观察者对一个被观察者的状态感兴趣，将自身的这种兴趣通过附着自身的方式注册在被观察者身上；</li><li>当被观察者发生变化，而这种便可也是观察者所关心的，就会产生一个通知，这个通知将会被送出去，最后将会调用每个观察者的更新方法；</li><li>当观察者不在对被观察者的状态感兴趣的时候，它们只需要简单的将自身剥离即可</li></ol><pre><code>/**    Subject      (notify)-------&gt;      Observer1        |        |------(notify)---------&gt;       Observer2        |        |------(notify)---------&gt;       Observer3 */</code></pre><ol><li>实现ObserList</li></ol><pre><code>function ObserverList(){    this.observerList = [];}ObserverList.prototype.add = function( obj ){    return this.observerList.push( obj );};ObserverList.prototype.count = function(){    return this.observerList.length;};ObserverList.prototype.get = function( index ){    if( index &gt; -1 &amp;&amp; index &lt; this.observerList.length ){        return this.observerList[ index ];    }};ObserverList.prototype.indexOf = function( obj, startIndex ){    var i = startIndex;    while( i &lt; this.observerList.length ){        if( this.observerList[i] === obj ){            return i;        }        i++;    }    return -1;};ObserverList.prototype.removeAt = function( index ){    this.observerList.splice( index, 1 );}</code></pre><ol start="2"><li>实现Subject</li></ol><pre><code>function Subject(){    this.observers = new ObserverList();}Subject.prototype.addObserver = function( observer ){    this.observers.add( observer );};Subject.prototype.removeObserver = function( observer ){    this.observers.removeAt( this.observers.indexOf( observer, 0 ) );};Subject.prototype.notify = function( context ){    var observerCount = this.observers.count();    for(var i=0; i &lt; observerCount; i++){        this.observers.get(i).update( context );    }}</code></pre><ol start="3"><li>实现Observer </li></ol><pre><code>function Observer () {    this.update = function () {        // ...    }}</code></pre><ol start="4"><li>test</li></ol><pre><code>var subject = new Subject();var observer1 = new Observer();observer1.update = function () {    console.log(&#39;observer1&#39;);}var observer2 = new Observer();observer2.update = function () {    console.log(&#39;observer2&#39;);}subject.addObserver(observer1);subject.addObserver(observer2);subject.notify();    // 输出 observer1 observer2</code></pre><h4 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h4><ol><li><p>观察者对象是个消息容器 拥有订阅 发布订阅 取消订阅的消息方法</p><pre><code>var Observe = (function() { var topics = {}; // 回调函数存放的数组 return {     subscribe: function(type, fn) {         // 如果此消息不存在则创建         if (!topics[type]) {             topics[type] = [];         }         // 将动作推入到该消息对应的动作执行序列中         topics[type].push(fn);     },     publish: function(type, args) {         // 如果该消息没有被注册，则返回         if (!topics[type]) {             return;         }         var self = this;         setTimeout(function () {             var subscribers = topics[type], len = subscribers ? subscribers.length: 0;             for (var i = 0; i &lt; len; i++) {                 // 依次执行注册的消息对应的动作序列                 subscribers[i].call(self, args);             }         }, 0);     },     unsubscribe: function() {         var subscribers = topics[type];         // 判断是否存在             if (subscribers instanceof Array) {             var i = subscribers.length - 1;             for (;i &gt;= 0; i-- ) {                 // 如果存在该动作则在消息动作序列中移除响应动作                     subscribers[i] === fn &amp;&amp; subscribers.splice(i, 1);             }         }     } }})();</code></pre></li><li><p>test</p></li></ol><pre><code>var listener1 = function (data) {    console.log(&#39;listener1:&#39; + data);}var listener2 = function (data) {    console.log(&#39;listener2:&#39; + data);}Observer.subscribe(&#39;example1&#39;, listener1);Observer.subscribe(&#39;example1&#39;, listener2);//发布通知Observer.publish(&#39;example1&#39;, &#39;hello world!&#39;);Observer.publish(&#39;example1&#39;, [&#39;test&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]);// 取消订阅Observer.unsubscribe(&#39;example1&#39;, listener2);Observer.publish(&#39;example1&#39;, &#39;123&#39;);</code></pre><ul><li><p>观察者与发布订阅的不同</p><ol><li>Publish/Subscribe(发布/订阅)模式使用一个主题/事件通道，这个通道介于订阅者和发布者之间；</li><li>该设计模式允许代码定义应用程序的特定事件，这些事件可以传递自定义参数，自定义参数包含订阅者需要的信息，采用事件通道可以避免发布者和订阅者之间产生依赖关系；</li><li>Observer(观察者)模式允许观察者实例对象(订阅者)执行适当的事件处理程序来注册和接收目标实例对象(发布者)发出的通知（即在观察者实例对象上注册update方法）。<br>使订阅者和发布者之间产生了依赖关系，且没有事件通道。</li></ol></li><li><p>优点: 解耦 @$%@#%</p></li><li>缺陷: 缺陷 具有不稳定性 发布订阅都是无状态的</li></ul><h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><ol><li>如果系统组件之间存在大量的直接关系，就可能是时候，使用一个中心的控制点，来让不同的组件通过它来通信；</li><li>中介者通过将组件之间显式的直接的引用替换成通过中心点来交互的方式，来做到松耦合。这样可以帮助我们解耦，和改善组件的重用性；</li><li>中介者模式主要用于一个系统中存在大量的对象，而且这些大量的对象需要互相通信，因为两个对象需要通信，一个对象必须要持有另一个对象，这样就会导致，系统里，每个对象都互相引用，会引起混乱，中介者把所有的对象都统一管理起来，其他的对象通过中介者去和别的对象通信。</li></ol><pre><code>function A(mediator) {    this.mediator = mediator;}A.prototype = {    send: function(msg,receiver) {        this.mediator.send(msg,&#39;A&#39;,receiver);    },    receiveMsg: function(msg,sender) {        console.log(sender+&quot; say:&quot;+msg)    }}function B(mediator) {    this.mediator = mediator;}B.prototype = {    send: function(msg,receiver) {        this.mediator.send(msg,&#39;B&#39;,receiver);    },    receiveMsg: function(msg,sender) {        console.log(sender+&quot; say:&quot;+msg)    }}function Mediator() {    this.A = new A(this);    this.B = new B(this);}Mediator.prototype = {    send: function(msg,sender,receiver) {        try {            this[receiver].receiveMsg(msg,sender);        }        catch(err) {            console.log(&#39;receiver &#39;+receiver+&#39; is not exsit&#39;);            this[sender].receiveMsg(&#39;receiver &#39;+ receiver +&#39; is not exsit&#39;,&#39;mediator&#39;);        }    }}var _mediator = new Mediator();var _a = new A(_mediator);var _b = new B(_mediator);_a.send(&#39;hello i am A&#39;,&#39;B&#39;);_b.send(&#39;hello i am B&#39;,&#39;A&#39;);</code></pre><ul><li>中介者模式</li></ul><pre><code>var mediator = (function() {    var _channels = [],        _subUid = -1    function subscribe(channel, handler) {      if(!_channels[channel]) _channels[channel] = []      var token = (++_subUid).toString()      _channels[channel].push({        token: token,        context: this,        handler: handler      })      return token    }    function publish(channel, data) {      if(!_channels[channel]) return false      var subscribers = _channels[channel]      var len = subscribers.length      while(len--) {        subscribers[len].handler.call(subscribers[len].context, data, channel, subscribers[len].token)      }      return this    }    function unsubscribe(token) {      for(var channel in _channels) {        var len = _channels[channel].length        for(var index=0; index&lt;len; index++) {          if(_channels[channel][index].token === token) {            _channels[channel].splice(index, 1)            return token          }        }      }    }    // Module模式引出    return {      subscribe: subscribe,      publish: publish,      unsubscribe: unsubscribe,      // 绑定到其他对象使用该设计模式      installTo: function(obj) {        obj.subscribe = subscribe        obj.publish = publish         obj.unsubscribe = unsubscribe      }    }})()mediator.subscribe(&#39;message&#39;, function(data, channel, token) {    // true    console.log(this === mediator)     console.log(data)    console.log(channel)    console.log(token)})mediator.publish(&#39;message&#39;, &#39;hello world&#39;)</code></pre><ol><li>Mediator(中介者)模式：单一目标通常有很多观察者，有时一个目标的观察者是另一个观察者的目标。通信可以实现双向</li><li>Observer(观察者)模式：不存在封装约束的单一对象，目标对象和观察者对象必须合作才能维持约束。 观察者对象向订阅它们的对象发布其感兴趣的事件。通信只能是单向的</li></ol><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><ol><li>原型模式引用为通过克隆的方式基于一个现有对象的模板创建对象的模式</li><li>原型模式可以让多个构造函数对应的实例对象共享同一个原型对象的属性和方法</li></ol><pre><code>var myCar = {    name: &#39;a&#39;,    drive: function() {},    stop: function() {}}var carInstance = Object.create(myCar);console.log(carInstance);</code></pre><p><em>进阶</em></p><pre><code>var createProto = (function(){    function Fconstructor() {}    return function(_proto) {        Fconstructor.prototype = _proto;        return new Fconstructor();    }})()</code></pre><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><ol><li>命令模式将命令执行者和命令发起者解耦，提供更大的整体灵活性。</li><li>用类来做比喻就是，抽象类（类似于命令发起者）定义一个接口，但不为它的成员函数提供实现，作为一个基类派生出其他类，派生类（类似于命令执行者）首先具体接口。</li></ol><pre><code>var clientCustom = {    name: &#39;a&#39;}var cooker = {    execute: function(food) {        console.log(`do! ${food}`)    }}function commandFunc(receiver, food) {    this.receiver = receiver;    this.food = food;}commandFunc.prototype.execute = function(cooker) {    cooker.execute(this.food);}var orderCommand_1 = new commandFunc(clientCustom, &#39;菜1&#39;);orderCommand_1.execute(cooker);</code></pre><h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><ol><li>这一模式提供了面向一种更大型的代码体提供了一个的更高级别的舒适的接口，隐藏了其真正的潜在复杂性</li><li>把这一模式想象成要是呈现给开发者简化的API，一些总是会提升使用性能的东西</li></ol><pre><code>var module = (function() {    var _private = {        i:5,        get : function() {            console.log( &quot;current value:&quot; + this.i);        },        set : function( val ) {            this.i = val;        },        run : function() {            console.log( &quot;running&quot; );        },        jump: function(){            console.log( &quot;jumping&quot; );        }    };    return {        facade : function( args ) {            _private.set(args.val);            _private.get();            if ( args.run ) {                _private.run();            }        }    };}());module.facade( {run: true, val:10} );</code></pre><pre><code>// 类似var addMyEvent = function( el,ev,fn ){    if( el.addEventListener ){        el.addEventListener( ev,fn, false );    }else if(el.attachEvent){        el.attachEvent( &quot;on&quot; + ev, fn );    } else{        el[&quot;on&quot; + ev] = fn;    } };</code></pre><p><em>更多思路: 类似于检测浏览器版本、类型, 调用一个方法 方法内部再执行各种判断…</em></p><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><ol><li>工厂模式是另外一种关注对象创建概念的创建模式。它的领域中同其它模式的不同之处在于它并没有明确要求我们使用一个构造器；</li><li>取而代之，一个工厂能提供一个创建对象的公共接口，我们可以在其中指定我们希望被创建的工厂对象的类型；</li><li>试想一下，在我们被要求创建一种类型的UI组件时，我们就有一个UI工厂。并不是通过直接使用new操作符或者通过另外一个构造器来创建这个组件，我们取而代之的向一个工厂对象索要一个新的组件；</li><li>我们告知工厂我们需要什么类型的组件（例如：“按钮”，“面板”），而它会将其初始化，然后返回供我们使用。</li></ol><pre><code>function Car(options) {    this.doors = options.doors || 4;    this.state = options.state || &quot;brand new&quot;;    this.color = options.color || &quot;silver&quot;;}function Trunk(options) {    this.state = options.state || &quot;used&quot;;    this.wheelSize = options.wheelSize || &quot;large&quot;;    this.color = options.color || &quot;blue&quot;;}function VehicleFactory() {    this.vehicleClass = Car;}VehicleFactory.prototype.createVehicle = function(options) {    if(options.type === &#39;car&#39;) {        this.vehicleClass.vehicleClass = Car;    } else {        this.vehicleClass.vehicleClass = Trunk;    }    return new this.vehicleClass(options);}var carFctory = new VehicleFactory();var car = carFactory.createVehicle( {    type: &quot;car&quot;,    color: &quot;yellow&quot;,    doors: 6 } );// Outputs: trueconsole.log( car instanceof Car );// Outputs: Car object of color &quot;yellow&quot;, doors: 6 in a &quot;brand new&quot; stateconsole.log( car );</code></pre><p><em>什么时候使用？</em></p><ol><li>当我们的对象或者组件设置涉及到高程度级别的复杂度时；</li><li>当我们需要根据我们所在的环境方便的生成不同对象的实体时；</li><li>当我们在许多共享同一个属性的许多小型对象或组件上工作时；</li><li>当带有其它仅仅需要满足一种API约定(又名鸭式类型)的对象的组合对象工作时.这对于解耦来说是有用的。</li></ol><h4 id="Mixin模式"><a href="#Mixin模式" class="headerlink" title="Mixin模式"></a>Mixin模式</h4><ol><li>子类划分是一个参考了为一个新对象继承来自一个基类或者超类对象的属性的术语.在传统的面向对象编程中,类B能够从另外一个类A处扩展。</li><li>这里我们将A看做是超类,而将B看做是A的子类.如此,所有B的实体都从A处继承了其A的方法.然而B仍然能够定义它自己的方法,包括那些重载的原本在A中的定义的方法。</li><li>B是否应该调用已经被重载的A中的方法,我们将这个引述为方法链.B是否应该调用A(超类)的构造器,我们将这称为构造器链。</li></ol><pre><code>var Person =  function( firstName , lastName ){    this.firstName = firstName;    this.lastName =  lastName;    this.gender = &quot;male&quot;;};var clark = new Person( &quot;Clark&quot; , &quot;Kent&quot; );var Superhero = function( firstName, lastName , powers ){    Person.call( this, firstName, lastName );    this.powers = powers;};SuperHero.prototype = Object.create( Person.prototype );var superman = new Superhero( &quot;Clark&quot; ,&quot;Kent&quot; , [&quot;flight&quot;,&quot;heat-vision&quot;] );console.log( superman );</code></pre><p><em>进阶</em></p><pre><code>// Define a simple Car constructorvar Car = function ( settings ) {    this.model = settings.model || &quot;no model provided&quot;;    this.color = settings.color || &quot;no colour provided&quot;;};var Mixin = function () {};Mixin.prototype = {    driveForward: function () {        console.log( &quot;drive forward&quot; );    },    driveBackward: function () {        console.log( &quot;drive backward&quot; );    },    driveSideways: function () {        console.log( &quot;drive sideways&quot; );    }};function augment( receivingClass, givingClass ) {    // only provide certain methods    if ( arguments[2] ) {        for ( var i = 2, len = arguments.length; i &lt; len; i++ ) {            receivingClass.prototype[arguments[i]] = givingClass.prototype[arguments[i]];        }    }    // provide all methods    else {        for ( var methodName in givingClass.prototype ) {            if ( !Object.hasOwnProperty(receivingClass.prototype, methodName) ) {                receivingClass.prototype[methodName] = givingClass.prototype[methodName];            }        }    }}// extendaugment( Car, Mixin, &quot;driveForward&quot;, &quot;driveBackward&quot; );var myCar = new Car({    model: &quot;Ford Escort&quot;,    color: &quot;blue&quot;});myCar.driveForward();myCar.driveBackward();// extendaugment( Car, Mixin );var mySportsCar = new Car({    model: &quot;Porsche&quot;,    color: &quot;red&quot;});mySportsCar.driveSideways();</code></pre><h4 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h4><ol><li>装饰器模式并不去深入依赖于对象是如何创建的，而是专注于扩展它们的功能这一问题上。不同于只依赖于原型继承，我们在一个简单的基础对象上面逐步添加能够提供附加功能的装饰对象。</li><li>它的想法是，不同于子类划分，我们向一个基础对象添加（装饰）属性或者方法，因此它会是更加轻巧的。</li></ol><pre><code>function vehicle(type) {    this.vehicleType = vehicleType || &quot;car&quot;;    this.model = &quot;default&quot;;    this.license = &quot;00000-000&quot;;}var veInstance = new vehicle(&#39;car&#39;);var trunk = new vehicle(&#39;trunk&#39;);// addtrunk.setModel = function( modelName ){    this.model = modelName;};truck.setColor = function( color ){    this.color = color;};</code></pre><p><em>进阶</em></p><pre><code>// The constructor to decoratefunction MacBook() {    this.cost = function () { return 997; };    this.screenSize = function () { return 11.6; };}// Decorator 1function Memory( macbook ) {    var v = macbook.cost();    macbook.cost = function() {      return v + 75;    };}// Decorator 2function Engraving( macbook ){    var v = macbook.cost();    macbook.cost = function(){        return  v + 200;    };}// Decorator 3function Insurance( macbook ){    var v = macbook.cost();    macbook.cost = function(){        return  v + 250;    };} var mb = new MacBook();Memory( mb );Engraving( mb );Insurance( mb );// Outputs: 1522console.log( mb.cost() );// Outputs: 11.6console.log( mb.screenSize() );</code></pre><ol><li>我们的装饰器重载了超类对象MacBook()的 object.cost()函数，使其返回的Macbook的当前价格加上了被定制后升级的价格；</li><li>这被看做是对原来的Macbook对象构造器方法的装饰，它并没有将其重写（例如，screenSize())，我们所定义的Macbook的其它属性也保持不变，完好无缺。</li></ol><pre><code>var decorator = function(dom, fn) {    if(typeof dom.onclick === &#39;function&#39; ){        var origin = dom.onclick;        dom.onclick = function(event) {            origin.call(dom, event); // 原事件            fn.call(dom, event); // 装饰        }    } else {        dom.onclick = fn;    }}</code></pre><h4 id="创建者模式"><a href="#创建者模式" class="headerlink" title="创建者模式"></a>创建者模式</h4><ol><li>工厂模式可有效的创建可复用的实例对象，关心的是最终创建的对象是什么，不关心创建的过程，因此通过工厂模式得到的都是对象实例或者类簇。</li><li>建造者模式相对比工厂模式复杂一些，关心的是创建对象的过程</li></ol><pre><code>function Person(name, age) {    this.name = name;    this.age = age;}Person.prototype.getName = function() {    return this.name}Person.prototype.getAge = function() {    return this.age}function Job(job) {    switch(job) {      case &#39;teacher&#39;:        this.job = &#39;教师&#39;        this.jobDesc = &#39;数学教师&#39;        break      case &#39;doctor&#39;:        this.job = &#39;医生&#39;        this.jobDesc = &#39;骨科医生&#39;        break      case &#39;coder&#39;:        this.job = &#39;程序员&#39;        this.jobDesc = &#39;Web前端程序员&#39;        break      default:        this.job = job        this.jobDesc = &#39;不清楚您的职位的相关描述&#39;        break    }}Job.prototype.changeJobDesc = function(desc) {    this.jobDesc = desc}Job.prototype.changeJob = function(job) {    return this.job = job}function Hobby(hobby) {    this.hobby = []    this.hobby.push(hobby)}Hobby.prototype.addHobby = function(hobby) {    this.hobby.concat(hobby)}Hobby.prototype.getHobby = function() {    return this.hobby.split(&#39;,&#39;)}function Skill(skill) {    this.skill = []    this.skill.push(skill)}function Resume(name, age) {    this.person = new Person(name, age)    this.person.job = new Job()    this.person.hobby = new Hobby()    this.person.skill = new Skill()}let resume = new Resume(&#39;ziyi2&#39;, 28)console.log(resume)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS模块化演进</title>
      <link href="/2020/09/28/2020/JS%E6%A8%A1%E5%9D%97%E5%8C%96%E6%BC%94%E8%BF%9B/"/>
      <url>/2020/09/28/2020/JS%E6%A8%A1%E5%9D%97%E5%8C%96%E6%BC%94%E8%BF%9B/</url>
      
        <content type="html"><![CDATA[<p>模块化的理解：</p><ul><li>利于维护，通过引入的方式直观了解依赖关系</li><li>多人开发时，只负责自己的独立模块</li></ul><h4 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h4><pre><code>;(function(root) {    var api = &#39;url&#39;;    var config = {        obj: &#39;x&#39;    };    root.config = config;    root.api = api;})(window)// 控制全局变量数量</code></pre><a id="more"></a><h4 id="commonJS"><a href="#commonJS" class="headerlink" title="commonJS"></a>commonJS</h4><ul><li>模块的标识应遵循的规则</li><li>定义全局函数require，通过传入模块标识来引入其他模块，执行的结果即为别的模块暴漏出来的API</li><li>如果被require函数引入的模块中也包含依赖，那么依次加载这些依赖</li><li>如果引入模块失败，那么require函数应该报一个异常</li><li>模块通过变量exports来向往暴漏API，exports只能是一个对象，暴漏的API须作为此对象的属性</li></ul><p>起初用于服务端, 后来考虑到浏览器使用, require需要支持浏览器发送请求读取模块</p><pre><code>// math.jsexports.add = function(a) {    return a + 1;}</code></pre><pre><code>// increment.jsvar add = require(&#39;math&#39;).add;exports.inc = function(e) {    return add(e) + 1;}</code></pre><pre><code>// pro.jsvar incr = require(&#39;increment&#39;).inc;var q = 1;incr(q);</code></pre><p>后来有所衍生…</p><p>Async 2.x派</p><ol><li>既然浏览器必须异步加载代码，那么模块在定义的时候就必须指明所依赖的模块，然后把本模块的代码写在回调函数里。</li><li>模块的加载也是通过下载-回调这样的过程来进行。</li><li>这就成为了AMD</li></ol><h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><p>AMD / RequireJS异军突起</p><ol><li>用全局函数define来定义模块，用法为：define(id?, dependencies?, factory)</li><li>id为模块标识，遵从CommonJS Module Identifiers规范</li><li>dependencies为依赖的模块数组，在factory中需传入形参与之一一对应</li><li>如果dependencies的值中有”require”、”exports”或”module”，则与commonjs中的实现保持一致</li><li>如果dependencies省略不写，则默认为[“require”, “exports”, “module”]，factory中也会默认传入require,exports,module</li><li>如果factory为函数，模块对外暴漏API的方法有三种：return任意类型的数据、exports.xxx=xxx、module.exports=xxx</li></ol><pre><code>// a.jsdefine(function() {    console.log(&#39;a&#39;);    return {        hello: function() {            console.log(&#39;Hello a.js&#39;);        }    }});</code></pre><pre><code>// b.jsdefine(function() {    console.log(&#39;b&#39;);    return {        hello: function() {            console.log(&#39;Hello b.js&#39;);        }    }});</code></pre><pre><code>// main.jsrequire([&#39;a&#39;, &#39;b&#39;], function(a, b) {    console.log(&#39;main&#39;);    a.hello();    $(&#39;#b&#39;).click(function(){        b.hello();   });});</code></pre><p><em>运行结果是?</em></p><p>a.js执行 - b.js执行 - main.js执行 - hello, a.js - (点击按钮后)hello, b.js</p><p>但是如果细细来看，b.js被预先加载并且预先执行了，（第二行输出），b.hello这个方法是在点击了按钮之后才会执行，如果用户压根就没点，那么b.js中的代码应不应该执行呢 ?</p><p>这就造成了一些问题</p><ol><li>如果依赖模块过多, 会把所以模块都引入并执行了。</li><li>另外一点: 引入过长, require([‘a’, ‘b’, ‘c’, …], function(a, b, c, …) {})</li></ol><ul><li>懒加载， 会引起操作时引入的卡顿</li></ul><pre><code>define(function(require) {    require([&#39;a&#39;], function(a) {        a.hello();    })    $(&#39;#b&#39;).click(function () {        require([&#39;b&#39;], function(b) {b.hello();});    })})</code></pre><ul><li>后来AMD做了兼容<pre><code>define(function(require) {  var a = require(&#39;a&#39;);  var test = function () {      a.hello()  }  return {      a: test  }})</code></pre></li></ul><p>由于AMD有种种问题, 而别的规范也因此衍生, CMD / seajs </p><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><pre><code>define(function(require, exports, module) {    // 通过 require 引入依赖    var $ = require(&#39;jquery&#39;);    var spining = require(&#39;./spining&#39;);    exports.doSomething = function() {}; // 通过exports 对外提供Api    module.exports = spining; // 通过module.exports 提供接口})</code></pre><h4 id="ES6模块"><a href="#ES6模块" class="headerlink" title="ES6模块"></a>ES6模块</h4><p>2015年6月，ECMAScript2015也就是ES6发布了，JavaScript终于在语言标准的层面上，实现了模块功能。<br>使得在编译时就能确定模块的依赖关系，以及其输入和输出的变量，不像 CommonJS、AMD之类的需要在运行时才能确定（例如FIS这样的工具只能预处理依赖关系，本质上还是运行时解析），成为浏览器和服务器通用的模块解决方案</p><pre><code>// a.jsconst helloInLang = {    en: &#39;Hello world!&#39;,    es: &#39;¡Hola mundo!&#39;,    ru: &#39;Привет мир!&#39;};export const getHello = (lang) =&gt; (    helloInLang[lang]);export const sayHello = (lang) =&gt; {    console.log(getHello(lang));};</code></pre><pre><code>// hello.jsimport { sayHello } from &#39;./a&#39;;sayHello(&#39;ru&#39;);</code></pre><h4 id="Q"><a href="#Q" class="headerlink" title="Q?"></a>Q?</h4><p>Q1：<br>我们在看 node 代码时，应该会发现，关于接口导出，有的地方使用module.exports，而有的地方使用exports，这两个有什么区别呢?</p><pre><code>var module = {    exports: {}}var exports = module.exports;console.log(module.exports === exports); // truevar s = &#39;i am ronffy&#39;exports = s; // module.exports 不受影响console.log(module.exports === exports); // false</code></pre><p>模块初始化时，exports和module.exports指向同一块内存，exports被重新赋值后，就切断了跟原内存地址的关系。<br>所以，exports要这样使用：</p><pre><code>exports.s = &#39;i am ronffy&#39;;</code></pre><pre><code>var a = require(&#39;./a.js&#39;);console.log(a.s); // i am ronffy</code></pre><p>Q2：</p><ul><li>CommonJS与AMD, CommonJS 和 AMD 都是   <strong><em> 运行时加载 </em></strong></li><li>CommonJS 是服务器端模块规范，AMD 是浏览器端模块规范。</li><li>CommonJS 加载模块是同步的，即执行var a = require(‘./a.js’);时，在 a.js 文件加载完成后，才执行后面的代码。AMD 加载模块是异步的，所有依赖加载完成后以回调函数的形式执行代码。</li><li>[如下代码]fs和chalk都是模块，不同的是，fs是 node 内置模块，chalk是一个 npm 包。这两种情况在 CommonJS 中才有，AMD 不支持</li></ul><p>Q3：<br>在ES6中，import命令可以具体指定加载模块中用export命令暴露的接口（不指定具体的接口，默认加载export default），没有指定的是不会加载的。<br>因此会在编译时就完成模块的加载，这种加载方式称为编译时加载或者静态加载。</p><p>Q4： CommonJS和ES6 Module的区别？</p><ul><li>CommonJS模块输出的是一个值的拷贝，ES6 Module输出的是值的引用；</li><li>CommonJS模块是运行时加载，ES6模块是编译时输出接口；</li><li>CommonJS是单个值导出，ES6 模块可以导出多个；</li><li>CommonJS是动态语法可以写在判断里，ES6 Module静态语法只能写在顶层；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收机制</title>
      <link href="/2020/09/23/2020/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/09/23/2020/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>👉：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management" target="_blank" rel="noopener">MDN-内存管理</a></p><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。</p><a id="more"></a><p>在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）</p><p>限制：无法处理循环引用的事例</p><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。</p><p>这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。</p><p>这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS-CSRF-Cookie</title>
      <link href="/2020/08/11/2020/XSS-CSRF/"/>
      <url>/2020/08/11/2020/XSS-CSRF/</url>
      
        <content type="html"><![CDATA[<h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><p>Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。</p><ol><li>存储型</li><li>反射型</li><li>DOM型三种</li></ol><table><thead><tr><th>类型</th><th>存储区</th><th>插入点</th></tr></thead><tbody><tr><td>存储型</td><td>后端数据库</td><td>HTML</td></tr><tr><td>反射型</td><td>URL</td><td>HTML</td></tr><tr><td>DOM型</td><td>后端数据库、前端、URL</td><td>JS</td></tr></tbody></table><a id="more"></a><ol><li><p>存储性XSS攻击步骤</p><ul><li>攻击者将恶意代码提交到目标网站数据库中</li><li>用户打开网站时，将恶意代码从数据库中取出，拼接在HTML中返回</li><li>用户收到响应后解析，执行恶意代码</li><li>恶意代码窃取用户数据等..</li><li>常见于带有用户保存数据得网站功能，如：论坛，评论等</li></ul></li><li><p>反射型XSS的攻击步骤</p><ul><li>攻击者构造特殊的URL，包含恶意代码</li><li>用户打开恶意代码URL，网站将恶意代码从URL取出，拼接在HTML中返回</li><li>用户收到响应后解析，恶意代码也执行</li><li>恶意代码窃取用户数据，并冒充用户行为等</li><li><em>与存储型XSS的区别</em>：<ul><li>存储型XSS存在数据库中，反射性XSS存在URL中</li><li>反射型XSS漏洞常见于URL传递参数的功能，如跳转等</li><li>需要用户主动打开，例如通过邮件等</li></ul></li></ul></li><li><p>DOM型XSS</p><ul><li>攻击者构造特殊URL，包含恶意代码</li><li>用户打开恶意代码URL</li><li>用户浏览器响应与执行</li><li>恶意代码窃取用户数据</li><li><em>DOM型XSS与前两种的区别：</em> <ul><li>DOM型XSS，取出与执行都在浏览器端完成，属于JS自身的安全漏洞</li><li>其他两种更偏向于服务端</li></ul></li></ul></li></ol><p>常用防范方法</p><ol><li>httpOnly</li><li>输入过滤</li><li>转义HTML，进行输入输出的编码转义，尽量减少<code>v-html、innerHTML等方式渲染HTML</code></li></ol><p>DOM型XSS：</p><ol><li>利用innerHTML修改页面；</li><li>利用document.onkeypress偷取记录键盘事件。</li></ol><p><em>如何抵御DOMXSS?</em></p><ol><li>避免客户端文档重写、重定向或其他敏感操作，同时避免使用客户端数据，这些操作尽量在服务器端使用动态页面来实现；</li><li>分析和强化客户端JS代码，特别是受到用户影响的DOM对象，注意能直接修改DOM和创建HTML文件的相关函数或方法，并在输出变量到页面时先进行编码转义，如输出到HTML则进行HTML编码、输出到则进行JS编码。</li></ol><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><p>跨站请求伪造（英语：Cross-site request forgery），攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的</p><p>CSRF特点：</p><ol><li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。</li><li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。   </li><li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。</li><li>跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。</li></ol><p>一个典型的CSRF攻击：</p><ol><li>受害者登录了<code>a.com</code>，并保留了登录凭证；</li><li>攻击者引诱受害者访问<code>b.com</code>；</li><li><code>b.com</code>向<code>a.com</code>发送了一个请求，<code>a.com/act=xx</code>。浏览器默认带上<code>a.com</code>的Cookie；</li><li><code>a.com</code>接收到请求后，对请求验证，确认是受害者的凭证，执行请求；</li><li><code>a.com</code>以受害者的名义执行；</li><li>攻击完成</li></ol><p><em>如何抵御CSRF?</em></p><ul><li>阻止不明外域的访问<ol><li>同源检测</li><li>Samesite Cookie</li></ol></li></ul><p><code>组织不明外域</code></p><ol><li>根据origin或referer头进行判断</li><li>如果都不存在，建议阻止</li></ol><ul><li>提交时要求附加本域才能获取的信息<ol><li>CSRF Token</li><li>双重Cookie验证</li></ol></li></ul><p><code>CSRFToken</code><br>我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。<br>三个步骤：</p><ol><li>将CSRF Token输出到页面中，最好服务端输出，置于session中；</li><li>页面请求时携带；</li><li>服务端输出。</li></ol><p>Token是一个比较有效的CSRF防护方法，只要页面没有XSS漏洞泄露Token，那么接口的CSRF攻击就无法成功。但是此方法的实现比较复杂，需要给每一个页面都写入Token（前端无法使用纯静态页面）。<br>每一个Form及Ajax请求都携带这个Token，后端对每一个接口都进行校验，并保证页面Token及请求Token一致。这就使得这个防护策略不能在通用的拦截上统一拦截处理，而需要每一个页面和接口都添加对应的输出和校验。这种方法工作量巨大，且有可能遗漏</p><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p><a href="https://github.com/mqyqingfeng/Blog/issues/157" target="_blank" rel="noopener">浏览器系列之 Cookie</a></p><h5 id="Cookie的属性："><a href="#Cookie的属性：" class="headerlink" title="Cookie的属性："></a>Cookie的属性：</h5><ul><li>Name/Value</li><li>Expires: 设置Cookie的过期时间</li><li>Max-Age：优先级高于<code>Expires</code><ol><li>正数，持久化时间</li><li>负数，表示为一个会话Cookie</li><li>0，立即失效</li></ol></li><li>Domain：指定的主机名，不能跨域设置，即把<code>A</code>的设置到<code>B</code>下</li><li>Path：指定一个<code>URL</code>，<code>Domain</code>和<code>Path</code>共同定义了Cookie的作用域，即Cookie应该发送给哪些<code>URL</code></li><li>Secure：标记<code>Secure</code>和Cookie只应该通过<code>HTTPS</code>发送，使用<code>HTTPS</code>可以保护Cookie在浏览器和服务器间传输不被篡改</li><li>HTTPOnly：设置<code>HTTPOnly</code>可以防止客户端通过脚本访问Cookie，有助于避免<code>XSS</code></li></ul><h5 id="Cookie的作用："><a href="#Cookie的作用：" class="headerlink" title="Cookie的作用："></a>Cookie的作用：</h5><ul><li>会话状态管理（购物车，登录状态…）</li><li>个性化设置（主题…）</li><li>浏览器行为跟踪…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三次握手四次挥手</title>
      <link href="/2020/07/09/2020/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2020/07/09/2020/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="/2020/07/09/2020/三次握手四次挥手/NO1.png" alt="NO1" title="NO1"></p><a id="more"></a><ol><li>TCP服务器进程先创建传输控制块TCB，时刻准备接收客户进程的连接请求，此时服务器进入LISTEN（监听状态）；</li><li>TCP客户进程创建传输控制块TCB，然后向服务器发出连接请求报文，此时报文首部同部位SYN=1，此时TCP客户端进程进入SYN-SENT状态，TCP规定，SYN=1报文不能携带数据；</li><li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文，确认报文中ACK=1,SYN=1，此时TCP服务器进程进入SYNC-RCVD状态，这个报文也不能携带数据；</li><li>TCP客户进程收到确认后，要给服务器发出确认，确认报文中ACK=1，此时TCP连接建立，客户端进入ESTABLISHED状态，TCP规定，ACK报文可以携带数据；</li><li>TCP服务器收到确认后，也进入ESTABLISHED状态，可以开始通信。</li></ol><p><em>类似是这样的：</em></p><ul><li>第一次握手：客户端发包，服务端接收<ol><li>服务端收到了，服务端就可以确认客户端发送能力、服务端接收能力是正常的；</li></ol></li><li>第二次握手：服务端发包，客户端接收<ol><li>这样客户端得出结论，服务端的接收、发送能力正常，客户端的接收、发送能力正常，不过此时服务器不能确认客户端接收是否正常；</li></ol></li><li>第三次握手：客户端发包，服务端接收<ol><li>这样服务端就可以得出结论，客户端接收，发送能力正常，服务端自己的发送，接收能力正常。</li></ol></li></ul><h5 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h5><p>握手少了，无法确认双方连接；<br>握手多了没必要；<br>如果只有两次握手，那么服务端向客户端发送 SYN/ACK 报文后，就会认为连接建立。但是如果客户端没有收到报文，那么客户端是没有建立连接的。这就导致服务端会浪费资源。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img src="/2020/07/09/2020/三次握手四次挥手/NO2.png" alt="NO2" title="NO2"></p><ol><li>客户端向服务端发送连接释放报文，FIN=1,ACK=1，主动关闭连接，等待服务端确认；</li><li>服务端收到连接释放报文后，立即发出确认报文，ACK=1，此时TCP处于半关闭状态，即客户端到服务端的连接已经释放了，但是服务端到客户端的连接还未十分，这表示客户端已经没有数据发送了，但是服务端可能还有数据给客户端发送；</li><li>服务端向客户端发送释放报文，FIN=1,ACK=1，主动关闭连接，同时等待确认；</li><li>客户端收到服务连接释放报文后，立即发出确认报文，ACK=1，服务端收到客户端的确认后，就会立即进入close状态。</li></ol><p><em>什么情况呢？形象比喻：</em></p><ul><li>A和B打电话，通话结束后</li><li>A：我没啥要说的了（开始发呆）；</li><li>B：我知道了，我还有要说的；</li><li>B：2#$#@$@#$@#说了一堆，然后说我也说完了；</li><li>A：好的，我知道了</li></ul><h5 id="为什么需要四次挥手？"><a href="#为什么需要四次挥手？" class="headerlink" title="为什么需要四次挥手？"></a>为什么需要四次挥手？</h5><p>因为 TCP 是全双工的，一方关闭连接后，另一方还可以继续发送数据。所以四次挥手，将断开连接分成两个独立的过程。</p><h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><h5 id="握手，挥手阶段包丢失怎么办？"><a href="#握手，挥手阶段包丢失怎么办？" class="headerlink" title="握手，挥手阶段包丢失怎么办？"></a>握手，挥手阶段包丢失怎么办？</h5><p>简而言之，通过定时器 + 超时重试机制，尝试获取确认，直到最后会自动断开连接。</p><p>具体而言，TCP 设有一个保活计时器。服务器每收到一次客户端的数据，都会重新复位这个计时器，时间通常是设置为 2 小时。若 2 小时还没有收到客户端的任何数据，服务器就开始重试：每隔 75 分钟发送一个探测报文段，若一连发送 10 个探测报文后客户端依然没有回应，那么服务器就认为连接已经断开了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS连接过程</title>
      <link href="/2020/07/09/2020/HTTPS%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/07/09/2020/HTTPS%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>我们前面分析了HTTP的握手与挥手，到了HTTPS这一步，涉及一些加密及证书，我们再单独复习一下。</p><p><img src="/2020/07/09/2020/HTTPS连接过程/NO1.png" alt="NO1" title="NO1"></p><a id="more"></a><h4 id="客户端访问HTTPS连接"><a href="#客户端访问HTTPS连接" class="headerlink" title="客户端访问HTTPS连接"></a>客户端访问HTTPS连接</h4><ol><li>我们在浏览器输入url并且回车，这个时候客户端会将客户端支持的加密算法套件（CIpher）发给服务端。</li></ol><h4 id="服务端发送证书（公钥）给客户端"><a href="#服务端发送证书（公钥）给客户端" class="headerlink" title="服务端发送证书（公钥）给客户端"></a>服务端发送证书（公钥）给客户端</h4><ol><li>服务端接收到Cipher后，和自己支持的加密算法对比，如果不符合则断开连接，否则，服务端把符合的算法和证书发送给客户端，包括证书时间、日期、机构。</li></ol><h4 id="客户端验证服务端证书"><a href="#客户端验证服务端证书" class="headerlink" title="客户端验证服务端证书"></a>客户端验证服务端证书</h4><ol><li>客户端验证证书，包括颁发证书的机构<code>是否合法</code>与<code>过期</code>，证书中包含的网站地址是否与正访问的地址一致等；</li><li>验证通过后，客户端会生成一个随机字符串，然后用服务端的公钥进行加密，这里就保证只有服务端可以看到这串字符串；</li><li>生成握手信息，用约定好的HASH，对握手信息进行取HASH，然后用随机字符串加密握手信息和握手信息的签名HASH，把结果发给服务端，这里要带上握手HASH是因为防止信息篡改，如果信息被篡改，那么服务端接收到信息进行HASH后，会发现HASH和客户端传回来的不一样。</li></ol><h4 id="服务端接收加密信息，解密得到客户端提供的随机字符串"><a href="#服务端接收加密信息，解密得到客户端提供的随机字符串" class="headerlink" title="服务端接收加密信息，解密得到客户端提供的随机字符串"></a>服务端接收加密信息，解密得到客户端提供的随机字符串</h4><ol><li>服务端接收到加密信息后，首先使用私钥解密得到随机字符串，然后使用随机字符串解密握手信息，获得握手信息和握手信息的HASH值，服务端对握手信息进行HASH，对比传回来的HASH，如果相同，则说明信息没有被篡改。</li><li>服务端验证完客户端后，同样用随机字符串加密握手信息和握手信息的HASH值发给客户端。</li></ol><h4 id="客户端验证服务端返回的握手信息，完成握手"><a href="#客户端验证服务端返回的握手信息，完成握手" class="headerlink" title="客户端验证服务端返回的握手信息，完成握手"></a>客户端验证服务端返回的握手信息，完成握手</h4><ol><li>客户端接收到服务端发回来的握手信息后，用一开始生成的随机字符串对密文进行解密，得到握手信息和握手HASH值，校验通过后，握手完毕，从这开始，客户端和服务端的通信就使用那串随机字符串进行AES对称加密。</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>使用RSA非对称算法，服务端向客户端发送公钥证书等；</li><li>客户端向第三方验证公钥合法性，验证通过后向服务端约定对称加密的随机字符串，保证随机字符串只有通信双方知道。</li><li>接下来通信就使用这个随机符串串进行加密通信，因为随机字符串只有双方知道，所有信息不会被截获。</li></ol><p><img src="/2020/07/09/2020/HTTPS连接过程/NO2.png" alt="NO2" title="NO2"></p><ul><li>在使用HTTPS是需要保证服务端配置正确了对应的安全证书</li><li>客户端发送请求到服务端</li><li>服务端返回公钥和证书到客户端</li><li>客户端接收后会验证证书的安全性,如果通过则会随机生成一个随机数,用公钥对其加密,发送到服务端</li><li>服务端接受到这个加密后的随机数后会用私钥对其解密得到真正的随机数,随后用这个随机数当做私钥对需要发送的数据进行对称加密</li><li>客户端在接收到加密后的数据使用私钥(即生成的随机值)对数据进行解密并且解析数据呈现结果给客户</li><li>SSL加密建立</li></ul><p><em>所以因此HTTP前期是非对称加密，后期是堆成加密？</em></p><p><img src="/2020/07/09/2020/HTTPS连接过程/NO3.png" alt="NO3" title="NO3"></p><h4 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h4><ol><li>HTTP使用80端口，HTTPS使用443端口；</li><li>HTTPS需要申请证书，需要费用；</li><li>HTTP是超文本传输协议，是明文。HTTPS需要经过SSL加密的协议；</li><li>HTTPS比HTTP慢<ul><li>通信慢：HTTPS和HTTP相比，还多了SSL通信</li><li>加密处理的运算</li></ul></li></ol><h4 id="HTTPS签名过程防篡改"><a href="#HTTPS签名过程防篡改" class="headerlink" title="HTTPS签名过程防篡改"></a>HTTPS签名过程防篡改</h4><ol><li>签名就是在信息后再加上一段内容，内容信息是经过Hash后的值，可以证明信息没有被修改过，Hash一般都会加密后和信息一起发送，保证这个hash值不给修改</li><li>使用摘要算法，对信息进行hash</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>async/await原理</title>
      <link href="/2020/06/30/2020/async-await%E5%8E%9F%E7%90%86/"/>
      <url>/2020/06/30/2020/async-await%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>async其实就是Generator的语法糖。<br>async函数对Generator的改进:</p><ol><li>内置执行器；</li><li>更好的语义， async/await；</li><li>更广的适应性；</li><li>返回Promise。</li></ol><p>async本质上是封装了Generator的自动执行器。</p><p><em>题外话：为什么Generator可以在next之前暂停?</em><br><a id="more"></a><br>A：协程。</p><p>一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。<br>协程是一种比线程更加轻量级的存在。普通线程是抢先式的，会争夺cpu资源，而协程是合作的，可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程。</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>我们看一点题目:</p><pre><code>console. log(&#39;script start&#39; )async function async1() {    await async2()     console. log( &#39; async1 end&#39; )}async function async2() {    console.1og( &#39;async2 end &#39; )}    async1()setTimeout(function() {    console. log( &#39;setTimeout&#39; )}, 0)new Promise(resolve =&gt; {    console.log(&#39; Promise&#39; )    resolve() }).then( function() {    console。log( &#39; promise1&#39; )}).then(function() {    console.1og( &quot; promise2&#39; )})console. log( &#39;script end&#39; )</code></pre><p><em>你知道答案是什么吗?</em><br>script start - async2 end - Promise - script end  -  promise1 - promise2 - async1 end - setTimeout</p><p><em>解析：</em></p><ol><li>执行代码，输出script start。</li><li>执行async1(),会调用async2(),然后输出async2 end,此时将会保留async1函数的上下文，然后跳出async1函数。(async 返回一个Promise， Promise是立即执行的。)</li><li>遇到setTimeout，产生一个宏任务</li><li>执行Promise，输出Promise。遇到then，产生第一个微任务</li><li>继续执行代码，输出script end</li><li>代码逻辑执行完毕(当前宏任务执行完毕)，开始执行当前宏任务产生的微任务队列，输出promise1，该微任务遇到then，产生一个新的微任务</li><li>执行产生的微任务，输出promise2,当前微任务队列执行完毕。执行权回到async1</li><li>执行await,实际上会产生一个promise返回</li><li>执行完成，执行await后面的语句，输出async1 end</li><li>最后，执行下一个宏任务，即执行setTimeout，输出setTimeout</li></ol><h3 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h3><p>实现一个Sleep, 每隔一秒输出1，2，3，4，5</p><pre><code>function sleep(interval) {    return new Promise(resolve =&gt; {        setTimeout(resolve, interval);    })}// 用法async function one2FiveInAsync() {    for (let i = 1; i &lt;= 5; i++) {        console.log(i);        await sleep(1000);    }}one2FiveInAsync();</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue响应式原理</title>
      <link href="/2020/06/21/2020/Vue%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/"/>
      <url>/2020/06/21/2020/Vue%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue2"><a href="#Vue2" class="headerlink" title="Vue2"></a>Vue2</h2><p>之前看过几回<code>Vue</code>的响应式原理剖析，但是几乎总是不久就忘记了，仅仅是依稀记得<code>defineProperty</code>做<code>get</code>和<code>set</code>的数据劫持，然后在此基础上做一些发布，说到底还是可能不够深入，不够理解，特此希望借此总结一下，将一些点做下记录，顺便对源码做一些回顾。<br>我们从三个部分来介绍<code>Vue</code>的响应式原理的实现：</p><ul><li>对象变响应式</li><li>get收集依赖</li><li>set发布更新</li></ul><h3 id="对象变响应式"><a href="#对象变响应式" class="headerlink" title="对象变响应式"></a>对象变响应式</h3><p>我们都知道<code>Vue</code>中是通过<code>defineProperty</code>进行数据劫持，但是他具体是如何进行到劫持这一步的呢？<br>我们一起从<code>Vue</code>的源码中开始了解一下吧！</p><h4 id="index入口"><a href="#index入口" class="headerlink" title="index入口"></a>index入口</h4><ul><li><code>src\core\instance\index.js</code></li></ul><p>Vue的源码入口，其中通过<code>Function</code>实现的<code>Vue</code>这个类，并且还执行了一些方法，</p><pre><code>initMixin(Vue) stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)</code></pre><p>从字面意思上来看，我们很容易理解，<code>Mixin</code>，什么event，lifecycleMixin，大概应该都是对Vue这个进行的扩展。这个以后有机会的话一起详细看看，本单元我们的主角，就是<code>initMixin(Vue)</code>，我们看看它实现了什么呢。</p><h4 id="initJS"><a href="#initJS" class="headerlink" title="initJS"></a>initJS</h4><ul><li><code>src\core\instance\init.js</code></li></ul><p>我们看看<code>init</code>方法倒是实现了什么，我会去除掉部分代码，我们本单元关键是寻找如何变成响应式对象的。</p><pre><code>export function initMixin (Vue: Class&lt;Component&gt;) {  Vue.prototype._init = function (options?: Object) {    const vm: Component = this    vm._uid = uid++    // ...    initLifecycle(vm)    initEvents(vm)    initRender(vm)    // ...    callHook(vm, &#39;beforeCreate&#39;)    initInjections(vm)    initState(vm)    initProvide(vm)    callHook(vm, &#39;created&#39;)    // ...    if (vm.$options.el) {      vm.$mount(vm.$options.el)    }  }}</code></pre><p>将<code>vm</code>变量赋值为<code>this</code>，这就是我们常见的<code>vm.xxx</code>写法，其中这就是<code>vm = this</code>的由来，这其中是对<code>生命周期</code>，<code>事件</code>的一些初始化，以及调用了两个生命<code>钩子</code>函数。而最主要的对<code>data</code>和<code>prop</code>的处理，则是在<code>initState</code>中。</p><h4 id="stateJS"><a href="#stateJS" class="headerlink" title="stateJS"></a>stateJS</h4><ul><li><code>src\core\instance\state.js</code></li></ul><pre><code>export function initState (vm: Component) {  vm._watchers = []  const opts = vm.$options  if (opts.props) initProps(vm, opts.props)  if (opts.methods) initMethods(vm, opts.methods)  if (opts.data) {    initData(vm) // 初始化数据  } else {    observe(vm._data = {}, true /* asRootData */)  }  if (opts.computed) initComputed(vm, opts.computed)  if (opts.watch &amp;&amp; opts.watch !== nativeWatch) {    initWatch(vm, opts.watch) // 初始化 Watch  }}</code></pre><p><code>initState</code>主要对<code>prop</code>，<code>methods</code>，<code>data</code>，<code>computed</code>，<code>watch</code>都分别做一些处理，其中<code>prop</code>和<code>data</code>是我们要下一步查看的。</p><h4 id="initPorps"><a href="#initPorps" class="headerlink" title="initPorps"></a>initPorps</h4><ol><li><code>initPorps</code></li></ol><pre><code>function initProps (vm: Component, propsOptions: Object) {  const propsData = vm.$options.propsData || {}  const props = vm._props = {}  const keys = vm.$options._propKeys = []  const isRoot = !vm.$parent  for (const key in propsOptions) {    keys.push(key)    const value = validateProp(key, propsOptions, propsData, vm)    if (process.env.NODE_ENV !== &#39;production&#39;) {      // ...    } else {      defineReactive(props, key, value)    }    // ...    if (!(key in vm)) {      proxy(vm, `_props`, key)    }  }  toggleObserving(true)}</code></pre><p>先从定义的props中遍历，调用了<code>validateProp</code>校验<code>props</code>是否符合规范。然后遍历<code>propsOptions</code>调用<code>defineReactive</code>方法把每个<code>prop</code>变成响应式，然后执行<code>proxy</code>方法，这个方法又是干什么的呢？</p><p>在这里我们先记住留下两个点需要解决，需要去跟踪：</p><ol><li><code>defineReactive</code>方法；</li><li><code>proxy</code>方法；</li></ol><p>我们需要再回头看看刚刚的<code>initData(vm)</code>。</p><h4 id="initData"><a href="#initData" class="headerlink" title="initData"></a>initData</h4><pre><code>function initData (vm: Component) {  let data = vm.$options.data  data = vm._data = typeof data === &#39;function&#39;    ? getData(data, vm)    : data || {}  // ...  const keys = Object.keys(data)  const props = vm.$options.props  const methods = vm.$options.methods  let i = keys.length  while (i--) {    const key = keys[i]    if (process.env.NODE_ENV !== &#39;production&#39;) {      if (methods &amp;&amp; hasOwn(methods, key)) {        warn(          `Method &quot;${key}&quot; has already been defined as a data property.`,          vm        )      }    }    if (props &amp;&amp; hasOwn(props, key)) {      process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(        `The data property &quot;${key}&quot; is already declared as a prop. ` +        `Use prop default value instead.`,        vm      )    } else if (!isReserved(key)) {      proxy(vm, `_data`, key)    }  }  observe(data, true /* asRootData */)}</code></pre><p><code>initData</code>这一段代码做了啥呢？先判断了一下<code>data</code>是不是一个方法，是的话使用<code>getData</code>拿到手。然后取出<code>data</code>中的数据，与<code>methods</code>，<code>props</code>中的数据做判断，判断是否存在键值重复！所有这里这一步就是我们再Vue组件中定义了键值重复时抛出警告的地方。</p><p>我们继续，诶，很眼熟，又是<code>proxy方法</code>，然后往下执行，是一个<code>observe</code>新方法，它们又是做什么的呢？</p><p>我们在记录一下，然后可以往下跟踪，我们现在有三个未接之谜了：</p><ol><li><code>defineReactive</code>方法；</li><li><code>proxy</code>方法；</li><li><code>observe</code>方法。</li></ol><h4 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h4><ul><li><code>src\core\instance\state.js</code></li></ul><p>还记得怎么使用<code>proxy</code>的吗？</p><pre><code>proxy(vm, `_props`, key)</code></pre><pre><code>const sharedPropertyDefinition = {  enumerable: true,  configurable: true,  get: noop,  set: noop}export function proxy (target: Object, sourceKey: string, key: string) {  sharedPropertyDefinition.get = function proxyGetter () {    return this[sourceKey][key]  }  sharedPropertyDefinition.set = function proxySetter (val) {    this[sourceKey][key] = val  }  Object.defineProperty(target, key, sharedPropertyDefinition)}</code></pre><p>简单几句，传入得三个参数分别为<code>vm(this)</code>，<code>sourceKey</code>，<code>key</code>，这一步操作，其实还是利用了<code>get</code>，<code>set</code>将<code>props</code>上的参数代理到<code>vm(this)</code>上。仅此而已，也是因为这样，我们在<code>Vue</code>中才可以使用<code>this.xxx</code>去访问<code>props</code>上的传入的参数。好了，我们消灭了一个疑问<code>proxy</code>。</p><h4 id="observe"><a href="#observe" class="headerlink" title="observe"></a>observe</h4><ul><li>src\core\observer\index.js</li></ul><pre><code>export function observe (value: any, asRootData: ?boolean): Observer | void {  if (!isObject(value) || value instanceof VNode) {    return  }  let ob: Observer | void  if (hasOwn(value, &#39;__ob__&#39;) &amp;&amp; value.__ob__ instanceof Observer) {    ob = value.__ob__  } else if (    shouldObserve &amp;&amp;    !isServerRendering() &amp;&amp;    (Array.isArray(value) || isPlainObject(value)) &amp;&amp;    Object.isExtensible(value) &amp;&amp;    !value._isVue  ) {    ob = new Observer(value)  }  if (asRootData &amp;&amp; ob) {    ob.vmCount++  }  return ob}</code></pre><p><code>observe</code>方法，首先先判断了一下传入的对象是不是<code>vnode</code>，对于非<code>VNODE</code>的对象类型才添加一个<code>Observer</code>，new出来的实例，那这个<code>Observer</code>又是啥，现在又有两个问题需要解决了。</p><ol><li><code>Observer</code>方法；</li><li><code>defineReactive</code>方法；</li></ol><h4 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h4><ul><li>src\core\observer\index.js</li></ul><pre><code>export class Observer {  // ...  constructor (value: any) {    this.value = value    this.dep = new Dep()    this.vmCount = 0    def(value, &#39;__ob__&#39;, this)    if (Array.isArray(value)) {      // ...      this.observeArray(value) // 依然会遍历数组，然后observe    } else {      // ...      this.walk(value)    }  }  walk (obj: Object) {    const keys = Object.keys(obj)    for (let i = 0; i &lt; keys.length; i++) {      defineReactive(obj, keys[i])    }  }  observeArray (items: Array&lt;any&gt;) {    for (let i = 0, l = items.length; i &lt; l; i++) {      observe(items[i])    }  }}</code></pre><p><code>Observer</code>是一个类，其中似乎创建了一个什么实例<code>new Dep</code>，这个我们先留下观察，继续向下，然后调用了<code>def</code>这么一个方法，这个方法是做什么呢？</p><ul><li><code>src\core\util\lang.js</code></li></ul><pre><code>export function def (obj: Object, key: string, val: any, enumerable?: boolean) {  Object.defineProperty(obj, key, {    value: val,    enumerable: !!enumerable,    writable: true,    configurable: true  })}</code></pre><pre><code>def(value, &#39;__ob__&#39;, this)</code></pre><p>其实<code>def</code>封装了defineProperty，调用此方法可以在传入的<code>obj</code>上绑定一个<code>value</code>的<code>key</code>，在这一块，就是在我们data上绑定一个<strong>ob</strong>的属性。</p><p>然后继续向下走，使用<code>isArray</code>判断value是不是数组，如果是数组，则调用了<code>observeArray</code>，否则则调用<code>walk</code>方法。</p><ul><li><code>observeArray</code></li></ul><pre><code>observeArray (items: Array&lt;any&gt;) {    for (let i = 0, l = items.length; i &lt; l; i++) {      observe(items[i])    }}</code></pre><p>这就是遍历调用observe方法。</p><ul><li><code>walk</code><pre><code>walk (obj: Object) {  const keys = Object.keys(obj)  for (let i = 0; i &lt; keys.length; i++) {    defineReactive(obj, keys[i])  }}</code></pre><code>walk</code>是在对象的情况下，遍历对象，对每一个key-value调用<code>defineReactive</code>方法，好家伙，兜兜转转又回来了。</li></ul><p>剩余跟踪问题：</p><ol><li><code>defineReactive</code>方法；</li></ol><h4 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive"></a>defineReactive</h4><ul><li><code>src\core\observer\index.js</code></li></ul><pre><code>export function defineReactive (  obj: Object,  key: string,  val: any,  customSetter?: ?Function,  shallow?: boolean // 如果 shallow  为 true) {  // 对每一个属性对new一个Dep依赖  const dep = new Dep()  // ...  const getter = property &amp;&amp; property.get  const setter = property &amp;&amp; property.set  if ((!getter || setter) &amp;&amp; arguments.length === 2) {    val = obj[key]  }  // ...  let childOb = !shallow &amp;&amp; observe(val)  Object.defineProperty(obj, key, {    enumerable: true,    configurable: true,    get: function reactiveGetter () {      // ...    },    set: function reactiveSetter (newVal) {      // ...    }  })}</code></pre><p>是不是有点熟悉，这不就是我们经常背的<code>Vue</code>响应式原理吗？通过<code>defineProperty</code>进行数据劫持啥啥啥的，最终我们还是走到了这里。<br>是的，在<code>defineProperty</code>中，通过<code>defineProperty</code>进行对对象的属性添加<code>getter</code>和<code>setter</code>进行数据劫持。<br>而这里面就深藏了我们的后续动作：<strong>收集依赖</strong>，<strong>发布更新</strong>。</p><h3 id="get收集依赖"><a href="#get收集依赖" class="headerlink" title="get收集依赖"></a>get收集依赖</h3><p>我们继续看看<code>defineProperty</code>中的<code>get</code>怎么做的依赖收集？</p><pre><code>export function defineReactive (  obj: Object,  key: string,  val: any,  customSetter?: ?Function,  shallow?: boolean // 如果 shallow  为 true) {  // 对每一个属性对new一个Dep依赖  const dep = new Dep()  const property = Object.getOwnPropertyDescriptor(obj, key)  if (property &amp;&amp; property.configurable === false) {    return  }  // 拿到其原本的getter与setter方法  const getter = property &amp;&amp; property.get  const setter = property &amp;&amp; property.set  if ((!getter || setter) &amp;&amp; arguments.length === 2) {    val = obj[key]  }  // 迭代其子属性  let childOb = !shallow &amp;&amp; observe(val)  Object.defineProperty(obj, key, {    enumerable: true,    configurable: true,    get: function reactiveGetter () {      const value = getter ? getter.call(obj) : val      if (Dep.target) {        dep.depend()        if (childOb) {          childOb.dep.depend()           if (Array.isArray(value)) {            dependArray(value)          }        }      }      return value    },    set: function reactiveSetter (newVal) {      // ...    }  })}</code></pre><p>这里面分别有这么三步，是重要的：</p><ol><li>const dep = new Dep()；</li><li>dep.depend()；</li><li>childOb的处理。<pre><code>if (childOb) { childOb.dep.depend()  if (Array.isArray(value)) {   dependArray(value) }}</code></pre></li></ol><p>在了解这些之前，我们应该需要看看<code>new Dep</code>，究竟创建了个啥？</p><h4 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h4><ul><li><code>src\core\observer\dep.js</code></li></ul><pre><code>export default class Dep {  static target: ?Watcher;  id: number;  subs: Array&lt;Watcher&gt;;  constructor () {    this.id = uid++    this.subs = []  }  addSub (sub: Watcher) {    this.subs.push(sub)  }  removeSub (sub: Watcher) {    remove(this.subs, sub)  }  depend () {    if (Dep.target) {      Dep.target.addDep(this)    }  }  notify () {    const subs = this.subs.slice()    if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; !config.async) {      subs.sort((a, b) =&gt; a.id - b.id)    }    // 循环更新    for (let i = 0, l = subs.length; i &lt; l; i++) {      subs[i].update()    }  }}</code></pre><p>嗯，很眼熟有没有，这就是一个<code>addSub</code>，<code>removeSub</code>，这就是一个发布订阅呀有没有，好吧，我们继续来看。<br>这个<code>this.subs</code>是一个<code>Watcher</code>的数组，那它发布订阅管理的是<code>Watcher</code>吗？</p><p>那这个<code>Watcher</code>又是啥？</p><h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h4><ul><li><code>src\core\observer\watcher.js</code></li></ul><pre><code>export default class Watcher {  // ...  constructor (    vm: Component,    expOrFn: string | Function,    cb: Function,    options?: ?Object,    isRenderWatcher?: boolean  ) {    this.vm = vm    if (isRenderWatcher) {      vm._watcher = this    }    vm._watchers.push(this)    // options    if (options) {      this.deep = !!options.deep      this.user = !!options.user      this.lazy = !!options.lazy      this.sync = !!options.sync      this.before = options.before    } else {      this.deep = this.user = this.lazy = this.sync = false    }    this.cb = cb    this.id = ++uid // uid for batching    this.active = true    this.dirty = this.lazy // for lazy watchers    this.deps = []    this.newDeps = []    this.depIds = new Set()    this.newDepIds = new Set()    this.expression = process.env.NODE_ENV !== &#39;production&#39;      ? expOrFn.toString()      : &#39;&#39;    // parse expression for getter    if (typeof expOrFn === &#39;function&#39;) {      this.getter = expOrFn    } else {      this.getter = parsePath(expOrFn)      if (!this.getter) {        this.getter = noop        process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(          `Failed watching path: &quot;${expOrFn}&quot; ` +          &#39;Watcher only accepts simple dot-delimited paths. &#39; +          &#39;For full control, use a function instead.&#39;,          vm        )      }    }    this.value = this.lazy      ? undefined      : this.get()  }  /**   * Evaluate the getter, and re-collect dependencies.   */  get () {    pushTarget(this)，    let value    const vm = this.vm    try {      value = this.getter.call(vm, vm)    } catch (e) {      if (this.user) {        handleError(e, vm, `getter for watcher &quot;${this.expression}&quot;`)      } else {        throw e      }    } finally {      if (this.deep) {        traverse(value)      }      popTarget()      this.cleanupDeps()    }    return value  }  addDep (dep: Dep) {    const id = dep.id    if (!this.newDepIds.has(id)) {      this.newDepIds.add(id)      this.newDeps.push(dep)      if (!this.depIds.has(id)) {        dep.addSub(this) //  addSub 为 sub 队列，添加一个Watcher 实例化对象      }    }  }  // 清理观察者依赖项集合  cleanupDeps () {    let i = this.deps.length    while (i--) {      const dep = this.deps[i]      if (!this.newDepIds.has(dep.id)) {        dep.removeSub(this)      }    }    let tmp = this.depIds    this.depIds = this.newDepIds    this.newDepIds = tmp    this.newDepIds.clear()    tmp = this.deps    this.deps = this.newDeps    this.newDeps = tmp    this.newDeps.length = 0  }  update () {    /* istanbul ignore else */    if (this.lazy) {      this.dirty = true    } else if (this.sync) {       this.run()    } else {      queueWatcher(this)    }  }  run () {    if (this.active) {      const value = this.get()      if (        value !== this.value ||        isObject(value) ||        this.deep      ) {        const oldValue = this.value        this.value = value        if (this.user) {          try {            this.cb.call(this.vm, value, oldValue)          } catch (e) {            handleError(e, this.vm, `callback for watcher &quot;${this.expression}&quot;`)          }        } else {          this.cb.call(this.vm, value, oldValue)        }      }    }  }  evaluate () {    this.value = this.get()    this.dirty = false  }  depend () {    let i = this.deps.length    while (i--) {      this.deps[i].depend()    }  }  teardown () {    if (this.active) {      // remove self from vm&#39;s watcher list      // this is a somewhat expensive operation so we skip it      // if the vm is being destroyed.      if (!this.vm._isBeingDestroyed) {        remove(this.vm._watchers, this)      }      let i = this.deps.length      while (i--) {        this.deps[i].removeSub(this)      }      this.active = false    }  }}</code></pre><pre><code>Dep.target = nullconst targetStack = []export function pushTarget (target: ?Watcher) {  targetStack.push(target)  Dep.target = target}export function popTarget () {  targetStack.pop()  Dep.ta</code></pre><p><code>Watcher</code>也是一个类，其中定义了</p><ol><li><code>this.deps</code>，<code>this.newDeps</code>两数组，看名字，像是与Dep实例有关的数组；</li><li><code>this.depIds</code>，<code>this.newDepIds</code>两个<code>set</code>结构；</li><li><code>get()</code>方法；</li><li><code>addDep()</code>方法；</li><li><code>cleanupDeps</code>方法；</li><li><code>update</code>方法；</li><li><code>run</code>、<code>evaluate</code>、<code>depend</code>、<code>teardown</code>等方法。</li></ol><p>在初始化<code>Watcher</code>的时候会触发进入<code>get</code>方法，<code>get</code>方法中调用<code>pushTarget</code>，这个<code>pushTarget</code>是调用了<code>dep</code>中<code>pushTargt</code>方法，将<code>this</code>push进<code>taegetStack</code>的堆栈中，并且：</p><pre><code>Dep.target = target</code></pre><pre><code>static target: ?Watcher;</code></pre><p>将静态属性<code>target</code>设置为当前this(Watcher)，此处的<code>target</code>设置留下疑问①。</p><p>接下来我们继续，</p><pre><code>try {  value = this.getter.call(vm, vm)} catch (e) {  // ...}</code></pre><p>此处的<code>this.getter</code>，就是在<code>constructor</code>中设置的<code>expOrFn</code>。</p><pre><code>// r: 88if (typeof expOrFn === &#39;function&#39;) {  this.getter = expOrFn} </code></pre><p>那么这个<code>expOrFn</code>是传入了什么？我们可以在全局搜索一下在何处new了Watcher。<br><img src="/2020/06/21/2020/Vue数据双向绑定原理/NO1.png" alt="NO1" title="NO1"></p><p>在这个<code>mountComponent</code>中调用的，并且传入了</p><pre><code>updateComponent = () =&gt; {  vm._update(vm._render(), hydrating)// 调用 Vue.prototype._update}</code></pre><p>因此，我们可以得出在这里<code>expOfFn = updateComponent</code>的结论，并且我们可以依然搜索，在<code>src\platforms\web\runtime\index.js</code>中，mount方法正是借用了<code>updateComponent</code>。</p><p>好了，我们回来，刚刚提到<code>this.getter.call()</code>，按照现在的寻找，正是执行了<code>vm._update(vm._render(), hydrating)</code>，在执行渲染时自然会触发<code>VNODE</code>对于<code>vm</code>上数据的访问，就会触发数据对象上设置的<code>getter</code>。</p><p>触发了get之后呢？<br>我们重新回到<code>defineRecative</code>，看看get中还做了啥。</p><pre><code>const value = getter ? getter.call(obj) : val// 在get中手机属性依赖if (Dep.target) {  dep.depend()// 此里面做依赖收集，这个Dep有什么作用? --- src/core/observer/dep.js  if (childOb) {    childOb.dep.depend()     if (Array.isArray(value)) {      dependArray(value)    }  }}</code></pre><p>因为刚刚<code>Dep.target</code>已经修改为Watcher了，就会执行<code>dep.depend</code>方法</p><pre><code>depend () {  if (Dep.target) {    Dep.target.addDep(this)  }}</code></pre><p>而这个还是转头执行<code>addDep</code>，watcher中的addDep</p><pre><code>addDep (dep: Dep) {  const id = dep.id  if (!this.newDepIds.has(id)) {    this.newDepIds.add(id)    this.newDeps.push(dep)    if (!this.depIds.has(id)) {      dep.addSub(this);    }  }}</code></pre><p>这里面做了一些判断，看样子是对一下判断是否有重复的情况…然后执行<code>addSub</code>，将<code>watcher</code>添加订阅到subs中。</p><pre><code>addSub (sub: Watcher) {  this.subs.push(sub)}</code></pre><p>这样，在后续的<code>subs</code>pop执行更新派发时就可以通知到了。</p><h3 id="派发更新"><a href="#派发更新" class="headerlink" title="派发更新"></a>派发更新</h3><p>派发更新这一步，我们需要看回原来的<code>defineReactive</code>，看看里面的set做了什么。</p><pre><code>export function defineReactive (  obj: Object,  key: string,  val: any,  customSetter?: ?Function,  shallow?: boolean // 如果 shallow  为 true) {  // ...  Object.defineProperty(obj, key, {    enumerable: true,    configurable: true,    get: function reactiveGetter () {      // ...    },    set: function reactiveSetter (newVal) {      const value = getter ? getter.call(obj) : val      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) {        return      }      if (getter &amp;&amp; !setter) return      if (setter) {        setter.call(obj, newVal)      } else {        val = newVal      }      childOb = !shallow &amp;&amp; observe(newVal)      dep.notify()    }  })}</code></pre><p><code>set</code>内先对新值旧值做了一些比较，以及设置，然后就来到了这两行：</p><pre><code>childOb = !shallow &amp;&amp; observe(newVal)dep.notify()</code></pre><p>看起来比较高深，<code>dep.notify</code>故名思意，就是通知，那么应该就是这一步，对所有订阅者进行了通知。</p><p><code>!shallow &amp;&amp; observe(newVal)</code>当<code>shallow</code>是<code>false</code>的情况下，会再调用<code>observe</code>将newVal设置为响应式对象(observe在我们之前的内容中有讲到)。</p><h4 id="dep-notify"><a href="#dep-notify" class="headerlink" title="dep.notify"></a>dep.notify</h4><p><code>dep.notify</code>在类<code>Dep</code>中，<code>src\core\observer\dep.js</code>，r: 44，</p><pre><code>notify () {  const subs = this.subs.slice()  if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; !config.async) {    subs.sort((a, b) =&gt; a.id - b.id)  }  // 循环更新  for (let i = 0, l = subs.length; i &lt; l; i++) {    subs[i].update()  }}</code></pre><p>其中先对<code>subs</code>排了个序，当做先来后到，正确触发。然后在遍历，依次执行<code>update</code>方法，因为我们指定<code>subs</code>是<code>watcher</code>的数组，所有执行的也是<code>watcher</code>的<code>update</code>方法。</p><h4 id="watcher-update"><a href="#watcher-update" class="headerlink" title="watcher.update"></a>watcher.update</h4><pre><code>update () {  if (this.lazy) {    this.dirty = true  } else if (this.sync) {    this.run()  } else {    queueWatcher(this)  }}</code></pre><p>其实这个<code>lazy</code>会对应的<code>computed</code>中的响应，我们后续有机会可以了解。<code>sync</code>是同步的情况下则直接改变。</p><p>我们来到了<code>queueWatcher</code>，看看这个里面做了什么？</p><h4 id="queueWatcher"><a href="#queueWatcher" class="headerlink" title="queueWatcher"></a>queueWatcher</h4><ul><li><code>src\core\observer\scheduler.js</code></li></ul><pre><code>export function queueWatcher (watcher: Watcher) {  const id = watcher.id  if (has[id] == null) {    has[id] = true    if (!flushing) {      queue.push(watcher)    } else {      // if already flushing, splice the watcher based on its id      // if already past its id, it will be run next immediately.      let i = queue.length - 1      while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) {        i--      }      queue.splice(i + 1, 0, watcher)    }    // queue the flush    if (!waiting) {      waiting = true      if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; !config.async) {        flushSchedulerQueue()        return      }      nextTick(flushSchedulerQueue)    }  }}</code></pre><p>先是使用了<code>has</code>对象判断了<code>watcher</code>不能重复，那这个<code>flush</code>又是做啥的？暂时看不出来，我们先留下疑问。<br>接下去调用<code>nextTick</code>执行<code>flushSchedulerQueue</code>方法，这样子统一放进一个队列中进行，而不是每次更改都触发。</p><pre><code>function flushSchedulerQueue () {  currentFlushTimestamp = getNow()  flushing = true  let watcher, id  queue.sort((a, b) =&gt; a.id - b.id) // 根据id排序  for (index = 0; index &lt; queue.length; index++) {    watcher = queue[index]    if (watcher.before) {      watcher.before()    }    id = watcher.id    has[id] = null    watcher.run()    if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; has[id] != null) {      circular[id] = (circular[id] || 0) + 1      if (circular[id] &gt; MAX_UPDATE_COUNT) {        warn(          &#39;You may have an infinite update loop &#39; + (            watcher.user              ? `in watcher with expression &quot;${watcher.expression}&quot;`              : `in a component render function.`          ),          watcher.vm        )        break      }    }  }  // keep copies of post queues before resetting state  const activatedQueue = activatedChildren.slice()  const updatedQueue = queue.slice()  resetSchedulerState()  callActivatedHooks(activatedQueue)  callUpdatedHooks(updatedQueue)  if (devtools &amp;&amp; config.devtools) {    devtools.emit(&#39;flush&#39;)  }}</code></pre><ol><li><p><code>queue.sort</code>进行了排序，源码已经有明确的注释表明含义了，大致就是：组件更新从父到子，所以执行也需要按照此顺序；</p></li><li><p>遍历<code>queue</code>，然后执行<code>watcher.run</code></p></li></ol><pre><code>run () {  if (this.active) {    const value = this.get()    if (      value !== this.value ||      isObject(value) ||      this.deep    ) {      const oldValue = this.value      this.value = value      if (this.user) {        try {          this.cb.call(this.vm, value, oldValue)        } catch (e) {          handleError(e, this.vm, `callback for watcher &quot;${this.expression}&quot;`)        }      } else {        this.cb.call(this.vm, value, oldValue)      }    }  }}</code></pre><p><code>run</code>方法执行了<code>get</code>去拿到当前的值，并且判断了新值旧值是否相等，是否是对象，是否deep为true，有一者满足的情况下会执行回调函数，并将新值，旧值做为参数。以及一些操作，清除Scheduler和触发<code>update</code>钩子等操作。</p><p>执行<code>get</code>方法时，会触发<code>getter</code>，也是前面提到的<code>expOrFn = updateComponent</code>重新<code>render</code>组件。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EventLoop</title>
      <link href="/2020/06/12/2020/EventLoop/"/>
      <url>/2020/06/12/2020/EventLoop/</url>
      
        <content type="html"><![CDATA[<h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p>先了解下任务队列</p><ul><li>所有同步任务都在主线程上执行，形成一个执行栈</li><li>主线程之外，还存在一个任务队列。只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li><li>一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li><p>主线程不断重复上面的第三步。<br>此时区分为浏览器的事件循环和Node端的事件循环。下面将一一详解。<br>主线程从任务队列中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop(事件循环)</p><a id="more"></a><p>在一个事件循环当中，执行的步骤如下：</p></li><li><p>首先将同步代码放入执行栈进行执行，若存在异步事件则将其的返回结果会被放到一个任务队列中。任务队列又分为宏任务队列和微任务队列。</p></li><li>当执行栈为空时，会优先查看微任务队列中是否有事件存在</li><li>若存在，则依次执行队列事件中的对应回调，直到微任务队列为空，再进入下一步</li><li>若不存在，跳往下一步</li><li>查看宏任务队列中是否有事件存在</li><li>若存在，则将队列中的事件的对应回调放入执行栈执行</li><li>若不存在，跳往下一步</li><li>若执行栈中又有异步代码，则放入下一个任务队列。如此反复循环前三个步骤</li></ul><p>从以上我们得知重点是执行栈为空后优先处理<code>微任务</code>再处理<code>宏任务</code>。</p><p>微任务：</p><ul><li>process.nextTick</li><li>promise、then、catch</li><li>Object.observe</li></ul><p>宏任务：</p><ul><li>setTimeout</li><li>setInterval</li><li>I\O</li><li>setImmediate</li></ul><p>eg.</p><pre><code>console.log(&#39;start&#39;)const interval = setInterval(() =&gt; {    console.log(&#39;setInterval&#39;)}, 0)setTimeout(() =&gt; {    console.log(&#39;setTimeout 1&#39;)  Promise.resolve()      .then(() =&gt; {        console.log(&#39;promise 3&#39;)      })      .then(() =&gt; {        console.log(&#39;promise 4&#39;)      })      .then(() =&gt; {        setTimeout(() =&gt; {          console.log(&#39;setTimeout 2&#39;)          Promise.resolve()              .then(() =&gt; {                console.log(&#39;promise 5&#39;)              })              .then(() =&gt; {                console.log(&#39;promise 6&#39;)              })              .then(() =&gt; {                clearInterval(interval)              })        }, 0)      })}, 0)Promise.resolve().then(() =&gt; {      console.log(&#39;promise 1&#39;)}).then(() =&gt; {    console.log(&#39;promise 2&#39;)})</code></pre><p><em>会输出什么呢?</em></p><p>答案:</p><ol><li>start</li><li>promise 1</li><li>promise 2</li><li>setInterval</li><li>setTimeout 1</li><li>promise 3</li><li>promise 4</li><li>setInterval</li><li>setTimeout 2</li><li>promise 5</li><li>promise 6</li></ol><p>其实按照以上的思路，宏任务-微任务-宏任务，是很好理解的。</p><p><code>then</code></p><pre><code>const p = function() {    return new Promise((resolve, reject) =&gt; {        const p1 = new Promise((resolve, reject) =&gt; {            setTimeout(() =&gt; {                resolve(1);            });            resolve(2);        });        p1.then((res) =&gt; {            console.log(res);        });        console.log(3);        resolve(4);    })}p.then((res) =&gt; {    console.log(res);})console.log(&#39;end&#39;)</code></pre><p><em>你知道答案吗?</em></p><p>A： 3-end-2-4<br>你答对了吗?</p><p>解析:<br>执行代码，Promise本身是同步的立即执行函数，.then是异步执行函数。遇到setTimeout，先把其放入宏任务队列中遇到p1.then会先放到微任务队列中，接着往下执行，输出 3<br>遇到 p().then 会先放到微任务队列中，接着往下执行，输出 end<br>同步代码块执行完成后，开始执行微任务队列中的任务，首先执行 p1.then，输出 2, 接着执行p().then, 输出 4<br>微任务执行完成后，开始执行宏任务，setTimeout, resolve(1)，但是此时 p1.then已经执行完成，此时 1不会输出。</p><h2 id="Node-EventLoop"><a href="#Node-EventLoop" class="headerlink" title="Node EventLoop"></a>Node EventLoop</h2><p><img src="/2020/06/12/2020/EventLoop/NO1.png" alt="NO1" title="NO1"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域访问</title>
      <link href="/2020/05/11/2020/cors%E8%B7%A8%E5%9F%9F/"/>
      <url>/2020/05/11/2020/cors%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Cross-Origin Resource Sharing（CORS）跨来源资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略。</p><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p><em>同源策略?</em></p><p>源(origin)其实就是指的URL。<br>eg. <a href="https://jayantxu.cn:80/p/abcd#123?query=cool">https://jayantxu.cn:80/p/abcd#123?query=cool</a></p><table><thead><tr><th>protocol</th><th>host</th><th>port</th><th>pathname</th><th>hash</th><th>query string</th></tr></thead><tbody><tr><td>https</td><td>jayantxu.cn</td><td>80</td><td>/p/abcd</td><td>123</td><td>query=cool</td></tr><tr><td>location.protocol</td><td>location.host</td><td>location.port</td><td>location.pathname</td><td>location.hash</td><td>location.search</td></tr></tbody></table><p>同源就是指URL中<code>protocol协议</code>、<code>host域名</code>、<code>port端口</code>这三个部分相同，其中一者不同即不同。</p><p>源不同会限制你：</p><ul><li>AJAX 请求不能发送。</li><li>无法获取DOM元素并进行操作。</li><li>无法读取Cookie、LocalStorage 和 IndexDB 。</li></ul><a id="more"></a><p>有些请求是不受跨域请求限制的, eg. WebSocket、script、img、iframe、video、audio…</p><p>跨域错误：</p><pre><code>[Error] Origin http://127.0.0.1:8080 is not allowed by Access-Control-Allow-Origin.[Error] Failed to load resource: Origin http://127.0.0.1:8080 is not allowed by Access-Control-Allow-Origin. (normal, line 0)[Error] XMLHttpRequest cannot load http://127.0.0.1:3000/getInfo due to access control checks.</code></pre><h3 id="常见解决方法"><a href="#常见解决方法" class="headerlink" title="常见解决方法"></a>常见解决方法</h3><h4 id="1、jsonp请求"><a href="#1、jsonp请求" class="headerlink" title="1、jsonp请求"></a>1、jsonp请求</h4><p>只接受get这一种请求。<br>eg.Ajax</p><pre><code>dataType: &#39;jsonp&#39;</code></pre><h4 id="2、postMessage跨域"><a href="#2、postMessage跨域" class="headerlink" title="2、postMessage跨域"></a>2、postMessage跨域</h4><p>H5的新API</p><ol><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li><li>上面三个场景的跨域数据传递</li></ol><p>例如：使用iframe兼容老系统，嵌入打开的时候，可以使用此进行通信。</p><p><em>a.html</em></p><pre><code>&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt;           var iframe = document.getElementById(&#39;iframe&#39;);    iframe.onload = function() {        var data = {            name: &#39;aym&#39;        };        // 向domain2传送跨域数据        iframe.contentWindow.postMessage(JSON.stringify(data), &#39;http://www.domain2.com&#39;);    };    // 接受domain2返回数据    window.addEventListener(&#39;message&#39;, function(e) {        alert(&#39;data from domain2 ---&gt; &#39; + e.data);    }, false);&lt;/script&gt;</code></pre><p><em>b.html</em></p><pre><code>&lt;script&gt;    // 接收domain1的数据    window.addEventListener(&#39;message&#39;, function(e) {        alert(&#39;data from domain1 ---&gt; &#39; + e.data);        var data = JSON.parse(e.data);        if (data) {            data.number = 16;            // 处理后再发回domain1            window.parent.postMessage(JSON.stringify(data), &#39;http://www.domain1.com&#39;);        }    }, false);&lt;/script&gt;</code></pre><h4 id="3、cors跨域资源共享"><a href="#3、cors跨域资源共享" class="headerlink" title="3、cors跨域资源共享"></a>3、cors跨域资源共享</h4><p>浏览器将cors请求分为了两类：简单请求，非简单请求。</p><p>简单请求: 在头信息中，增加一个origin字段，用于说明，本次请求来自哪个源，服务器根据这个值，决定是否同意此请求。</p><ol><li>HEAD</li><li>GET</li><li>POST<br>(content-type只限于三个值：<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>)</li></ol><p>如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。<br>浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。<br><strong>所以：请求是发送出去了的！返回之后浏览器处理后报错</strong></p><p>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p><pre><code>Access-Control-Allow-Origin: http://api.alipay.com  // 表示接受的域名Access-Control-Allow-Credentials: true // 是否允许发送cookieAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8</code></pre><p>非简单请求</p><p>预检请求：在正式通信前，会先请求查询当前域名是否在服务器许可名单内，以及使用哪些头信息等，在肯定答复后，才会正式发出请求，否则报错。<br>预检的请求方法是<code>OPTION</code></p><p>eg.<br>这个请求：</p><pre><code>var url = &#39;http://api.alipay.com/cors&#39;;var xhr = new XMLHttpRequest();xhr.open(&#39;PUT&#39;, url, true);xhr.setRequestHeader(&#39;X-Custom-Header&#39;, &#39;value&#39;);xhr.send();</code></pre><p>浏览器发现是非简单请求，所以会<code>预检</code><br>预检：</p><pre><code>OPTIONS /cors HTTP/1.1Origin: http://api.alipay.comAccess-Control-Request-Method: PUT // 因为是PUT，所以列出PUTAccess-Control-Request-Headers: X-Custom-Header // 指定浏览器CORS请求会额外发送的头信息字段Host: api.alice.com Accept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...</code></pre><p>预检的回应：<br>服务器收到”预检”请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应。</p><pre><code>HTTP/1.1 200 OKDate: Mon, 01 Dec 2020 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.alipay.com  // 表示接受的源Access-Control-Allow-Methods: GET, POST, PUT // 接受的方法Access-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain</code></pre><p>如果浏览器不接受，则返回一个正常回应，没有任何cors头信息，浏览器认定不同意预检请求，就报错了。</p><p><em>withCredentials</em><br>刚刚提到要发送cookie，除了浏览器同意，指定了<code>Access-Control-Allow-Credentials</code>字段外，前端的请求也需要开启<code>xhr.withCredentials = true</code></p><p>图示：</p><p><img src="/2020/05/11/2020/cors跨域/NO1.png" alt="NO1" title="NO1"></p><h4 id="4、代理型-nginx-node"><a href="#4、代理型-nginx-node" class="headerlink" title="4、代理型:nginx / node"></a>4、代理型:nginx / node</h4><ol><li><p>使用nginx做代理，把请求分发去服务器。</p><pre><code>#proxy服务器server { listen       8090; server_name  xxx; location / {     proxy_pass   xxx:8080;  #反向代理 }}</code></pre></li><li><p>node搭一个中转。</p></li></ol><h4 id="5、websocket"><a href="#5、websocket" class="headerlink" title="5、websocket"></a>5、websocket</h4><p>H5的新协议。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟生成虚拟3D轮播结构</title>
      <link href="/2020/03/30/2020/%E8%BD%AE%E6%92%AD/"/>
      <url>/2020/03/30/2020/%E8%BD%AE%E6%92%AD/</url>
      
        <content type="html"><![CDATA[<p><em>2020-07-03更新描述：回头再看，这个处理过程并不优雅🤒，写的也不好🤣，权当当时的思路记录吧</em></p><h4 id="仿造-CloudCarousel-3D轮播"><a href="#仿造-CloudCarousel-3D轮播" class="headerlink" title="仿造 CloudCarousel 3D轮播"></a>仿造 CloudCarousel 3D轮播</h4><p>先上效果图:<br><img src="/2020/03/30/2020/轮播/NO1.gif" alt="NO1" title="NO1"><br>（很是粗糙，还未做成通用型，未优化，先做记录下，以 <strong>8</strong> 图位为例子）</p><a id="more"></a><h5 id="首先我们需要将几个元素排列成圆"><a href="#首先我们需要将几个元素排列成圆" class="headerlink" title="# 首先我们需要将几个元素排列成圆"></a># <strong>首先我们需要将几个元素排列成圆</strong></h5><p>我们可以先计算 每一个元素之间间隔多少角度</p><pre><code>const distance = 360 / this.carouselData.length ;const itemdis = distance * Math.PI / 180;// 180° = Π * 弧度// =&gt; 弧度 = 180° / Π// 所以当我们知道了每一个所占的角度，就可以知道它 每两个间定长的弧度</code></pre><p><img src="/2020/03/30/2020/轮播/NO2.gif" alt="NO2" title="NO2"></p><p><strong>以 数组中每一位 数的 index 索引与 弧度相乘，结合 cos 、 sin 函数，我们就可以让他们围绕成为圆</strong></p><p>而半径则交给 <strong>radius</strong> 去决定</p><ul><li>Math.sin( (itemdis  <em> index) ) </em> radiusH + ‘px’</li><li>Math.cos( (itemdis <em> index) ) </em> radiusH + ‘px’</li></ul><p>所以第一步，我们可以在界面上画出：<br><img src="/2020/03/30/2020/轮播/NO3.png" alt="NO3" title="NO3"></p><p><strong>为什么它只有两个？</strong></p><p>这就是因为圆心我们并没有进行设置。</p><p>所以我们需要在上一步的基础上获取它的父容器的 宽高 作为中心点。（中心点可以自由去设置，此图为了完整展现，数据不完全。）</p><p><img src="/2020/03/30/2020/轮播/NO4.png" alt="NO4" title="NO4"></p><p>于是我们完成了第一步，将他们排列成<strong>圆</strong>。</p><h5 id="放扁，有立体感"><a href="#放扁，有立体感" class="headerlink" title="# 放扁，有立体感"></a># <strong>放扁，有立体感</strong></h5><p>第二步的操作其实并不麻烦，我们仅需要将他们 bottom 竖轴的半径进行压缩，他们随之就可以成为一个立体的椭圆了。<strong>靠想象</strong></p><p><img src="/2020/03/30/2020/轮播/NO5.png" alt="NO5" title="NO5"></p><h5 id="动起来"><a href="#动起来" class="headerlink" title="# 动起来"></a># <strong>动起来</strong></h5><p>起初想依靠 对 <strong>数据数组</strong> 进行 头部删除，尾部插入改变序列位置，从而达到动起来的效果。</p><pre><code>this.interval = setInterval(() =&gt; {    // 临界条件，单 0 索引的位置等于目标元素 的时候即停止。    if(this.carouselData[0][&#39;name&#39;] === item[&#39;name&#39;]) {        clearInterval(this.interval);    }    // 出 0号位置    unitItem = JSON.parse(JSON.stringify(this.carouselData[0]));    this.carouselData.splice(0, 1);    this.$nextTick(() =&gt; {        // 入 数组尾部        this.carouselData.push(unitItem);    })}, 500);</code></pre><pre><code>transition all .8s ease</code></pre><p><strong>跑题：</strong><br>transition 属性是一个简写属性，用于设置四个过渡属性：</p><ul><li>transition-property：<br>规定设置过渡效果的 CSS 属性的名称</li><li>transition-duration：<br>规定完成过渡效果需要多少秒或毫秒。</li><li>transition-timing-function：<br>规定速度效果的速度曲线。</li><li>transition-delay<br>定义过渡效果何时开始。</li></ul><p><strong>over</strong></p><p>这样的确可以有效针对中间元素的移动改变。但是每一次插入 数组尾部 的该元素来说，由于无法跟踪它插入前的位置，元素信息等等等。所以transition对它来说是无效的。<br>这就造成了下面（如图）的问题。</p><p><img src="/2020/03/30/2020/轮播/NO6.png" alt="NO6" title="NO6"></p><p>至少我们实现了第二步，动起来。</p><h5 id="更完美的动起来"><a href="#更完美的动起来" class="headerlink" title="# 更完美的动起来"></a># <strong>更完美的动起来</strong></h5><p>后来，一下想不着怎么办，就回家去想了。~ ~</p><p>后来，我想到的解决方式（事实上应该不止，我只能想到一种。。）</p><p><strong>我可以允许它数组以及每一位的索引位置等等不变，我可以动态计算，我应该在每一轮给它什么位置。即 我可以算给它，它在某一个时刻，应该在什么相对位置了。</strong></p><p><img src="/2020/03/30/2020/轮播/NO4.png" alt="NO7" title="NO7"></p><p><strong>解析：</strong><br>以数组及其索引为例子：(以 <strong>4图位</strong> 为例子)<br>索引位置：     [0]——–[1]——–[2]——–[3]</p><p>假设我点了 <strong>索引2</strong> 处的位置，那么 [2] 就应该来到 [0] 的位置，它所需要经历的路径有 [1]、[0]的这两个位置。</p><p>所以它需要遍历两次</p><hr><p>样式位置：     [0]——–[1]——–[2]——–[3]</p><hr><p>初始时候：     [0]——–[1]——–[2]——–[3]<br>   第一次：<br>一次结束：     [1]——–[2]——–[3]——–[0]<br>   第二次：<br>二次结束：     [2]——–[3]——–[0]——–[1]</p><hr><p>startIndex = 0; // 开始位置索引  0<br>step = 点击位置 - 开始索引 = &gt; 2 - 0 = 2; // 循环2次<br>iterStep = 1; 当前位移次数</p><hr><p>初始时候： [0]——–[1]——–[2]——–[3]</p><ul><li>第一次执行：</li></ul><p>length = 4;<br><strong>for(let i = 0 ; i &lt;= length - 1; i++)</strong><br>判断条件： i &lt; iterStep<br>[0]  |  0 &lt; 1  —&gt; [0]应该获得[3] 的样式 | length - iterStep + i  —&gt;  4 - 1 + 0 = 3;<br>[1]  |  1 !&lt; 1 —&gt; [1]应该获得[0] 的样式 | i - iterStep —&gt; 1 - 1 = 0;<br>[2]  |  2 !&lt; 1 —&gt; [2]应该获得[1] 的样式 | i - iterStep —&gt; 2 - 1 = 1;<br>[3]  |  3 !&lt; 1 —&gt; [3]应该获得[2] 的样式 | i - iterStep —&gt; 3 - 1 = 2;</p><p>获得样式对应 ：<br>[1]——–[2]——–[3]——–[0]</p><p>iterStep += 1; —&gt; iterStep = 2;<br>step -= 1; —&gt; step = 1;<br>step === 0 ？结束 ：继续；<br><strong>继续</strong></p><hr><ul><li>第二次执行：</li></ul><p>length = 4;<br><strong>for(let i = 0 ; i &lt;= length - 1; i++)</strong><br>判断条件： i &lt; iterStep<br>[0]  |  0 &lt; 2  —&gt; [0]应该获得[2] 的样式 | length - iterStep + i  —&gt;  4 - 2 + 0 = 2;<br>[1]  |  1 &lt; 2 —&gt; [1]应该获得[3] 的样式 | length - iterStep + i —&gt; 4 - 2 + 1 = 3;<br>[2]  |  2 !&lt; 2 —&gt; [2]应该获得[0] 的样式 | i - iterStep —&gt; 2 - 2 = 0;<br>[3]  |  3 !&lt; 2 —&gt; [3]应该获得[1] 的样式 | i - iterStep —&gt; 3 - 2 = 1;</p><p>获得样式对应 ：<br>[2]——–[3]——–[0]——–[1]</p><p>iterStep += 1; —&gt; iterStep = 3;<br>step -= 1; —&gt; step = 0;<br>step === 0 ？结束 ：继续；<br><strong>结束</strong></p><p>我们就可以先完善第一段代码：</p><pre><code>let oldIndex = this.nowFrontIndex; // 当前初索引Indexlet step = index - oldIndex; // 遍历次数let iterStep = 1; // 临界条件let length = arr.length;this.interval = setInterval(() =&gt; {    if (step === 0) {        this.nowFrontIndex = index; // 更新初始Index        clearInterval(this.interval);        this.interval = null;        return;    }    let result;    for(let i = 0; i &lt; length; i ++) {        if (i &lt; iterStep) {            result = this.transformAtCircle(length - iterStep + i);            this.$set(this.arr, i, result);        } else {            result = this.transformAtCircle(i - iterStep);            this.$set(this.arr, i, result);        }    }    iterStep += 1;    step -= 1;}, 400);</code></pre><h6 id="再一次点击"><a href="#再一次点击" class="headerlink" title="再一次点击"></a>再一次点击</h6><p>当前位置  [2]——–[3]——–[0]——–[1]</p><p>假设我点了 <strong>索引3</strong> 处的位置，那么 [3] 就应该来到 [0] 的位置，它所需要经历的路径有 [0]的这个位置。</p><p>所以它需要遍历一次</p><hr><p>样式位置：     [0]——–[1]——–[2]——–[3]</p><hr><p>初始时候：     [2]——–[3]——–[0]——–[1]<br>   第一次：<br>一次结束：     [3]——–[0]——–[1]——–[2]</p><hr><p>startIndex = 2; // 开始位置索引  2<br>step = 点击索引 - 开始索引 = &gt; 3 - 2 = 1; // 循环2次<br>iterStep = 1; 当前位移次数  关键！ </p><p><strong>oldIndex ? iterStep += oldIndex : iterStep</strong> —&gt; iterStep = 3;</p><p>如果因为此次点击是在存在了第一次点击的情况下，所以对于目前的索引位置其实已经偏移过了。</p><hr><p>初始时候： [2]——–[3]——–[0]——–[1]</p><ul><li>第一次执行：</li></ul><p>length = 4;<br><strong>for(let i = 0 ; i &lt;= length - 1; i++)</strong><br>判断条件： i &lt; iterStep<br>[0]  |  0 &lt; 3  —&gt; [0]应该获得[1] 的样式 | length - iterStep + i  —&gt;  4 - 3 + 0 = 1;<br>[1]  |  1 &lt; 3 —&gt; [1]应该获得[2] 的样式 | length - iterStep + i —&gt; 4 - 3 + 1 = 2;<br>[2]  |  2 &lt; 3 —&gt; [2]应该获得[3] 的样式 | length - iterStep + i —&gt; 4 - 3 + 2= 3;<br>[3]  |  3 !&lt; 3 —&gt; [3]应该获得[0] 的样式 | i - iterStep —&gt; 3 - 3 = 0;</p><p>获得样式对应 ：<br>[3]——–[0]——–[1]——–[2]</p><p>iterStep += 1; —&gt; iterStep = 4;;<br>step -= 1; —&gt; step = 0;<br>step === 0 ？结束 ：继续；<br><strong>结束</strong></p><p>所以我们再一次完善一下我们的代码</p><pre><code>let oldIndex = this.nowFrontIndex; // 当前初索引Indexlet step = index - oldIndex; // 遍历次数let iterStep = 1; // 临界条件let length = this.arr.length;++++++ if(oldIndex) {+     iterStep += oldIndex;+ }+++++this.interval = setInterval(() =&gt; {    if (step === 0) {        this.nowFrontIndex = index; // 更新初始Index        clearInterval(this.interval);        this.interval = null;        return;    }    let result;    for(let i = 0; i &lt; length; i ++) {        if (i &lt; iterStep) {            result = this.transformAtCircle( length - iterStep + i);            this.$set(this.arr, i, result);        } else {            result = this.transformAtCircle(i - iterStep);            this.$set(this.arr, i, result);        }    }    iterStep += 1;    step -= 1;}, 400);</code></pre><h6 id="再再一次点击"><a href="#再再一次点击" class="headerlink" title="再再一次点击"></a>再再一次点击</h6><p>当前位置  [3]——–[0]——–[1]——–[2]</p><p>假设我点了 <strong>索引1</strong> 处的位置，那么 [1] 就应该来到 [0] 的位置，它所需要经历的路径有 [0]，[1]的这个位置。</p><p>所以它需要遍历一次</p><hr><p>样式位置：     [0]——–[1]——–[2]——–[3]</p><hr><p>初始时候：     [3]——–[0]——–[1]——–[2]<br>   第一次：<br>一次结束：     [0]——–[1]——–[2]——–[3]<br>   第二次：<br>二次结束：     [1]——–[2]——–[3]——–[0]</p><hr><p>还记得我们的计算方式吗？我们快速走一遍。</p><p>startIndex = 3; // 开始位置索引  3<br>step = 点击索引 - 开始索引 = &gt; 1 - 3 = <strong>-2</strong> ； //  ？ ？ ？<br>iterStep = 1; 当前位移次数  关键！ </p><p><strong>oldIndex ? iterStep += oldIndex : iterStep</strong> —&gt; 1 + 3 = 4；;</p><ul><li>第一次执行</li></ul><p>length = 4;<br><strong>for(let i = 0 ; i &lt;= length - 1; i++)</strong><br>判断条件： i &lt; iterStep<br>[0]  |  0 &lt; 4  —&gt; [0]应该获得[0] 的样式 | length - iterStep + i  —&gt;  4 - 4 + 0 = 0;<br>[1]  |  1 &lt; 4 —&gt; [1]应该获得[1] 的样式 | length - iterStep + i —&gt; 4 - 4 + 1 = 1;<br>[2]  |  2 &lt; 4 —&gt; [2]应该获得[2] 的样式 | length - iterStep + i —&gt; 4 - 4 + 2 = 2;<br>[3]  |  3 &lt; 3 —&gt; [3]应该获得[3] 的样式 | length - iterStep + i —&gt; 4 - 4 + 3 = 3;</p><p>获得样式对应 ：<br>[0]——–[1]——–[2]——–[3]</p><p>iterStep += 1; —&gt; iterStep = 5;<br>step -= 1; —&gt; step = -3;<br>step === 0 ？结束 ：继续；<br><strong>继续</strong>【同时我们应该注意到，它将不会停止了！】</p><p>所以我们需要修改我们的循环次数了。</p><p>[3]——–[0]——–[1]——–[2]<br>当我们点击 [0]  —&gt; 0 - 3 = -3 —&gt; step = -3 — 实际循环 1 次<br>当我们点击 [1]  —&gt; 1 - 3 = -2 —&gt; step = -2 — 实际循环 2 次<br>当我们点击 [2]  —&gt; 2 - 3 = -1 —&gt; step = -1 — 实际循环 3 次<br>-3 + length —&gt; -3 + 4 = 1<br>-2 + length —&gt; -2 + 4 = 2<br>-1 + length —&gt; -1 + 4 = 3<br><strong>so</strong><br>我们需要更改完善一下我们的代码了：</p><pre><code>let oldIndex = this.nowFrontIndex; // 当前初索引Indexlet step = index - oldIndex; // 遍历次数let iterStep = 1; // 临界条件let length = this.arr.length;if(oldIndex) {   iterStep += oldIndex;}++++++ if (step &lt; 0) {+   step += length;+ }+++++this.interval = setInterval(() =&gt; {    if (step === 0) {        this.nowFrontIndex = index; // 更新初始Index        clearInterval(this.interval);        this.interval = null;        return;    }    let result;    for(let i = 0; i &lt; length; i ++) {        if (i &lt; iterStep) {            result = this.transformAtCircle( length - iterStep + i);            this.$set(this.arr, i, result);        } else {            result = this.transformAtCircle(i - iterStep);            this.$set(this.arr, i, result);        }    }    iterStep += 1;    step -= 1;}, 400);</code></pre><p>所以我们再重复一下以上点击，执行看看。</p><h6 id="再再再一次点击"><a href="#再再再一次点击" class="headerlink" title="再再再一次点击"></a>再再再一次点击</h6><p>当前位置  [3]——–[0]——–[1]——–[2]</p><p>假设我点了 <strong>索引1</strong> 处的位置，那么 [1] 就应该来到 [0] 的位置，它所需要经历的路径有 [0]，[1]的这个位置。</p><p>所以它需要遍历一次</p><hr><p>样式位置：     [0]——–[1]——–[2]——–[3]</p><hr><p>初始时候：     [3]——–[0]——–[1]——–[2]<br>   第一次：<br>一次结束：     [0]——–[1]——–[2]——–[3]<br>   第二次：<br>二次结束：     [1]——–[2]——–[3]——–[0]</p><hr><p>还记得我们的计算方式吗？我们快速走一遍。</p><p>startIndex = 3; // 开始位置索引  3<br>step = 点击索引 - 开始索引 = &gt; 1 - 3 = -2<br><strong>step &lt; 0 ? step += length : step</strong> —&gt; -2 + 4 = 2； step = 2;</p><p>iterStep = 1; 当前位移次数  关键！ </p><p><strong>oldIndex ? iterStep += oldIndex : iterStep</strong> —&gt; 1 + 3 = 4； iterStep = 4;</p><ul><li>第一次执行</li></ul><p>length = 4;<br><strong>for(let i = 0 ; i &lt;= length - 1; i++)</strong><br>判断条件： i &lt; iterStep<br>[0]  |  0 &lt; 4  —&gt; [0]应该获得[0] 的样式 | length - iterStep + i  —&gt;  4 - 4 + 0 = 0;<br>[1]  |  1 &lt; 4 —&gt; [1]应该获得[1] 的样式 | length - iterStep + i —&gt; 4 - 4 + 1 = 1;<br>[2]  |  2 &lt; 4 —&gt; [2]应该获得[2] 的样式 | length - iterStep + i —&gt; 4 - 4 + 2 = 2;<br>[3]  |  3 &lt; 4 —&gt; [3]应该获得[3] 的样式 | length - iterStep + i —&gt; 4 - 4 + 3 = 3;</p><p>获得样式对应 ：<br>[0]——–[1]——–[2]——–[3]</p><p>iterStep += 1; —&gt; iterStep = 5;<br>step -= 1; —&gt; step = 1;<br>step === 0 ？结束 ：继续；<br><strong>继续</strong></p><ul><li>第二次执行</li></ul><p>length = 4;<br><strong>for(let i = 0 ; i &lt;= length - 1; i++)</strong><br>判断条件： i &lt; iterStep<br>[0]  |  0 &lt; 5  —&gt; [0]应该获得[3] 的样式 | length - iterStep + i  —&gt;  4 - 5 + 0 = -1;  —  ？ ？ ？<br>[1]  |  1 &lt; 5 —&gt; [1]应该获得[0] 的样式 | length - iterStep + i —&gt; 4 - 5 + 1 = 0;<br>[2]  |  2 &lt; 5 —&gt; [2]应该获得[1] 的样式 | length - iterStep + i —&gt; 4 - 5 + 2 = 1;<br>[3]  |  3 &lt; 5 —&gt; [3]应该获得[2] 的样式 | length - iterStep + i —&gt; 4 - 5 + 3 = 2;</p><p>获得样式对应 ：<br>[1]——–[2]——–[3]——–[0 // <strong>-1</strong> ？？？]</p><p>iterStep += 1; —&gt; iterStep = 6;<br>step -= 1; —&gt; step = 0;<br>step === 0 ？结束 ：继续；<br><strong>结束</strong><br>我们可以注意到 -1 位置 ? 那 0 的样式就完全错了。后续也肯定会全错！<br>那问题就在我们的判断分支上了。</p><p>即使存在上一轮的 iterStep, 也不应该持续不断的 + oldIndex 或者 + 1 下去。<br>但它轮转了length 长度的圈度之后，它应该重新从 “0”开始计数。</p><p>也就是 iterStep &gt; length 的时候，它应该 <strong>iterStep - length</strong>;</p><p>所以我们再再一次改变我们的代码</p><pre><code>let oldIndex = this.nowFrontIndex; // 当前初索引Indexlet step = index - oldIndex; // 遍历次数let iterStep = 1; // 临界条件let length = this.arr.length;if(oldIndex) {   iterStep += oldIndex;}if (step &lt; 0) {   step += length;}this.interval = setInterval(() =&gt; {    if (step === 0) {        this.nowFrontIndex = index; // 更新初始Index        clearInterval(this.interval);        this.interval = null;        return;    }    let result;    for(let i = 0; i &lt; length; i ++) {        +++++        + if (iterStep &gt; length) {        +    iterStep -= length;        + }        +++++        if (i &lt; iterStep) {            result = this.transformAtCircle( length - iterStep + i);            this.$set(this.arr, i, result);        } else {            result = this.transformAtCircle(i - iterStep);            this.$set(this.arr, i, result);        }    }    iterStep += 1;    step -= 1;}, 400);</code></pre><h6 id="再再再再一次点击"><a href="#再再再再一次点击" class="headerlink" title="再再再再一次点击"></a>再再再再一次点击</h6><p>当前位置  [3]——–[0]——–[1]——–[2]</p><p>假设我点了 <strong>索引1</strong> 处的位置，那么 [1] 就应该来到 [0] 的位置，它所需要经历的路径有 [0]，[1]的这个位置。</p><p>所以它需要遍历一次</p><hr><p>样式位置：     [0]——–[1]——–[2]——–[3]</p><hr><p>初始时候：     [3]——–[0]——–[1]——–[2]<br>   第一次：<br>一次结束：     [0]——–[1]——–[2]——–[3]<br>   第二次：<br>二次结束：     [1]——–[2]——–[3]——–[0]</p><hr><p>还记得我们的计算方式吗？我们快速走一遍。</p><p>startIndex = 3; // 开始位置索引  3<br>step = 点击索引 - 开始索引 = &gt; 1 - 3 = -2<br><strong>step &lt; 0 ? step += length : step</strong> —&gt; -2 + 4 = 2； step = 2;</p><p>iterStep = 1; 当前位移次数  关键！ </p><p><strong>oldIndex ? iterStep += oldIndex : iterStep</strong> —&gt; 1 + 3 = 4； iterStep = 4;</p><ul><li>第一次执行</li></ul><p>length = 4;<br><strong>for(let i = 0 ; i &lt;= length - 1; i++)</strong></p><p><strong>iterStep &gt; length ? iterStep -= length : iterStep</strong> —&gt; iterStep = 4;</p><p>判断条件： i &lt; iterStep<br>[0]  |  0 &lt; 4  —&gt; [0]应该获得[0] 的样式 | length - iterStep + i  —&gt;  4 - 4 + 0 = 0;<br>[1]  |  1 &lt; 4 —&gt; [1]应该获得[1] 的样式 | length - iterStep + i —&gt; 4 - 4 + 1 = 1;<br>[2]  |  2 &lt; 4 —&gt; [2]应该获得[2] 的样式 | length - iterStep + i —&gt; 4 - 4 + 2 = 2;<br>[3]  |  3 &lt; 4 —&gt; [3]应该获得[3] 的样式 | length - iterStep + i —&gt; 4 - 4 + 3 = 3;</p><p>获得样式对应 ：<br>[0]——–[1]——–[2]——–[3]</p><p>iterStep += 1; —&gt; iterStep = 5;<br>step -= 1; —&gt; step = 1;<br>step === 0 ？结束 ：继续；<br><strong>继续</strong></p><ul><li>第二次执行</li></ul><p>length = 4;<br><strong>for(let i = 0 ; i &lt;= length - 1; i++)</strong></p><p><strong>iterStep &gt; length ? iterStep -= length : iterStep</strong> —&gt; iterStep = 5 &gt; 4 —&gt; 1;</p><p>判断条件： i &lt; iterStep<br>[0]  |  0 &lt; 1  —&gt; [0]应该获得[3] 的样式 | length - iterStep + i  —&gt;  4 - 1 + 0 = 3;<br>[1]  |  1 &lt; 1 —&gt; [1]应该获得[0] 的样式 | i - iterStep —&gt; 1 - 1 = 0；<br>[2]  |  2 &lt; 1 —&gt; [2]应该获得[1] 的样式 | i - iterStep —&gt; 2 - 1 = 1；<br>[3]  |  3 &lt; 1 —&gt; [3]应该获得[2] 的样式 | i - iterStep —&gt; 3 - 1 = 2；</p><p>获得样式对应 ：<br>[1]——–[2]——–[3]——–[0]</p><p>iterStep += 1; —&gt; iterStep = 2;<br>step -= 1; —&gt; step = 0;<br>step === 0 ？结束 ：继续；<br><strong>结束</strong></p><hr><p>这样就暂时完成单向的转轮。<br>还有双向循环的旋转，就不做介绍了。<br>贴代码。</p><h5 id="Over"><a href="#Over" class="headerlink" title="Over"></a>Over</h5><p>以 8 图 为例子</p><pre><code>if (this.interval) {        return ;    }    let oldIndex = this.nowFrontIndex; // 当前初索引Index    let midIndex,        isRight = false; // middleIndex    if (oldIndex &gt; 3) {        midIndex = oldIndex - 4;    } else {        midIndex = oldIndex + 4;    }    isRight = this.computedIsRightPart(midIndex, index, oldIndex); // 左右    let step = index - oldIndex; // 遍历次数    if (step &lt; 0) {        step = 8 + step;    }    if (isRight) {        step = oldIndex - index;        if (step &lt; 0) {            step = 8 + step        }    }    let iterStep = 1; // 临界条件    if (oldIndex) {        if (!isRight) {            iterStep += oldIndex;        }    }    this.interval = setInterval(() =&gt; {        if (step === 0) {            this.nowFrontIndex = index; // 更新初始Index            clearInterval(this.interval);            this.interval = null;            return;        }        let result;        for(let i = 0; i &lt;= 7; i ++) {            if (isRight) {                if (i &lt; oldIndex) {                    let key = 8 - oldIndex;                    if ((key + i + iterStep) &lt; 8) {                        result = this.transformAtCircle(key + i + iterStep);                        this.$set(this.computedCarouselLoca, i, result);                    } else {                        result = this.transformAtCircle((key + i + iterStep) - 8);                        this.$set(this.computedCarouselLoca, i, result);                    }                } else {                    if ((i - oldIndex + iterStep) &lt; 8) {                        result = this.transformAtCircle(i - oldIndex + iterStep);                        this.$set(this.computedCarouselLoca, i, result);                    } else {                        result = this.transformAtCircle(i - oldIndex + iterStep - 8);                        this.$set(this.computedCarouselLoca, i, result);                    }                }            } else {                if (iterStep &gt;= 9) {                    iterStep = iterStep - 8;                }                 if (i &lt; iterStep) {                    // let key = 8 - iterStep + i;                    // if (key &lt; 0) {                    //     key = iterStep - 9                    // }                    result = this.transformAtCircle(8 - iterStep + i);                    this.$set(this.computedCarouselLoca, i, result);                } else {                    result = this.transformAtCircle(i - iterStep);                    this.$set(this.computedCarouselLoca, i, result);                }            }        }        iterStep += 1;        step -= 1;    }, 400);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>adv</title>
      <link href="/2020/02/15/2020/adv/"/>
      <url>/2020/02/15/2020/adv/</url>
      
        <content type="html"><![CDATA[<h6 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h6><p>2020开年就遭遇了疫情，来势汹汹，武汉加油🙏</p><p>本该回去上班的大家，都改成了远程办公，合着实际的业务工作也没有下发多少，就在假期把小组任务做了，尝试封装一些组内的通用组件。</p><p>分别由<code>input</code>、<code>select</code>、<code>button</code>、<code>time</code>、<code>Date</code>、<code>Tab</code>。<br>样式有一些是模仿了<code>Element</code>的组件样式，并且在遇到内部的一些逻辑不太明了的时候，可以通过查看Element的相关组件源码从而进行解决了。</p><p>话不多说，先上效果图…</p><a id="more"></a><h6 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h6><p><img src="/2020/02/15/2020/adv/NO1.gif" alt="NO1" title="NO1"></p><h6 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h6><p><img src="/2020/02/15/2020/adv/NO2.gif" alt="NO2" title="NO2"></p><h6 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h6><p><img src="/2020/02/15/2020/adv/NO3.gif" alt="NO3" title="NO3"></p><h6 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h6><p><img src="/2020/02/15/2020/adv/NO4.gif" alt="NO4" title="NO4"></p><h6 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h6><p><img src="/2020/02/15/2020/adv/NO5.gif" alt="NO5" title="NO5"></p><h6 id="Tabs"><a href="#Tabs" class="headerlink" title="Tabs"></a>Tabs</h6><p><img src="/2020/02/15/2020/adv/NO6.gif" alt="NO6" title="NO6"></p><h6 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h6><p>其实封装一些通用组件对整一个结构路径的学习把握，比多看一些源码的作用和影响相对来说也大一些。<br>内部有很多的事件，逻辑其实也没有考量的很清楚，毕竟也是不到一个月内完成的内容，如果要优化和改进，可以修改的地方其实还有很多。<br>但是也是这个过程学习到了很多，例如再次模仿<code>Element</code>重新写了一些适用的失焦指令，日期时间面板的计算函数、周数的计算函数等等等…<br>这些都是很有趣的知识点，一下子的总结还有很多，接下来会慢慢介绍这些内容：</p><p><em>未完待续…</em></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
            <tag> Adv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重绘回流</title>
      <link href="/2020/02/03/2020/%E9%87%8D%E7%BB%98%E5%9B%9E%E6%B5%81/"/>
      <url>/2020/02/03/2020/%E9%87%8D%E7%BB%98%E5%9B%9E%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h4 id="重绘（repaint）"><a href="#重绘（repaint）" class="headerlink" title="重绘（repaint）"></a>重绘（repaint）</h4><p>由于节点的几何属性发生了改变或者由于样式发生改变而不影响布局的，称为重绘，例如outline，visibility，color，background-color。</p><h4 id="回流（reflow）"><a href="#回流（reflow）" class="headerlink" title="回流（reflow）"></a>回流（reflow）</h4><p>回流是布局或者几何属性需要改变就称为回流，回流是影响浏览器性能的关键因素，因为回流设计涉及到部分页面、或者整个页面的布局更新，一个元素的回流会导致其所有子元素以及DOM紧随其后的节电等元素的回流。</p><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p>回流会引发重绘，重绘不一定会引起回流。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul><li><code>offsetTop</code>、<code>offsetLeft</code>、<code>offsetWidth</code>、<code>offsetHeight</code></li><li><code>scrollTop</code>、<code>scrollLeft</code>、<code>scrollWidth</code>、<code>scrollHeight</code></li><li><code>clientTop</code>、<code>clientLeft</code>、<code>clientWidth</code>、<code>clientHeight</code></li><li><code>width</code>、<code>height</code></li><li><code>getComputedStyle</code></li></ul><p>这些属性，均会引起强制渲染刷新队列。</p><h4 id="减少重绘与回流"><a href="#减少重绘与回流" class="headerlink" title="减少重绘与回流"></a>减少重绘与回流</h4><h5 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h5><ol><li>使用transform代替top；</li><li>使用visibility代替display: none，前者重绘，后者回流；</li><li>避免使用table布局；</li><li>尽可能再DOM树最末端改变class；</li><li>避免多层内联样式<pre><code>span { color: red;}div &gt; a &gt; span { color: red;}</code></pre></li><li>将动画效果应用到position为absolute或者fixed的元素上，避免影响其他元素布局；</li></ol><h5 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h5><ol><li>避免频繁操作样式，最好一次性写style，不要分开很多个，或者一次性更改class；</li><li>避免频繁操作DOM；</li><li>避免频繁读取会引起重绘、回流的属性；</li><li>有负责动画的元素使用绝对定位，脱离文档流，否则引起父元素及后续元素的频繁回流。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> CSS </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue的Keep-alive组件</title>
      <link href="/2020/01/27/2020/Vue%E7%9A%84Keep-alive/"/>
      <url>/2020/01/27/2020/Vue%E7%9A%84Keep-alive/</url>
      
        <content type="html"><![CDATA[<p><code>keep-alive</code>是<code>vue</code>的内置组件，在组件切换过程中可以将状态保留在内存里，防止重复渲染，<code>keep-alive</code>可以设置以下属性：</p><ul><li>include</li><li>exclude</li><li>max</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><code>LRU缓存</code>，源码：<em>src/core/components/keep-alive.js</em>。</p><p><code>LRU缓存</code>，源码：<em>src/core/components/keep-alive.js</em>。</p><p>这个的应用及讲解有很多，leetCode上也有相关的题目。<br>简单的说就是简历了一个特殊队列，及时更新过久未使用或者新使用的对象。</p><p>源码</p><pre><code>export default {  name: &#39;keep-alive&#39;,  abstract: true,  props: {    include: [String, RegExp, Array],    exclude: [String, RegExp, Array],    max: [String, Number]  },  created () {    this.cache = Object.create(null)    this.keys = []  },  destroyed () {    for (const key in this.cache) {      pruneCacheEntry(this.cache, key, this.keys)    }  },  mounted () {    this.$watch(&#39;include&#39;, val =&gt; {      pruneCache(this, name =&gt; matches(val, name))    })    this.$watch(&#39;exclude&#39;, val =&gt; {      pruneCache(this, name =&gt; !matches(val, name))    })  },  render() {    /* 获取默认插槽中的第一个组件节点 */    const slot = this.$slots.default    const vnode = getFirstComponentChild(slot)    /* 获取该组件节点的componentOptions */    const componentOptions = vnode &amp;&amp; vnode.componentOptions    if (componentOptions) {      /* 获取该组件节点的名称，优先获取组件的name字段，如果name不存在则获取组件的tag */      const name = getComponentName(componentOptions)      const { include, exclude } = this      /* 如果name不在inlcude中或者存在于exlude中则表示不缓存，直接返回vnode */      if (        (include &amp;&amp; (!name || !matches(include, name))) ||        // excluded        (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))      ) {        return vnode      }      const { cache, keys } = this      /* 获取组件的key值 */      const key = vnode.key == null        // same constructor may get registered as different local components        // so cid alone is not enough (#3269)        ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : &#39;&#39;)        : vnode.key     /*  拿到key值后去this.cache对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存 */      if (cache[key]) {        vnode.componentInstance = cache[key].componentInstance        // make current key freshest        remove(keys, key)        keys.push(key)      }        /* 如果没有命中缓存，则将其设置进缓存 */        else {        cache[key] = vnode        keys.push(key)        // prune oldest entry        /* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */        if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) {          pruneCacheEntry(cache, keys[0], keys, this._vnode)        }      }      vnode.data.keepAlive = true    }    return vnode || (slot &amp;&amp; slot[0])  }}</code></pre><p><code>cache</code>作为存储的对象:</p><pre><code>this.cache = {    &#39;key1&#39;:&#39;组件1&#39;,    &#39;key2&#39;:&#39;组件2&#39;,    // ...}</code></pre><p><code>key</code>的获取：</p><pre><code>const key = vnode.key == null? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : &#39;&#39;): vnode.key</code></pre><p>如果命中缓存</p><pre><code>if (cache[key]) {    vnode.componentInstance = cache[key].componentInstance    /* 调整该组件key的顺序，将其从原来的地方删掉并重新放在最后一个 */    remove(keys, key)    keys.push(key)} </code></pre><p>如果没有命中</p><pre><code>else {    cache[key] = vnode    keys.push(key)    /* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */    if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) {        pruneCacheEntry(cache, keys[0], keys, this._vnode)    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue的nextTick剖析</title>
      <link href="/2020/01/23/2020/Vue%E7%9A%84nextTick%E5%89%96%E6%9E%90/"/>
      <url>/2020/01/23/2020/Vue%E7%9A%84nextTick%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>对于<code>Vue</code>的<code>nextTick</code>，其中需要了解一下JS运行机制，包括不限于事件队列，宏任务，微任务等…</p><h2 id="先附上next-tick-js"><a href="#先附上next-tick-js" class="headerlink" title="先附上next-tick.js"></a>先附上next-tick.js</h2><pre><code>/* @flow *//* globals MutationObserver */import { noop } from &#39;shared/util&#39;import { handleError } from &#39;./error&#39;import { isIE, isIOS, isNative } from &#39;./env&#39;export let isUsingMicroTask = falseconst callbacks = []let pending = falsefunction flushCallbacks () {  pending = false  const copies = callbacks.slice(0)  callbacks.length = 0  for (let i = 0; i &lt; copies.length; i++) {    copies[i]()  }}// Here we have async deferring wrappers using microtasks.// In 2.5 we used (macro) tasks (in combination with microtasks).// However, it has subtle problems when state is changed right before repaint// (e.g. #6813, out-in transitions).// Also, using (macro) tasks in event handler would cause some weird behaviors// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).// So we now use microtasks everywhere, again.// A major drawback of this tradeoff is that there are some scenarios// where microtasks have too high a priority and fire in between supposedly// sequential events (e.g. #4521, #6690, which have workarounds)// or even between bubbling of the same event (#6566).let timerFunc// The nextTick behavior leverages the microtask queue, which can be accessed// via either native Promise.then or MutationObserver.// MutationObserver has wider support, however it is seriously bugged in// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It// completely stops working after triggering a few times... so, if native// Promise is available, we will use it:/* istanbul ignore next, $flow-disable-line */if (typeof Promise !== &#39;undefined&#39; &amp;&amp; isNative(Promise)) {  const p = Promise.resolve()  timerFunc = () =&gt; {    p.then(flushCallbacks)    // In problematic UIWebViews, Promise.then doesn&#39;t completely break, but    // it can get stuck in a weird state where callbacks are pushed into the    // microtask queue but the queue isn&#39;t being flushed, until the browser    // needs to do some other work, e.g. handle a timer. Therefore we can    // &quot;force&quot; the microtask queue to be flushed by adding an empty timer.    if (isIOS) setTimeout(noop)  }  isUsingMicroTask = true} else if (!isIE &amp;&amp; typeof MutationObserver !== &#39;undefined&#39; &amp;&amp; (  isNative(MutationObserver) ||  // PhantomJS and iOS 7.x  MutationObserver.toString() === &#39;[object MutationObserverConstructor]&#39;)) {  // Use MutationObserver where native Promise is not available,  // e.g. PhantomJS, iOS7, Android 4.4  // (#6466 MutationObserver is unreliable in IE11)  let counter = 1  const observer = new MutationObserver(flushCallbacks)  const textNode = document.createTextNode(String(counter))  observer.observe(textNode, {    characterData: true  })  timerFunc = () =&gt; {    counter = (counter + 1) % 2    textNode.data = String(counter)  }  isUsingMicroTask = true} else if (typeof setImmediate !== &#39;undefined&#39; &amp;&amp; isNative(setImmediate)) {  // Fallback to setImmediate.  // Technically it leverages the (macro) task queue,  // but it is still a better choice than setTimeout.  timerFunc = () =&gt; {    setImmediate(flushCallbacks)  }} else {  // Fallback to setTimeout.  timerFunc = () =&gt; {    setTimeout(flushCallbacks, 0)  }}export function nextTick (cb?: Function, ctx?: Object) {  let _resolve  callbacks.push(() =&gt; {    if (cb) {      try {        cb.call(ctx)      } catch (e) {        handleError(e, ctx, &#39;nextTick&#39;)      }    } else if (_resolve) {      _resolve(ctx)    }  })  if (!pending) {    pending = true    timerFunc()  }  // $flow-disable-line  if (!cb &amp;&amp; typeof Promise !== &#39;undefined&#39;) {    return new Promise(resolve =&gt; {      _resolve = resolve    })  }}</code></pre><h2 id="逐部分解析"><a href="#逐部分解析" class="headerlink" title="逐部分解析"></a>逐部分解析</h2><pre><code>function flushCallbacks () {   pending = false  const copies = callbacks.slice(0)  callbacks.length = 0  for (let i = 0; i &lt; copies.length; i++) {    copies[i]()  }}</code></pre><p>执行函数<code>flushCallbacks</code>，再其中，对推入<code>callbacks</code>保存的函数，进行遍历与执行，并且通过修改<code>.length</code>清空函数队列。</p><pre><code>let timerFuncif (typeof Promise !== &#39;undefined&#39; &amp;&amp; isNative(Promise)) {  const p = Promise.resolve()  timerFunc = () =&gt; {    p.then(flushCallbacks)    if (isIOS) setTimeout(noop)  }  isUsingMicroTask = true} else if (!isIE &amp;&amp; typeof MutationObserver !== &#39;undefined&#39; &amp;&amp; (  isNative(MutationObserver)  MutationObserver.toString() === &#39;[object MutationObserverConstructor]&#39;)) {  let counter = 1  const observer = new MutationObserver(flushCallbacks)  const textNode = document.createTextNode(String(counter))  observer.observe(textNode, {    characterData: true  })  timerFunc = () =&gt; {    counter = (counter + 1) % 2    textNode.data = String(counter)  }  isUsingMicroTask = true} else if (typeof setImmediate !== &#39;undefined&#39; &amp;&amp; isNative(setImmediate)) {  // Fallback to setImmediate.  // Techinically it leverages the (macro) task queue,  // but it is still a better choice than setTimeout.  timerFunc = () =&gt; {    setImmediate(flushCallbacks)  }} else {  // Fallback to setTimeout.  timerFunc = () =&gt; {    setTimeout(flushCallbacks, 0)  }}</code></pre><p><code>timerFunc</code>后续将定义的任务类型</p><ol><li><p>首先判断了运行是否支持<code>Promise</code>，支持<code>Promise</code>微任务，则<code>timerFunc</code>将使用为<code>Promise.then</code>微任务中执行；</p></li><li><p>若不支持则再判断非IE情况下，并且支持<code>MutationObserver</code>，则将使用此；<br><em>MutationObserverAPI可以看作一个监听DOM所有变化（包含节点、属性、文本内容的变动）的接口，MutationObserver的回调函数会进入微任务队列</em><br>👉：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" target="_blank" rel="noopener">MDN-MutationObserver知识</a></p></li><li><p>若以上都不支持，则再判断是否支持<code>setImmediate</code>；<br><em>仅IE10中及NodeJS中</em><br><em>此方法用于中断长时间运行的操作并在浏览器完成其他操作（例如事件和显示更新）后立即运行回调函数，技术上利用了宏任务</em><br>👉：<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/setImmediate" target="_blank" rel="noopener">MDN-setImmediate知识</a></p></li><li><p>最后的最后，若都不行，则降级为使用<code>setTimeout</code>；</p></li></ol><pre><code>export function nextTick (cb?: Function, ctx?: Object) {  let _resolve  callbacks.push(() =&gt; {    if (cb) {      try {        cb.call(ctx)      } catch (e) {        handleError(e, ctx, &#39;nextTick&#39;)      }    } else if (_resolve) {      _resolve(ctx)    }  })  if (!pending) {    pending = true    timerFunc()  }  if (!cb &amp;&amp; typeof Promise !== &#39;undefined&#39;) {    return new Promise(resolve =&gt; {      _resolve = resolve    })  }}</code></pre><ol><li><code>next-tick</code>方法中暴露的<code>nextTick</code>，其中向callbascks中推入回调函数，使用<code>callbacks</code>是因为，多个回调函数可以在一个<code>tick</code>内执行，而不用来一个执行一个。</li><li>然后就执行<code>timerFunc</code>…</li><li>如果没有<code>cb</code>回调函数，则return一个<code>Promise</code>，原因是<code>nextTick</code>还可以这样使用…<pre><code>this.$nextTick().then(() =&gt; { console.log(&#39;Jayant&#39;);})</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue虚拟节点VNodeDiff算法</title>
      <link href="/2020/01/17/2020/Vue-Diff/"/>
      <url>/2020/01/17/2020/Vue-Diff/</url>
      
        <content type="html"><![CDATA[<p>大部分内容引用自此博客：<a href="http://hcysun.me/vue-design/zh/renderer-diff.html" target="_blank" rel="noopener">vue-design</a>， 内容更全面和易懂，推荐大家看原文。</p><h5 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h5><p><strong>什么是虚拟DOM？：</strong></p><p>在内部的计算中，使用JS对象来描述并记录下一个DOM节点，这个就是虚拟DOM</p><a id="more"></a><p><img src="/2020/01/17/2020/Vue-Diff/NO1.png" alt="NO1" title="NO1"><br><img src="/2020/01/17/2020/Vue-Diff/NO2.png" alt="NO2" title="NO2"></p><p><strong>VDOM的优势在哪里？</strong></p><ol><li>虚拟DOM不会立马进行排版及重绘；</li><li>虚拟DOM频繁修改，然后一次性比较，最终在真实的DOM中进行排版与重绘，减少这个过程；</li><li>虚拟DOM有效降低大面积真实DOM的重绘，可以只进行局部的渲染。</li></ol><p><strong>起因：</strong><br><em>浏览器DOM树太多庞杂，具备的属性十分复杂，更新渲染所耗费的性能多、大。</em></p><p><strong>实际上的的作用？：</strong><br><img src="/2020/01/17/2020/Vue-Diff/NO3.png" alt="NO3" title="NO3"></p><p><strong>VDOM定义的位置：</strong><br><em>src/core/vdom/vnode.js   是一个构造函数</em></p><pre><code>// 定义了VNodeexport default class VNode {  tag: string | void; /** 最终得vnode标签属性 */  data: VNodeData | void; /** 包含最终节点上的style class attr */  children: ?Array&lt;VNode&gt;; /** 子节点 */  text: string | void; /** 文本属性 */  elm: Node | void; /** 对应得真是dom */  ns: string | void;  context: Component | void; // rendered in this component&#39;s scope  key: string | number | void; /** key值， diff时可以提高效率， 具体入v-for时 需要声明 :key */  componentOptions: VNodeComponentOptions | void;  componentInstance: Component | void; // component instance  parent: VNode | void; // component placeholder node  // strictly internal  raw: boolean; // contains raw HTML? (server only)  isStatic: boolean; // hoisted static node  isRootInsert: boolean; // necessary for enter transition check  isComment: boolean; // empty comment placeholder?  isCloned: boolean; // is a cloned node?  isOnce: boolean; // is a v-once node?  asyncFactory: Function | void; // async component factory function  asyncMeta: Object | void;  isAsyncPlaceholder: boolean;  ssrContext: Object | void;  fnContext: Component | void; // real context vm for functional nodes  fnOptions: ?ComponentOptions; // for SSR caching  devtoolsMeta: ?Object; // used to store functional render context for devtools  fnScopeId: ?string; // functional scope id support  constructor (    tag?: string,    data?: VNodeData,    children?: ?Array&lt;VNode&gt;,    text?: string,    elm?: Node,    context?: Component,    componentOptions?: VNodeComponentOptions,    asyncFactory?: Function  ) {    this.tag = tag    this.data = data    this.children = children    this.text = text    this.elm = elm    this.ns = undefined    this.context = context    this.fnContext = undefined    this.fnOptions = undefined    this.fnScopeId = undefined    this.key = data &amp;&amp; data.key    this.componentOptions = componentOptions    this.componentInstance = undefined    this.parent = undefined    this.raw = false    this.isStatic = false    this.isRootInsert = true    this.isComment = false    this.isCloned = false    this.isOnce = false    this.asyncFactory = asyncFactory    this.asyncMeta = undefined    this.isAsyncPlaceholder = false  }  // DEPRECATED: alias for componentInstance for backwards compat.  /* istanbul ignore next */  get child (): Component | void {    return this.componentInstance  }}</code></pre><p><strong>那我们要定义多少种类型的VNODE呢？</strong></p><ul><li>注释节点</li><li>文本节点</li><li>元素节点</li><li>组件节点</li><li>函数式组件节点</li><li>克隆节点</li></ul><p><em>前边的基本就是读取一个DOM元素之后，去拆解去组装成一个相对应DOM的VNODE元素，再回头看看这个虚拟DOM全程，最麻烦的地方在哪里呢？</em></p><p><strong>而VNODE更新的这个过程？</strong><br><em>DOM-Diff、patch：</em> 打补丁</p><p>简而言之，就是对旧的VNODE根据新的VNODE进行修补的这么一个过程，使得最终新旧VNODE保持一致。<strong>以newVNODE为基准，改造oldVNODE，这就是patch干的事，当然的前提是相同类型的VNODE才有对比的意义。</strong></p><p><strong>当新旧的VNODE类型不同时：</strong>调用一些replace将新的Vnode替换了旧Vnode。</p><p><strong>更新标签元素的基本规则，更新相同标签的VNode时：</strong>例如都为div</p><pre><code>// 旧的 VNodeconst prevVNode = h(&#39;div&#39;, {  style: {    width: &#39;100px&#39;,    height: &#39;100px&#39;,    backgroundColor: &#39;red&#39;  }})// 新的 VNodeconst nextVNode = h(&#39;div&#39;, {  style: {    width: &#39;100px&#39;,    height: &#39;100px&#39;,    border: &#39;1px solid green&#39;  }})</code></pre><ul><li>第 1 步：当新的 VNodeData 存在时，遍历新的 VNodeData。</li><li>第 2 步：根据新 VNodeData 中的 key，分别尝试读取旧值和新值，即 prevValue 和 nextValue。</li><li>第 3 步：使用 switch…case 语句匹配不同的数据进行不同的更新操作</li></ul><p><strong>更新完VNode后，其下更新子节点：</strong></p><p><img src="/2020/01/17/2020/Vue-Diff/NO4.png" alt="NO4" title="NO4"></p><p><strong>3 x 3 种组合</strong></p><ul><li>一、新旧节点都是单子节点，那我们对比他们替换不同即可<pre><code>patch()</code></pre></li><li>二、旧节点一个子节点，新节点无子节点，我们将旧节点子节点移除即可<pre><code>removeChild()</code></pre></li><li>三、旧节点有一个子节点，新节点有多个子节点的情况，我们可以移除旧节点子节点，再将新节点子节点遍历挂载上去。</li></ul><p><img src="/2020/01/17/2020/Vue-Diff/NO5.png" alt="NO5" title="NO5"></p><ul><li>四、五、六、当旧节点没有子节点的时候，新节点有一个子节点，或者多个子节点，那么依次挂载上去即可，若新节点没有子节点，那就什么都不用做了。</li><li>七、当旧节点有多个子节点的时候，新节点只有一个子节点，那么删了旧节点的所有子节点，挂载上新节点的那一个子节点。</li><li>八、当旧节点有多个子节点的时候，新节点没有子节点，那么删空旧节点的所有子节点即可。</li><li>九、当旧节点有多个子节点时候，新节点也有多个子节点的时候，就是核心的Diff对比</li></ul><p><strong>对于两多的情况，大家能想到用什么形式进行DOM的更新呢？</strong><br><strong>全部删除？再全部增加</strong></p><h6 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h6><p>新旧DOM的内部节点庞杂且复杂，所以核心的Diff是居于同层级间的比较，即是 oldVnode中有多个子节点，newVnode有多个子节点的情况</p><p><img src="/2020/01/17/2020/Vue-Diff/NO6.png" alt="NO6" title="NO6"></p><p>我们再VNode的el中挂载了DOM元素</p><p><img src="/2020/01/17/2020/Vue-Diff/NO7.png" alt="NO7" title="NO7"></p><p>如果标签什么的相同，我们用之前列举的集中patch即可进行比较。</p><p><img src="/2020/01/17/2020/Vue-Diff/NO8.png" alt="NO8" title="NO8"></p><p><img src="/2020/01/17/2020/Vue-Diff/NO9.png" alt="NO9" title="NO9"></p><p>如果新的VNode列表相较于旧的VNode是长的，那么最后的节点我们依然要创建节点，旧的VNode节点相较于新的VNode节点是短的，那么我们最后要删除销毁多余的DOM节点。</p><h6 id="key的作用"><a href="#key的作用" class="headerlink" title="key的作用"></a>key的作用</h6><pre><code>假设 第三个参数是key标识// 旧[  h(&#39;li&#39;, null, 1),  h(&#39;li&#39;, null, 2),  h(&#39;li&#39;, null, 3)]// 新[  h(&#39;li&#39;, null, 3),  h(&#39;li&#39;, null, 1),  h(&#39;li&#39;, null, 2)]</code></pre><p>如果我们按照之前的对比。</p><pre><code>h(&#39;li&#39;, null, 1)// vsh(&#39;li&#39;, null, 3)</code></pre><p>毫无疑问我们可能三次对比中都会去执行一下对比方法，但是根据我们直接观察，我们是可以通过移动他们的顺序从而达到更新DOM的效果的。</p><p>为了方便通过key进行对比的过程，我们在创建VNode的时候还需要保留对它的key的记录。</p><p><img src="/2020/01/17/2020/Vue-Diff/NO10.png" alt="NO10" title="NO10"></p><p><strong>我们通过key知道了他们之间的映射关系</strong>，我们只需要遍历新的children中的每一个节点，去旧的children中寻找是否有相同的key值节点即可。</p><pre><code>// 遍历新的 childrenfor (let i = 0; i &lt; nextChildren.length; i++) {  const nextVNode = nextChildren[i]  let j = 0  // 遍历旧的 children  for (j; j &lt; prevChildren.length; j++) {    const prevVNode = prevChildren[j]    // 如果找到了具有相同 key 值的两个节点，则调用 `patch` 函数更    if (nextVNode.key === prevVNode.key) {      patch(prevVNode, nextVNode, container)      break     }  }}</code></pre><p><strong>用key标记后又怎么找到需要移动的节点呢？</strong></p><p><img src="/2020/01/17/2020/Vue-Diff/NO11.png" alt="NO11" title="NO11"></p><p>我们对新的Vnode节点进行遍历，去旧节点找寻所在的索引位置，例如：我们在新节点中找到li-a，发现在旧节点中所对应的索引是0，依次类推，最后的索引就是0-1-2。<br>这个索引对我们有什么帮助呢？<br><strong>这是一个递增的顺序，这说明如果在寻找的过程中遇到的索引呈现递增趋势，则说明新旧 children 中节点顺序相同，不需要移动操作。相反的，如果在寻找的过程中遇到的索引值不呈现递增趋势，则说明需要移动操作</strong></p><p><img src="/2020/01/17/2020/Vue-Diff/NO12.png" alt="NO12" title="NO12"></p><p>按照这个例子，我们最终找出来的索引是2-0-1</p><p>我们一开始找到的索引是2，而后是0，我们遇到了比2小的索引数，打破了递增的规律，我们此时知道了，在旧的Vnode中，li-c所处的位置是比li-a要靠后的，我们即 得出 li-a如果要更新在新的VNode中，它需要后移，<strong>并以li-c做最大索引参照物</strong></p><h6 id="移动节点"><a href="#移动节点" class="headerlink" title="移动节点"></a>移动节点</h6><p>新的节点在经过对比后也将拥有对真实DOM的引用</p><p><img src="/2020/01/17/2020/Vue-Diff/NO13.png" alt="NO13" title="NO13"></p><p><strong>我们需要怎么移动元素呢？</strong><br>li-c作为第一各元素，我们完成对它的内部的对比更新即可</p><p>我们遍历到li-a的时候，我们知道它在旧DOMchildren中的索引是0，所以0 &lt; 2，我们需要移动li-a元素<br>而此时我们遍历的为新节点数组的li-a位置，我们拿到el真实DOM之后，在上一个元素之后插入即可。</p><pre><code>const refNode = nextChildren[i - 1].el.nextSibling // 上一个元素原本的下一个元素// 调用 insertBefore 函数移动 DOMcontainer.insertBefore(prevVNode.el, refNode)</code></pre><p><img src="/2020/01/17/2020/Vue-Diff/NO14.png" alt="NO14" title="NO14"></p><h6 id="添加新元素"><a href="#添加新元素" class="headerlink" title="添加新元素"></a>添加新元素</h6><p><img src="/2020/01/17/2020/Vue-Diff/NO15.png" alt="NO15" title="NO15"></p><p>我们可以找到，在旧的children中li-d是不存在的。<br>我们只需要将新的此节点挂载在正确位置上即可。<br><strong>如何知道此节点不存在？</strong><br>我们添加一个标志变量，在遍历新的children是声明为false，在旧的内部遍历时，找到此key节点，则置为true，最终验证此变量即可</p><pre><code>for (let i = 0; i &lt; nextChildren.length; i++) {  const nextVNode = nextChildren[i]  let j = 0,    find = false //   &lt;== 这  for (j; j &lt; prevChildren.length; j++) {    const prevVNode = prevChildren[j]    if (nextVNode.key === prevVNode.key) {      find = true      patch(prevVNode, nextVNode, container)      if (j &lt; lastIndex) {        const refNode = nextChildren[i - 1].el.nextSibling        container.insertBefore(prevVNode.el, refNode)        break      } else {        // 更新 lastIndex        lastIndex = j      }    }  }  if (!find) {    // 挂载新节点    const refNode =          i - 1 &lt; 0            ? prevChildren[0].el            : nextChildren[i - 1].el.nextSibling        mount(nextVNode, container, false, refNode)  }</code></pre><p>这个i-1&lt;0 是因为当前一个子节点为第一个节点的时候，我们把它插在最前面即可。</p><h6 id="移除不存在了的元素"><a href="#移除不存在了的元素" class="headerlink" title="移除不存在了的元素"></a>移除不存在了的元素</h6><p><img src="/2020/01/17/2020/Vue-Diff/NO16.png" alt="NO16" title="NO16"></p><p>我们用什么方法去移除寻找需要移除的DOM节点？<br>还记得我们一开始遍历的即是新的children吗，在内部才遍历旧children的吗？我们只会执行两次，第一次解决li-a、第二次解决li-b，然后就退出循环了</p><p>**所以我们需要在新的children遍历结束后，在进行一遍旧children的遍历，并且用旧children节点去新的children中寻找相同节点，如果找不到，则说明已经没有这个DOM了。</p><pre><code>// 移除已经不存在的节点// 遍历旧的节点for (let i = 0; i &lt; prevChildren.length; i++) {  const prevVNode = prevChildren[i]  // 拿着旧 VNode 去新 children 中寻找相同的节点  const has = nextChildren.find(    nextVNode =&gt; nextVNode.key === prevVNode.key  )  if (!has) {    // 如果没有找到相同的节点，则移除    container.removeChild(prevVNode.el)  }}</code></pre><p>上面的对比缺陷？</p><p><img src="/2020/01/17/2020/Vue-Diff/NO17.png" alt="NO17" title="NO17"></p><p><img src="/2020/01/17/2020/Vue-Diff/NO18.png" alt="NO18" title="NO18"></p><h5 id="VUE的对比？：双端比较"><a href="#VUE的对比？：双端比较" class="headerlink" title="VUE的对比？：双端比较"></a>VUE的对比？：双端比较</h5><p><img src="/2020/01/17/2020/Vue-Diff/NO19.png" alt="NO19" title="NO19"></p><p>我们使用四个索引指向着 old 与 new 的开始与结束，即双端</p><pre><code>let oldStartIdx = 0let oldEndIdx = prevChildren.length - 1let newStartIdx = 0let newEndIdx = nextChildren.length - 1// 同时let oldStartVNode = prevChildren[oldStartIdx]let oldEndVNode = prevChildren[oldEndIdx]let newStartVNode = nextChildren[newStartIdx]let newEndVNode = nextChildren[newEndIdx]</code></pre><p><strong>每一次的对比都会执行以下四步：</strong><br>newStartIndex - oldStartIndex<br>newEndIndex - oldEndIndex<br>oldStartIndex - newEndIndex<br>newStartIndex - oldEndIndex</p><p><img src="/2020/01/17/2020/Vue-Diff/NO20.png" alt="NO20" title="NO20"></p><pre><code>if (oldStartVNode.key === newStartVNode.key) {  // 步骤一：oldStartVNode 和 newStartVNode 比对} else if (oldEndVNode.key === newEndVNode.key) {  // 步骤二：oldEndVNode 和 newEndVNode 比对} else if (oldStartVNode.key === newEndVNode.key) {  // 步骤三：oldStartVNode 和 newEndVNode 比对}else if (oldEndVNode.key === newStartVNode.key) {  // 步骤四：oldEndVNode 和 newStartVNode 比对}</code></pre><p> 在第四步中我们可以得到可以复用的节点<br> 我们将li-d移动到开头</p><pre><code>if (oldStartVNode.key === newStartVNode.key) {  // 步骤一：oldStartVNode 和 newStartVNode 比对  } else if (oldEndVNode.key === newEndVNode.key) {  // 步骤二：oldEndVNode 和 newEndVNode 比对  } else if (oldStartVNode.key === newEndVNode.key) {  // 步骤三：oldStartVNode 和 newEndVNode 比对  } else if (oldEndVNode.key === newStartVNode.key) {   * * * * * * * *  * * * * * * * * * * * * * 这 * * * * * * * * * *      // 步骤四：oldEndVNode 和 newStartVNode 比对      // 先调用 patch 函数完成更新      patch(oldEndVNode, newStartVNode, container)      // 更新完成后，将容器中最后一个子节点移动到最前面，使其成为第一个子节点      container.insertBefore(oldEndVNode.el, oldStartVNode.el)      // 更新索引，指向下一个位置      oldEndVNode = prevChildren[--oldEndIdx]      newStartVNode = nextChildren[++newStartIdx]    }</code></pre><p> 而后我们进行下一次的对比：</p><p><img src="/2020/01/17/2020/Vue-Diff/NO21.png" alt="NO21" title="NO21"></p><p><img src="/2020/01/17/2020/Vue-Diff/NO22.png" alt="NO22" title="NO22"></p><p><strong>什么时候可以结束呢？</strong></p><pre><code>while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {  if (oldStartVNode.key === newStartVNode.key) {    // 步骤一：oldStartVNode 和 newStartVNode 比对  } else if (oldEndVNode.key === newEndVNode.key) {    // 步骤二：oldEndVNode 和 newEndVNode 比对  } else if (oldStartVNode.key === newEndVNode.key) {    // 步骤三：oldStartVNode 和 newEndVNode 比对  } else if (oldEndVNode.key === newStartVNode.key) {    // 步骤四：oldEndVNode 和 newStartVNode 比对  }  }</code></pre><p> 当oldStartIndex 大于 olaEndIndex 或者 newStartIndex 大于 newEndIndex的时候</p><p> <em>第二轮中，我们找到了li-c，而它是最后一个节点，DOM顺序的话不需要移动</em></p><pre><code>while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {  if (oldStartVNode.key === newStartVNode.key) {    // 步骤一：oldStartVNode 和 newStartVNode 比对  } else if (oldEndVNode.key === newEndVNode.key) {    * * * * * * * * * * * * * * * * * * * * * 这 * * * * * * * * * *    // 步骤二：oldEndVNode 和 newEndVNode 比对    // 调用 patch 函数更新    patch(oldEndVNode, newEndVNode, container)    // 更新索引，指向下一个位置    oldEndVNode = prevChildren[--oldEndIdx]    newEndVNode = nextChildren[--newEndIdx]  } else if (oldStartVNode.key === newEndVNode.key) {    // 步骤三：oldStartVNode 和 newEndVNode 比对  } else if (oldEndVNode.key === newStartVNode.key) {    // 步骤四：oldEndVNode 和 newStartVNode 比对    // 先调用 patch 函数完成更新    patch(oldEndVNode, newStartVNode, container)    // 更新完成后，将容器中最后一个子节点移动到最前面，使其成为第一个子节点    container.insertBefore(oldEndVNode.el, oldStartVNode.el)    // 更新索引，指向下一个位置    oldEndVNode = prevChildren[--oldEndIdx]    newStartVNode = nextChildren[++newStartIdx]  }}</code></pre><p><img src="/2020/01/17/2020/Vue-Diff/NO23.png" alt="NO23" title="NO23"> </p><p> 我们执行第三步的时候在li-a处，满足了<br>oldStartVNode.key === newEndVNode.key</p><pre><code>while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {  if (oldStartVNode.key === newStartVNode.key) {    // 步骤一：oldStartVNode 和 newStartVNode 比对  } else if (oldEndVNode.key === newEndVNode.key) {    // 步骤二：oldEndVNode 和 newEndVNode 比对    // 调用 patch 函数更新    patch(oldEndVNode, newEndVNode, container)    // 更新索引，指向下一个位置    oldEndVNode = prevChildren[--oldEndIdx]    newEndVNode = newEndVNode[--newEndIdx]  } else if (oldStartVNode.key === newEndVNode.key) {    * * * * * * * * * 这 * * * * * * * * *    // 步骤三：oldStartVNode 和 newEndVNode 比对    // 调用 patch 函数更新    patch(oldStartVNode, newEndVNode, container)    // 将 oldStartVNode.el 移动到 oldEndVNode.el 的后面，也就是 oldEndVNode.el.nextSibling 的前面    container.insertBefore(      oldStartVNode.el,      oldEndVNode.el.nextSibling    )    // 更新索引，指向下一个位置    oldStartVNode = prevChildren[++oldStartIdx]    newEndVNode = nextChildren[--newEndIdx]  } else if (oldEndVNode.key === newStartVNode.key) {    // 步骤四：oldEndVNode 和 newStartVNode 比对    // 先调用 patch 函数完成更新    patch(oldEndVNode, newStartVNode, container)    // 更新完成后，将容器中最后一个子节点移动到最前面，使其成为第一个子节点    container.insertBefore(oldEndVNode.el, oldStartVNode.el)    // 更新索引，指向下一个位置    oldEndVNode = prevChildren[--oldEndIdx]    newStartVNode = nextChildren[++newStartIdx]  }}</code></pre><p><strong>最后一轮</strong><br><img src="/2020/01/17/2020/Vue-Diff/NO24.png" alt="NO24" title="NO24"> </p><p><img src="/2020/01/17/2020/Vue-Diff/NO25.png" alt="NO25" title="NO25"> </p><p>patch li-b 即可</p><p><img src="/2020/01/17/2020/Vue-Diff/NO26.png" alt="NO26" title="NO26"> </p><h6 id="双端比较优势"><a href="#双端比较优势" class="headerlink" title="双端比较优势"></a>双端比较优势</h6><p><strong>还记得这个吗？</strong><br><img src="/2020/01/17/2020/Vue-Diff/NO27.png" alt="NO27" title="NO27"> </p><p><img src="/2020/01/17/2020/Vue-Diff/NO28.png" alt="NO28" title="NO28"> </p><p>在React的比较上基础上，我们使用双端比较来看看</p><p><img src="/2020/01/17/2020/Vue-Diff/NO29.png" alt="NO29" title="NO29"> </p><ul><li>④相同key，可复用，移动li-c</li></ul><p><img src="/2020/01/17/2020/Vue-Diff/NO30.png" alt="NO30" title="NO30"> </p><ul><li>然后我们发现就不再需要改变了</li></ul><h6 id="非理想情况的处理方式"><a href="#非理想情况的处理方式" class="headerlink" title="非理想情况的处理方式"></a>非理想情况的处理方式</h6><p>有这么一种情况，当①②③④都无法进行匹配上的时候</p><p><img src="/2020/01/17/2020/Vue-Diff/NO31.png" alt="NO31" title="NO31"> </p><p>那只能通过newStartIndex的这节点去oldChildren中寻找出来了</p><pre><code>while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {  if (oldStartVNode.key === newStartVNode.key) {    // 省略...  } else if (oldEndVNode.key === newEndVNode.key) {    // 省略...  } else if (oldStartVNode.key === newEndVNode.key) {    // 省略...  } else if (oldEndVNode.key === newStartVNode.key) {    // 省略...  } else {  * * * * * * * 这 * * * * * * * * *    // 遍历旧 children，试图寻找与 newStartVNode 拥有相同 key 值的元素    const idxInOld = prevChildren.findIndex(      node =&gt; node.key === newStartVNode.key    )  }}</code></pre><p><img src="/2020/01/17/2020/Vue-Diff/NO32.png" alt="NO32" title="NO32"> </p><p>else 的关键在于，找到了在oldChildren中的这个DOM，并且明白它已经在newChildren中被移动到了最前面。</p><ul><li>oldChildren 中的DOM被移动到最前面</li><li>调用patch函数完成更新</li><li>把oldChildren的目标节点移动在最前面，即oldStartIndex.el前面</li><li>同时将该位置将被置为undefined</li></ul><p><img src="/2020/01/17/2020/Vue-Diff/NO33.png" alt="NO33" title="NO33"> </p><p>那么前面的对比也需要增加遇到undefinded的情况调过的步骤。</p><h6 id="添加新元素-1"><a href="#添加新元素-1" class="headerlink" title="添加新元素"></a>添加新元素</h6><p><img src="/2020/01/17/2020/Vue-Diff/NO34.png" alt="NO34" title="NO34"> </p><p>用li-d 执行上述的步骤，执行不下去，li-b是新的节点</p><p>那是不是我们①②③④执行不下去的时候，将 li-d 挂载在最前面就可以了呢？<br>即挂载在oldStartIndex.el前面？</p><p>我们再来看一个例子</p><p><img src="/2020/01/17/2020/Vue-Diff/NO35.png" alt="NO35" title="NO35"> </p><p>大家模拟一下：自由思考</p><p>刷</p><pre><code>刷</code></pre><ul><li>②中找到可复用的节点，同时因为是最后，所以DOM不移动，patch即可</li></ul><p><strong>下一步</strong></p><p><img src="/2020/01/17/2020/Vue-Diff/NO36.png" alt="NO36" title="NO36"> </p><ul><li>②中找到可复用节点，同时DOM也不需要移动，patch即可</li></ul><p><strong>下一步</strong><br><img src="/2020/01/17/2020/Vue-Diff/NO37.png" alt="NO37" title="NO37"> </p><ul><li>②中可复用，依旧处理<br><img src="/2020/01/17/2020/Vue-Diff/NO38.png" alt="NO38" title="NO38"> </li></ul><p>所以我们发现 li-d 并没有被处理到<br>所以我们需要增加多一个判断，oldEndIndex 小于 oldStartIndex的话，就存在没有被处理到的全新节点</p><p><strong>我们需要把这些全新的节点挂载在oldStartIndex前面</strong></p><pre><code>while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {  // 省略...}  * * * * * * * * 这 * * * * * *   if (oldEndIdx &lt; oldStartIdx) {      // 添加新节点      for (let i = newStartIdx; i &lt;= newEndIdx; i++) {        mount(nextChildren[i], container, false, oldStartVNode.el)      }   }</code></pre><h6 id="移除不存在的元素"><a href="#移除不存在的元素" class="headerlink" title="移除不存在的元素"></a>移除不存在的元素</h6><p>  <img src="/2020/01/17/2020/Vue-Diff/NO39.png" alt="NO39" title="NO39"> </p><p>  <strong>自由思考一下：</strong></p><pre><code></code></pre><p><img src="/2020/01/17/2020/Vue-Diff/NO41.png" alt="NO41" title="NO41"> </p><ul><li>①中 patch 了 li-a</li></ul><p><strong>下一步</strong><br><img src="/2020/01/17/2020/Vue-Diff/NO42.png" alt="NO42" title="NO42"> </p><ul><li>②中 patch 了 li-c<br><img src="/2020/01/17/2020/Vue-Diff/NO43.png" alt="NO43" title="NO43"> </li></ul><p><strong>结束</strong></p><p>条件 newEndIndex &lt; newStartIndex 了<br>所以以此条件说明有元素被移除了</p><pre><code>while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {  // 省略...}      if (oldEndIdx &lt; oldStartIdx) {      // 添加新节点      for (let i = newStartIdx; i &lt;= newEndIdx; i++) {        mount(nextChildren[i], container, false, oldStartVNode.el)      }} else if (newEndIdx &lt; newStartIdx) {      // 移除操作      for (let i = oldStartIdx; i &lt;= oldEndIdx; i++) {        container.removeChild(prevChildren[i].el)      }  }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>借鉴费舍尔.耶茨混洗优化公司年会抽奖</title>
      <link href="/2020/01/07/2020/%E8%B4%B9%E8%88%8D%E5%B0%94-%E8%80%B6%E8%8C%A8%E6%B7%B7%E6%B4%97/"/>
      <url>/2020/01/07/2020/%E8%B4%B9%E8%88%8D%E5%B0%94-%E8%80%B6%E8%8C%A8%E6%B7%B7%E6%B4%97/</url>
      
        <content type="html"><![CDATA[<h2 id="年会抽奖"><a href="#年会抽奖" class="headerlink" title="年会抽奖"></a>年会抽奖</h2><p>今年的公司年会抽奖，开发界面及相应逻辑就落在我这边，大致的界面是这样…</p><p><img src="/2020/01/07/2020/费舍尔-耶茨混洗/NO1.png" alt="NO1" title="NO1"></p><p>Vue搭了一个架子，express做后台和数据做一些数据交换，nginx代理。<br>一切似乎很简单，抽奖的方法也是<code>random</code>就好了，然后<code>splice</code>…</p><p>但是，发现使用<code>splice</code>方法会默默的把后面数组的所有元素都挪一位，感觉不太妙，虽然人数不多，但是这样的方法也不是很好，于是就开始网上冲浪…🏄‍♂️</p><h2 id="费舍尔-耶茨混洗"><a href="#费舍尔-耶茨混洗" class="headerlink" title="费舍尔.耶茨混洗"></a>费舍尔.耶茨混洗</h2><p>.from url <a href="https://bost.ocks.org/mike/shuffle/" target="_blank" rel="noopener">费舍尔.耶茨混洗</a></p><p>数字 1 - N 之间的一组混排，大概一下子可以想到的是：</p><ul><li>从数组中取数组长度中的一个随机数 K。</li><li>然后将数组 K 索引处的 数值取出 splice，堆如新数组。</li><li>重复…</li></ul><p>混洗的算法中，使用从数组的高位开始。<br>我们使用数组的后部存储随机组合的元素，并使用数组的前部存储其余元素。<br>只要我们在选取时进行统一采样，我们就不会关心其余元素的顺序！为了实现就地O（n）随机播放，然后，从前面选择一个随机剩余的元素，并将其放置在新位置（在后面）。<br>后面的未改组元素交换到前面，在此处等待后续改组：</p><p>这是什么意思呢？</p><a id="more"></a><p>例如我们要在以下数组中随机取出三位：</p><pre><code>[&#39;a&#39;, &#39;s&#39;, &#39;f&#39;, &#39;w&#39;, &#39;r&#39;, &#39;y&#39;, &#39;c&#39;, &#39;o&#39;, &#39;q&#39;];</code></pre><p>当我们每次<code>for</code>循环时，我们不需要立即splice，以为立即取出的话会造成后续元素的位移。</p><p>我们将它与数组最后一位进行交换位置。</p><ol><li><p>i = 1 时， 我们选中了 ‘w’，我们即刻进行位置调整，这样数组变成了</p></li></ol><pre><code>[&#39;a&#39;, &#39;s&#39;, &#39;f&#39;, &#39;q&#39;, &#39;r&#39;, &#39;y&#39;, &#39;c&#39;, &#39;o&#39;, &#39;w&#39;];</code></pre><ol start="2"><li><p>i = 2 时， 我们选中了 ‘s’，我们即刻进行位置调整，这样数组变成了</p></li></ol><pre><code>[&#39;a&#39;, &#39;o&#39;, &#39;f&#39;, &#39;q&#39;, &#39;r&#39;, &#39;y&#39;, &#39;c&#39;, &#39;s&#39;, &#39;w&#39;];</code></pre><p>以此类推…</p><p>最后我们一次性取出最后三位即可。</p><blockquote><p>code</p></blockquote><pre><code>function shuffle(array) {  var m = array.length, t, i;  // While there remain elements to shuffle…  while (m) {    // Pick a remaining element…    i = Math.floor(Math.random() * m--);    // And swap it with the current element.    t = array[m];    array[m] = array[i];    array[i] = t;  }  return array;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS原型链</title>
      <link href="/2019/12/15/2019/JS%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2019/12/15/2019/JS%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p>每个实例对象都有一个属性<code>__proto__</code>指向构造函数的原型对象<code>prototype</code>上。该原型对象上也有这么一个属性，指向自己的原型对象，一层一层直到指向为<code>null</code>，这种关系就称为<code>原型链</code>。</p><p>👉：<a href="https://segmentfault.com/a/1190000021232132" target="_blank" rel="noopener">原文</a></p><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="/2019/12/15/2019/JS原型链/NO1.png" alt="NO1" title="NO1"></p><h4 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h4><a id="more"></a><p>prototype属性可以看成是一块特殊的存储空间，存储了供“徒弟”、“徒孙”们使用的方法和属性。</p><p><img src="/2019/12/15/2019/JS原型链/NO2.png" alt="NO2" title="NO2"></p><h4 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h4><p><strong>proto</strong>属性相当于通往prototype（“琅琊福地”）唯一的路（指针）<br>让“徒弟”、“徒孙” 们找到自己“师父”、“师父的师父” 提供给自己的方法和属性。</p><p><img src="/2019/12/15/2019/JS原型链/NO3.png" alt="NO3" title="NO3"></p><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>constructor属性是让“徒弟”、“徒孙” 们知道是谁创造了自己，这里可不是“师父”啊。<br>而是自己的父母，父母创造了自己，父母又是由上一辈人创造的，……追溯到头就是Function() </p><p><img src="/2019/12/15/2019/JS原型链/NO4.png" alt="NO4" title="NO4"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScipt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>踩坑eCharts参数</title>
      <link href="/2019/11/01/2019/%E8%B8%A9%E5%9D%91eCharts%E5%8F%82%E6%95%B0/"/>
      <url>/2019/11/01/2019/%E8%B8%A9%E5%9D%91eCharts%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/11/01/2019/踩坑eCharts参数/NO0.png" alt="NO0" title="NO0"></p><p>在echarts中，当对其中的option参数有所使用的时候，第二个参数是用于判断是否合并旧参数数据。<br>如果为true，则将完全替代，而不会在界面上出现“部分更新”的效果<br>如果为false，则是迭代进入新参数，会出现即使设置了新数据option，还会保留有 部分旧数据的情况。</p><p>搞得我整了好一会不知道为啥数据没响应，也是自己蠢🤣</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this指向</title>
      <link href="/2019/10/17/2019/this%E6%8C%87%E5%90%91/"/>
      <url>/2019/10/17/2019/this%E6%8C%87%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h4 id="一图解"><a href="#一图解" class="headerlink" title="一图解"></a>一图解</h4><p><img src="/2019/10/17/2019/this指向/NO1.png" alt="NO1" title="NO1"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Canvas进行像素分析，结合数据进行实时着色</title>
      <link href="/2019/10/08/2019/canvas%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%83%8F%E5%83%8F%E7%B4%A0%E7%82%B9%E7%9D%80%E8%89%B2/"/>
      <url>/2019/10/08/2019/canvas%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%83%8F%E5%83%8F%E7%B4%A0%E7%82%B9%E7%9D%80%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<h4 id="一、canvas的处理小技巧"><a href="#一、canvas的处理小技巧" class="headerlink" title="一、canvas的处理小技巧"></a>一、canvas的处理小技巧</h4><p>在保障的业务监控里，遇到这么一个难题，需要在场馆保障的同时，对现场的采集的指标进行不同门限预警进行颜色区分…，并且画出来</p><p>这可…<br><img src="/2019/10/08/2019/canvas进行图像像素点着色/NO0.png" alt="NO0" title="NO0"></p><p>UI给了如下两张图片：</p><h6 id="图一："><a href="#图一：" class="headerlink" title="图一："></a>图一：</h6><p><img src="/2019/10/08/2019/canvas进行图像像素点着色/NO1.png" alt="NO1" title="NO1"><br><a id="more"></a></p><h6 id="图二："><a href="#图二：" class="headerlink" title="图二："></a>图二：</h6><p><img src="/2019/10/08/2019/canvas进行图像像素点着色/NO2.png" alt="NO2" title="NO2"><br>需要去合成如下第三张实时指标着色图：</p><h6 id="图三："><a href="#图三：" class="headerlink" title="图三："></a>图三：</h6><p><img src="/2019/10/08/2019/canvas进行图像像素点着色/NO3.png" alt="NO3" title="NO3"></p><p>那么该如何做呢？</p><p>有需要需要根据数据的ID，去判断不同的指标值所带来的颜色，如何给这么一个椭圆形附上颜色呢？</p><p>和UI商量之后，给出了图二这么一个关键信息。<br><strong>能看出有什么奥秘吗?</strong></p><p>我们先来思考一下如何匹配上各个ID，用于给每个区块附上颜色。</p><p>我们拥有一批有ID的数据 <strong>-&gt;</strong> 需要能识别到图上所对应的位置 <strong>-&gt;</strong> 相应位置应该有能标识的关键信息 <strong>-&gt;</strong> 如何为图片打上关键信息</p><p>因此canvas就出场了。</p><p>canvas的关键属性方法：<br><strong>getImageData()</strong> ，可以识别到指定范围的颜色值出来，因此，我们借用这个就可以做到</p><p>没错，图二 是UI分别对各个区块填充的有规律颜色<br>分别只对R，G，B进行了颜色填充<br>由内到外，对图一的座位进行了标出<br>内圈一二层分别由R1排至R64，也就是<br>rgba(1,0,0,1)、rgba(2,0,0,1)…</p><p>因此我们在通过<br><strong>let imgData = ctx1.getImageData(0, 0, FDW, FDH);</strong></p><p>读取到的imgData中，我们就可以通过识别相应的R数组，知道该位置点是哪个ID属性的，并且找寻到相应ID的颜色值，为该点附上，依次类推，就可以建立一个<strong>颜色-ID-图片</strong>的关系出来</p><pre><code>let r = imgData.data[i], g = imgData.data[i + 1], b = imgData.data[i + 2], a = imgData.data[i + 3];if(a !== 0 &amp;&amp; (r!==0 || g!== 0 || b!== 0)) {    DealColorData2(imgData, ObjData, r, g, b, a, i);}</code></pre><p><img src="/2019/10/08/2019/canvas进行图像像素点着色/GIF.gif" alt="NO4" title="NO4"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个失焦指令的学习</title>
      <link href="/2019/09/26/2019/%E4%B8%80%E4%B8%AA%E5%A4%B1%E7%84%A6%E6%8C%87%E4%BB%A4%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/09/26/2019/%E4%B8%80%E4%B8%AA%E5%A4%B1%E7%84%A6%E6%8C%87%E4%BB%A4%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="前情"><a href="#前情" class="headerlink" title="前情"></a>前情</h4><p>前情，山西项目中由于选择等条件增多，于是抽离出来一个简单的单选多选组件。样式的话，普通极了，也没与完全按照最初UI给的设置稿。当然这是另外的话。<br>遇到的其中一个问题就是:<br>我希望可以有失焦时得回弹，首先就是我想到得是利用指令进行初始加载时候对各组件实例绑定上这么个事件逻辑。<br>于是我写下了这么一串代码：<br><a id="more"></a></p><pre><code>bind: (el, event, vM) =&gt; {    let _that = vM.context;    const aimdomArr = [&#39;Moretext_&#39;, &#39;MoreTextcontent_&#39;, &#39;MoreTextTriDown_&#39;, &#39;MoreTextTriUp_&#39;, &#39;MoreSelcontent_&#39;,        &#39;MoreSelUnit_&#39;, &#39;SelUnitIcon_ SelUnitUnCho&#39;, &#39;SelUnitText&#39;, &#39;SelUnitIcon_ SelUnitCho&#39;,        &#39;Singletext_&#39;, &#39;SingleTextcontent_&#39;, &#39;SingleTextTriDown_&#39;, &#39;SingleTextTriUp_&#39;, &#39;SingleSelcontent_&#39;,         &#39;SingleSelUnit_&#39;    ]    document.body.onclick = ((e) =&gt; {        let TARGETName = e.target.className;        let judgeclick = aimdomArr.indexOf(TARGETName);        if(judgeclick === -1) {            _that.isclickMore = false;            _that.isclickSingle = false;        }    }); }</code></pre><p>我得初衷是记录下组件得this，然后在监听发生在body上得点击事件，如若不是发生在相关得class类上得，则可以进行判断到。<br>但是，实际上绑定得this（_that）并不会一直是正确得那个，在bing得外层并没有响应得作用域，我们打印一下_taht是什么。</p><p><img src="/2019/09/26/2019/一个失焦指令的学习/NO1.png" alt="NO1" title="NO1"></p><p>以及触发事件时得that</p><p><img src="/2019/09/26/2019/一个失焦指令的学习/NO2.png" alt="NO2" title="NO2"></p><p>都在每一次组件实例绑定时把_that不断刷新成最新得那个了<br>那这时候应该怎么解决呢？<br>（什么, 大声🔈）<br>闭包。</p><p>在后来我想到可以看看element是如何实现相关逻辑得呢？于是就找一找element对于el-select的封装。<br><em>element-dev\packages\select\index.js</em><br>我们可以看到</p><pre><code>&lt;div class=&quot;el-select&quot; :class=&quot;[selectSize ? &#39;el-select--&#39; + selectSize : &#39;&#39;]&quot;    @click.stop=&quot;toggleMenu&quot;    v-clickoutside=&quot;handleClose&quot;&gt;</code></pre><p>也以指令得形式 <strong>clickoutside</strong>对这个逻辑进行封装以备复用<br><em>element-dev\src\utils\clickoutside.js</em></p><pre><code>bind(el, binding, vnode) {    nodeList.push(el);    const id = seed++;    el[ctx] = {      id,      documentHandler: createDocumentHandler(el, binding, vnode),      methodName: binding.expression,      bindingFn: binding.value    };},nodeList.forEach(node =&gt; node[ctx].documentHandler(e, startClick));if (binding.expression &amp;&amp; el[ctx].methodName &amp;&amp; vnode.context[el[ctx].methodName]) {     vnode.context[el[ctx].methodName](); } else {    el[ctx].bindingFn &amp;&amp; el[ctx].bindingFn();}</code></pre><p><img src="/2019/09/26/2019/一个失焦指令的学习/NO3.png" alt="NO3" title="NO3"><br><img src="/2019/09/26/2019/一个失焦指令的学习/GIF.gif" alt="GIF" title="GIF"></p><h4 id="Vue指令的编写"><a href="#Vue指令的编写" class="headerlink" title="Vue指令的编写"></a>Vue指令的编写</h4><p>我们顺便回顾一下对于Vue指令的指导吧。</p><h5 id="注册全局指令"><a href="#注册全局指令" class="headerlink" title="注册全局指令"></a>注册全局指令</h5><pre><code>Vue.directive(&#39;focus&#39;, {  // 当被绑定的元素插入到 DOM 中时……  inserted: function (el) {    // 聚焦元素    el.focus()  }})</code></pre><h5 id="注册局部指令"><a href="#注册局部指令" class="headerlink" title="注册局部指令"></a>注册局部指令</h5><pre><code>directives: {  focus: {    // 指令的定义    inserted: function (el) {      el.focus()    }  }}</code></pre><h5 id="指令接收的钩子函数"><a href="#指令接收的钩子函数" class="headerlink" title="指令接收的钩子函数"></a>指令接收的钩子函数</h5><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p><ul><li>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li><li>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li><li>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</li><li>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li><li>unbind：只调用一次，指令与元素解绑时调用。</li></ul><h5 id="钩子函数接收的参数"><a href="#钩子函数接收的参数" class="headerlink" title="钩子函数接收的参数"></a>钩子函数接收的参数</h5><ul><li>el：指令所绑定的元素，可以用来直接操作 DOM。</li><li>binding：一个对象，包含以下 property:<pre><code>  name：指令名，不包括 v- 前缀。  value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。  oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。  expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。  arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。  modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。  vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。  oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</code></pre></li></ul><p><strong>举例说明</strong></p><pre><code>&lt;div id=&quot;hook-arguments-example&quot; v-demo:foo.a.b=&quot;message&quot;&gt;&lt;/div&gt;</code></pre><pre><code>Vue.directive(&#39;demo&#39;, {  bind: function (el, binding, vnode) {    var s = JSON.stringify    el.innerHTML =      &#39;name: &#39;       + s(binding.name) + &#39;&lt;br&gt;&#39; +  // demo      &#39;value: &#39;      + s(binding.value) + &#39;&lt;br&gt;&#39; + // message的值      &#39;expression: &#39; + s(binding.expression) + &#39;&lt;br&gt;&#39; + // 表达式，即message      &#39;argument: &#39;   + s(binding.arg) + &#39;&lt;br&gt;&#39; + // 指令的传参，即foo      &#39;modifiers: &#39;  + s(binding.modifiers) + &#39;&lt;br&gt;&#39; // 修饰对象，即a: true, b: true  }})</code></pre><p>当然，如果有需要自定义传参，foo也是可以修改为动态参数的。</p><h6 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h6><pre><code>v-mydirective:[argument]=&quot;value&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Element </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毕业了</title>
      <link href="/2019/06/27/2019/%E6%AF%95%E4%B8%9A%E4%BA%86/"/>
      <url>/2019/06/27/2019/%E6%AF%95%E4%B8%9A%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<h5 id="毕业了"><a href="#毕业了" class="headerlink" title="毕业了"></a>毕业了</h5><p>诸多不舍，学生时代多好😔</p>]]></content>
      
      
      <categories>
          
          <category> 读书V生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常碎碎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flex布局的基本属性介绍</title>
      <link href="/2019/05/13/2019/Flex%E5%B8%83%E5%B1%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/05/13/2019/Flex%E5%B8%83%E5%B1%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h4 id="flex的布局定义："><a href="#flex的布局定义：" class="headerlink" title="flex的布局定义："></a>flex的布局定义：</h4><ul><li>display： flex；</li></ul><p>有所区分出，主轴（main-axis）与交叉轴(cross-axis)</p><p><img src="/2019/05/13/2019/Flex布局的基本属性介绍/bg2015071004.png" alt="1" title="1"></p><a id="more"></a><h4 id="容器（父元素）有以下六个属性"><a href="#容器（父元素）有以下六个属性" class="headerlink" title="容器（父元素）有以下六个属性"></a>容器（父元素）有以下六个属性</h4><h5 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h5><p>（row/row-reverse/column/column-reverse）</p><ul><li>row : 主轴水平，起点左端</li><li>row-reverse : 主轴水平，起点右端</li><li>column : 主轴垂直，起点上端</li><li>column-reverse : 主轴垂直，起点下端</li></ul><p><img src="/2019/05/13/2019/Flex布局的基本属性介绍/bg2015071005.png" alt="2" title="2"></p><h5 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h5><p>(nowrap/wrap/wrap-reverse)</p><ul><li>wrap : 当主轴排列不下时，换行</li><li>nowrap : 不换行</li><li>wrap-reverse : 换行，但转向的</li></ul><h5 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h5><p>(flex-flow是flex-direction与flex-wrap的简写形式)</p><h5 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h5><p>： 定义了项目在主轴上的对齐方式<br>(flex-start/ flex-end/ center/ space-between/ space-around)</p><ul><li>flex-start : 主轴开始方向对齐</li><li>flex-end : 主轴结束方向对齐</li><li>center : 主轴方向居中</li><li>space-between : 两端对齐，项目间隙相等</li><li>space-around : 项目两侧间隔相等，间隔是与边框的两倍</li></ul><p><img src="/2019/05/13/2019/Flex布局的基本属性介绍/bg2015071010.png" alt="3" title="3"></p><h5 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h5><p>：定义了 <strong>每行</strong> 项目的在侧轴方向上的对齐方式</p><ul><li>flex-start : 侧轴开始方向对齐</li><li>flex-end : 侧轴结束方向对齐</li><li>center ： 侧轴居中对齐</li><li>baseline ：项目每一行文字的几线对齐</li><li>stretch : 项目高度为auto时，占满整个容器</li></ul><p><img src="/2019/05/13/2019/Flex布局的基本属性介绍/bg2015071011.png" alt="4" title="4"></p><h5 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h5><p>： 定义了容器在侧轴方向上有额外空间时，如何排布每一行</p><ul><li>felx-start : 侧轴开始方向对齐</li><li>felx-end : 侧轴结束方向对齐</li><li>center : 侧轴中心对齐</li><li>space-between ： 与侧轴两端对齐，每行轴线间隔平均</li><li>space-around : 每根轴线两侧间隔相等</li><li>stretch : 占满整个侧轴</li></ul><p><img src="/2019/05/13/2019/Flex布局的基本属性介绍/bg2015071012.png" alt="5" title="5"></p><h4 id="项目（子元素）有以下六个属性"><a href="#项目（子元素）有以下六个属性" class="headerlink" title="项目（子元素）有以下六个属性"></a>项目（子元素）有以下六个属性</h4><h5 id="order"><a href="#order" class="headerlink" title="order"></a>order</h5><p>：定义了项目的排列顺序，数值越小排列越靠前，默认为0</p><p><img src="/2019/05/13/2019/Flex布局的基本属性介绍/bg2015071013.png" alt="6" title="6"></p><h5 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h5><p>：定义了属性项目的放大比例；<br>默认为0，即使有剩余空间，也不放大；<br>如果所有都为1，他们将等分剩余空间；<br>如果有一个为2，其他为1时，前者占据后者两倍的项目空间；</p><h5 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h5><p>：定义了项目的缩小比例，若项目空间不足时，项目将缩小<br>如果所有都为1，空间不足时，都将等比例缩小；<br>如果有一个为0，其他为1时，前者空间不缩小，后者等比例均分缩小</p><p><img src="/2019/05/13/2019/Flex布局的基本属性介绍/bg2015071015.jpg" alt="7" title="7"></p><h5 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h5><p>：定义了在分配多余空间；在分配多余空间之前，项目所占据的主轴空间，根据这个属性，计算主轴是否还有多余空间<br>可以定义和width和height属性一样的值。</p><h5 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h5><p>：flex是flex-grow、flex-shrink、flex-basis的缩写</p><h5 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h5><p>：定义允许单个项目与其他项目有不一样的侧轴对齐方式，可覆盖align-item</p><p><img src="/2019/05/13/2019/Flex布局的基本属性介绍/bg2015071016.png" alt="8" title="8"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gulp源码分析学习(三</title>
      <link href="/2019/04/09/2019/Gulp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0-%E4%B8%89/"/>
      <url>/2019/04/09/2019/Gulp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h1 id="vinyl-fs部分"><a href="#vinyl-fs部分" class="headerlink" title="vinyl-fs部分"></a>vinyl-fs部分</h1><p>当我们进入vinyl-fs的根目录index.js下，我们可以看到vinyl-fs所实现的src、dest接口是被分属于了几个外部模块 =&gt; </p><pre><code>&#39;use strict&#39;;// 让我们来看一下各自所属的文件module.exports = {  // 文件的处理上  src: require(&#39;./lib/src&#39;),  dest: require(&#39;./lib/dest&#39;),  symlink: require(&#39;./lib/symlink&#39;),};</code></pre><h2 id="一、glob"><a href="#一、glob" class="headerlink" title="一、glob"></a>一、glob</h2><p>在进入相应的模块方法分析之前，我们先来看一下什么是glob；</p><p>node的glob是指允许你使用一些正则表达式，用于匹配对应规则的文件，</p><a id="more"></a><p>类似于我们通常在gulp打包配置中所写的一样：</p><pre><code>gulp.src([&#39;./lib/images/*&#39;, &#39;./lib/images/*/*&#39;])</code></pre><p>而这其中即是我们的glob模式，也是如此我们可以匹配我们相应的传入文件。</p><p><strong>接下来，我们将陆续的来看一下</strong>src<strong> 、 </strong>dest<strong> 的具体实现。</strong></p><h2 id="二、src"><a href="#二、src" class="headerlink" title="二、src"></a>二、src</h2><p>我们进入 ./lib/src/index.js 中查看相应的入口文件</p><pre><code>&#39;use strict&#39;;var gs = require(&#39;glob-stream&#39;);// 结合流的阵列成使用单个双工流泵和duplexify// 如果其中一个流关闭/错误，管道中的所有流都将被销毁。var pumpify = require(&#39;pumpify&#39;);// 在transformStream中包装ReadableStreamvar toThrough = require(&#39;to-through&#39;);var isValidGlob = require(&#39;is-valid-glob&#39;);var createResolver = require(&#39;resolve-options&#39;);// 以下各导入模块可以进入相应文件中查看注释分析var config = require(&#39;./options&#39;);var prepare = require(&#39;./prepare&#39;);var wrapVinyl = require(&#39;./wrap-vinyl&#39;);var sourcemap = require(&#39;./sourcemap&#39;);var readContents = require(&#39;./read-contents&#39;);var resolveSymlinks = require(&#39;./resolve-symlinks&#39;);function src(glob, opt) {  // 此处进行默认的配置与传入的配置进行解析配置，详情可见vintl-fs-Test\createResolverTest.js  // 类似合并默认配置项与用户传入配置项  var optResolver = createResolver(config, opt);  // 判断是否有效的glob(简化的正则表达式)  if (!isValidGlob(glob)) {    throw new Error(&#39;Invalid glob argument: &#39; + glob);  }  var streams = [    // 使用了glob-stream模块，传入一个(简化的正则表达式)做为第一个参数，opt对象作为第二个参数，    // 返回创建glob流    gs(glob, opt),    // 传入上述的解析配置，创建一个vinly文件对象    wrapVinyl(optResolver),    // glob的stat为symlink的情况下，转为硬链接    resolveSymlinks(optResolver),    // 进行文件stat以及与optResolver配置选项上进行时间的比较    prepare(optResolver),    // 对流进行操作，获取文件内容，写入file.content属性    // 预设为Buffer是通过readBuffer获取    // 否则则通过readStream获取    readContents(optResolver),    // 对文件的映射，是否开启 sourcemap    sourcemap(optResolver),    /*    一步步的加工成streams    传于pumpify    */  ];  var outputStream = pumpify.obj(streams);  // 返回outputStream作为参数的toThrough流  return toThrough(outputStream);}module.exports = src;</code></pre><p>至此，简单的将即是我们的gulp.src便是使用于将匹配的文件转换为流的形式进而通过各项处理</p><p><strong>接下来，让我们看一下dest中对stream的处理</strong></p><h2 id="三、dest"><a href="#三、dest" class="headerlink" title="三、dest"></a>三、dest</h2><p>我们依旧进入相应的 ./lib/dest/index.js 中查看其入口文件</p><pre><code>&#39;use strict&#39;;/*dest主要作用是根据src接口接收透过来的输出流，并生成文件于指定文件夹*/// 将流信息转为var lead = require(&#39;lead&#39;);// 结合流的阵列成使用单个双工流泵和duplexify// 如果其中一个流关闭/错误，管道中的所有流都将被销毁。var pumpify = require(&#39;pumpify&#39;);// 在写入文件前确认目标文件夹存在var mkdirpStream = require(&#39;fs-mkdirp-stream&#39;);// 配置选项的解析var createResolver = require(&#39;resolve-options&#39;);// 配置var config = require(&#39;./options&#39;);// 用于比较var prepare = require(&#39;./prepare&#39;);// 生成sourcemapvar sourcemap = require(&#39;./sourcemap&#39;);var writeContents = require(&#39;./write-contents&#39;);var folderConfig = {  outFolder: {    type: &#39;string&#39;,  },};function dest(outFolder, opt) {  // 如果目标outFolder为空---&gt;报错  if (!outFolder) {    throw new Error(&#39;Invalid dest() folder argument.&#39; +      &#39; Please specify a non-empty string or a function.&#39;);  }  // 配置与用户传入配置的解析  var optResolver = createResolver(config, opt);  // 文件路径的配置解析---地址  var folderResolver = createResolver(folderConfig, { outFolder: outFolder });  //   function dirpath(file, callback) {    var dirMode = optResolver.resolve(&#39;dirMode&#39;, file);    callback(null, file.dirname, dirMode);  }  // 流  var saveStream = pumpify.obj(    // 提取以及校验流信息    prepare(folderResolver, optResolver),    // 生成sourcemap地图    sourcemap(optResolver),    // 传入解析dirMode的以下方法，...    mkdirpStream.obj(dirpath),    // 想合后的相应配置传入writeContents，然后写入相应文件    writeContents(optResolver)  );  // Sink the output stream to start flowing  // 流沉淀为文件  return lead(saveStream);}module.exports = dest;</code></pre><p>依据着相应的模块指示，我们也可以大致的清楚了gulp进行打包操作的流程</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gulp </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gulp源码分析学习(二</title>
      <link href="/2019/04/06/2019/Gulp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0-%E4%BA%8C/"/>
      <url>/2019/04/06/2019/Gulp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="undertaker模块文件分析"><a href="#undertaker模块文件分析" class="headerlink" title="undertaker模块文件分析"></a>undertaker模块文件分析</h2><p>我们从上一篇的入口文件分析可以得知，<strong>Gulp</strong>进行task、series、parallel等任务时，所执行的方法入口其实来源于<em>undertaker</em>模块</p><p>因此我们也进入相应的<em>undertaker</em>模块一探究竟</p><h2 id="一、undertaker-index-js"><a href="#一、undertaker-index-js" class="headerlink" title="一、undertaker-index.js"></a>一、undertaker-index.js</h2><a id="more"></a><p>undertaker模块下的index.js方法 =&gt;</p><pre><code>// Node工具函数中的继承var inherits = require(&#39;util&#39;).inherits;// Node中的事件触发器var EventEmitter = require(&#39;events&#39;).EventEmitter;var DefaultRegistry = require(&#39;undertaker-registry&#39;);var tree = require(&#39;./lib/tree&#39;);var task = require(&#39;./lib/task&#39;);var series = require(&#39;./lib/series&#39;);var lastRun = require(&#39;./lib/last-run&#39;);var parallel = require(&#39;./lib/parallel&#39;);var registry = require(&#39;./lib/registry&#39;);var _getTask = require(&#39;./lib/get-task&#39;);var _setTask = require(&#39;./lib/set-task&#39;);</code></pre><pre><code>inherits(Undertaker, EventEmitter);// 然后继续看一下其他模块方法的具体作用Undertaker.prototype.tree = tree;Undertaker.prototype.task = task;Undertaker.prototype.series = series;Undertaker.prototype.lastRun = lastRun;Undertaker.prototype.parallel = parallel;Undertaker.prototype.registry = registry;Undertaker.prototype._getTask = _getTask;Undertaker.prototype._setTask = _setTask;</code></pre><p>依旧采用核心工具函数的inherits方法进行构造函数的继承</p><p>inherits(Undertaker, EventEmitter); 此处使得<strong>Undertake</strong>r构造函数继承自<strong>Node</strong>核心模块<strong>EventEmitter</strong> 的原型链上方法，以及将EventEmitter的构造函数绑定在Undertaker构造函数的<strong>super_</strong>上。</p><p>并且将我们在开始部分所require进来的方法函数添加至原始链prototype上，以便调用</p><font color="ffff00"><em>接下来我们来看一下其中还有一个主方法，当中又实现了什么呢 =&gt; ?</em></font><pre><code>function Undertaker(customRegistry) {  EventEmitter.call(this);  /*  我们来看一下DefaultRegistry(undertaker-registry)都干了什么  */  this._registry = new DefaultRegistry();  // 允许用户自定义的寄存器任务  if (customRegistry) {    this.registry(customRegistry);  }  // process.env =&gt; 包含对用户环境信息的 对象  this._settle = (process.env.UNDERTAKER_SETTLE === &#39;true&#39;);}</code></pre><p>EventEmitter.call(this); 将EventEmitter执行函数的this绑定</p><p>this._registry = new DefaultRegistry(); new了一个DefaultRegistry的实例赋予this._registry属性</p><p>// 后两句我们稍后处理</p><p><em>DefaultRegistry</em>来源于<em>undertaker-registry</em></p><p>好的，那让我们现在来看一下，<strong>undertaker-registry</strong> 都将干些什么事。</p><h2 id="二、undertaker-registry-index-js"><a href="#二、undertaker-registry-index-js" class="headerlink" title="二、undertaker-registry - index.js"></a>二、undertaker-registry - index.js</h2><pre><code>// 提供了形如get、set的接口,充当寄存器的作用存放着那些任务队列function DefaultRegistry() {  if (this instanceof DefaultRegistry === false) {    return new DefaultRegistry();  }  this._tasks = {};}// 可能是初始化的作用DefaultRegistry.prototype.init = function init(taker) {};// 从上边的_tasks对象中去key=name的那个DefaultRegistry.prototype.get = function get(name) {  return this._tasks[name];};// set的时候,针对传入的name作为key,存放相应的处理方法fnDefaultRegistry.prototype.set = function set(name, fn) {  return this._tasks[name] = fn;};DefaultRegistry.prototype.tasks = function tasks() {  var self = this;  // 接收一个函数作为累加器-&gt;扩展-&gt;reduce()的用法  return Object.keys(this._tasks).reduce(function(tasks, name) {    tasks[name] = self.get(name);    return tasks;  }, {});  // {}将作为tasks的初始值-&gt;也就是=&gt; 相当于令一开始的  tasks={},  最终返回};module.exports = DefaultRegistry;</code></pre><p>undertaker-registry方法，增加在其构造函数中创建一个空对象_tasks = {}</p><p>并且在其原型链上提供了四个方法</p><ul><li>init</li><li>get</li><li>set</li><li>tasks</li></ul><p>也就是定义了一个内部属性_registry作为寄存器<strong>注册/寄存器模式的实现，提供统一接口来存储和读取 tasks</strong></p><h3 id="回到undertaker-index-js"><a href="#回到undertaker-index-js" class="headerlink" title="回到undertaker-index.js"></a>回到undertaker-index.js</h3><pre><code>// 允许用户自定义的寄存器任务  if (customRegistry) {    this.registry(customRegistry);  }</code></pre><p>接下来的这一句：</p><p>是根据前部引入的来实现的，那么它具体实现了什么功能呢？</p><pre><code>var registry = require(&#39;./lib/registry&#39;);</code></pre><p>我们接下来看一下 =&gt; </p><h2 id="三、-lib-registry"><a href="#三、-lib-registry" class="headerlink" title="三、 ./lib/registry"></a>三、 ./lib/registry</h2><pre><code>function setTasks(inst, task, name) {  inst.set(name, task);  return inst;}function registry(newRegistry) {  if (!newRegistry) {    return this._registry;  }  //验证是否有效，主要判断是否带有 .get/.set/.tasks/.init 接口，若不符合则抛出错误  validateRegistry(newRegistry);  var tasks = this._registry.tasks();  //将现有 tasks 拷贝到新的寄存器上  this._registry = reduce(tasks, setTasks, newRegistry);  //调用初始化接口（无论是否需要，寄存器务必带有一个init接口）  this._registry.init(this);}module.exports = registry;</code></pre><p>至此，将来逐步分析其余各任务方法模块的作用</p><p>其中包括</p><p>Undertaker.prototype.tree = tree; </p><p>Undertaker.prototype.task = task; </p><p>Undertaker.prototype.series = series;</p><p>Undertaker.prototype.lastRun = lastRun;</p><p>Undertaker.prototype.parallel = parallel;</p><p>Undertaker.prototype.registry = registry;</p><p>Undertaker.prototype._getTask = _getTask;</p><p>Undertaker.prototype._setTask = _setTask;</p><p>将按以下顺序进行 =&gt; </p><p><strong>/lib/set-task</strong></p><p><strong>/lib/get-task</strong></p><p><strong>/lib/last-run</strong></p><p><strong>/lib/task</strong></p><p><strong>/lib/tree</strong></p><p><strong>/lib/series</strong></p><p><strong>/lib/parallel</strong></p><h2 id="四、-lib-set-task"><a href="#四、-lib-set-task" class="headerlink" title="四、./lib/set-task"></a>四、./lib/set-task</h2><p>set-task</p><pre><code>&#39;use strict&#39;;var assert = require(&#39;assert&#39;);var metadata = require(&#39;./helpers/metadata&#39;);/*var WM = require(&#39;es6-weak-map&#39;);var metadata = new WM();=&gt;ES6中的WeakMap新类型,在其中引用的对象不计入垃圾回收机制,例如书中讲可用于存放一些DOM相关对象=&gt;此处为什么用WeakMap不用Map,可能是方便任务执行结束,有效清理内存提供get、set等方法*/// set方法采用了map(WeakMap)的数据类型进行存放// 暴露了一个set方法function set(name, fn) {  // 其中对task第一个参数的name进行类型判断=&gt;错误则报  assert(name, &#39;Task name must be specified&#39;);  assert(typeof name === &#39;string&#39;, &#39;Task name must be a string&#39;);  assert(typeof fn === &#39;function&#39;, &#39;Task function must be specified&#39;);  // 绑定this, 在this中使用参数 fn 对象的方法以及参数  // 因为WeakMap中要求的key对象不能被引用过  function taskWrapper() {    // 返回一个新包装this后的函数    return fn.apply(this, arguments);  }  function unwrap() {    // 返回原本的fn函数方法    return fn;  }  // 将name、fn包装  taskWrapper.unwrap = unwrap;  taskWrapper.displayName = name;  // 打印一下输出是什么 =&gt;   console.log(`taskWrapper： ${taskWrapper}`)  var meta = metadata.get(fn) || {};  // 打印一下输出是什么 =&gt;   console.log(`meta: ${meta}`)  var nodes = [];  if (meta.branch) {    nodes.push(meta.tree);  }  var task = this._registry.set(name, taskWrapper) || taskWrapper;  // 打印一下输出是什么 =&gt;   console.log(`task: ${task}`)  // 存入WeakMap对象  metadata.set(task, {    name: name,    orig: fn,    tree: {      label: name,      type: &#39;task&#39;,      nodes: nodes,    },  });  // 打印一下输出是什么 =&gt;   console.log(`metadata: ${metadata.get(task)}`)}module.exports = set;</code></pre><h2 id="五、-lib-get-task"><a href="#五、-lib-get-task" class="headerlink" title="五、./lib/get-task"></a>五、./lib/get-task</h2><p>get-task方法模块代码很简单</p><pre><code>&#39;use strict&#39;;// 也就是对undertaker-registry中的get方法提取function get(name) {  // 从_registry寄存器中get  return this._registry.get(name);}module.exports = get;</code></pre><h2 id="六、-lib-last-run"><a href="#六、-lib-last-run" class="headerlink" title="六、./lib/last-run"></a>六、./lib/last-run</h2><p>用来记录和获取针对某个方法的执行前/后时间</p><pre><code>&#39;use strict&#39;;// npm中其介绍的功能为,记录函数的时间点 =&gt; 对metadata对象的属性一顿操作var retrieveLastRun = require(&#39;last-run&#39;);var metadata = require(&#39;./helpers/metadata&#39;);function lastRun(task, timeResolution) {  if (timeResolution == null) {    timeResolution = process.env.UNDERTAKER_TIME_RESOLUTION;  }  var fn = task;  if (typeof task === &#39;string&#39;) {    fn = this._getTask(task);  }  var meta = metadata.get(fn);  if (meta) {    fn = meta.orig || fn;  }  return retrieveLastRun(fn, timeResolution);}module.exports = lastRun;</code></pre><h2 id="七、-lib-tree"><a href="#七、-lib-tree" class="headerlink" title="七、./lib/tree"></a>七、./lib/tree</h2><p>通过遍历metadata，获取当前注册过的所有任务的metadata</p><pre><code>&#39;use strict&#39;;var defaults = require(&#39;object.defaults&#39;);var map = require(&#39;collection-map&#39;);var metadata = require(&#39;./helpers/metadata&#39;);// 可用于获取当前注册过的所有任务的metadata-WeakMap// 也就是说,可以获取到当前我们定义了那些任务,对应方法,任务间依赖等关系function tree(opts) {  // 此方法会覆盖判断是否存在opts,并覆盖其中的{deep: false}  opts = defaults(opts || {}, {    deep: false,  });  // 获取寄存器中的tasks  var tasks = this._registry.tasks();  // 遍历tasks并且返回WeakMap(metadata)的“任务数组”   var nodes = map(tasks, function(task) {    var meta = metadata.get(task);    if (opts.deep) {      return meta.tree;    }    return meta.tree.label;  });  return {    label: &#39;Tasks&#39;,    nodes: nodes,  };}module.exports = tree;/*var undertaker = require(&#39;undertaker&#39;);ut = new undertaker();ut.task(&#39;taskA&#39;, function(cb){console.log(&#39;A&#39;); cb()});ut.task(&#39;taskB&#39;, function(cb){console.log(&#39;B&#39;); cb()});ut.task(&#39;taskC&#39;, function(cb){console.log(&#39;C&#39;); cb()});ut.task(&#39;taskD&#39;, function(cb){console.log(&#39;D&#39;); cb()});ut.task(&#39;taskE&#39;, function(cb){console.log(&#39;E&#39;); cb()});ut.task(&#39;taskC&#39;, ut.series(&#39;taskA&#39;, &#39;taskB&#39;));ut.task(&#39;taskE&#39;, ut.parallel(&#39;taskC&#39;, &#39;taskD&#39;));var tree = ut.tree();console.log(tree);*/</code></pre><h2 id="八、-lib-task"><a href="#八、-lib-task" class="headerlink" title="八、./lib/task"></a>八、./lib/task</h2><p>使用举例：</p><pre><code>gulp.task(&#39;css_comm&#39;, function() {  return gulp.src([&#39;1.css&#39;,&#39;2.css&#39;])      .pipe(concat(&#39;common.css&#39;))      .pipe(gulp.dest(&#39;./build/css&#39;))});</code></pre><pre><code>&#39;use strict&#39;;function task(name, fn) {  // 此处 if判断 写法为处理“新”打包写法  /*  function uglify(){    return gulp.src([&#39;src/*.js&#39;])        .pipe(uglify())        .pipe(gulp.dest(&#39;dist&#39;));  }  gulp.task(uglify);  */  if (typeof name === &#39;function&#39;) {    fn = name;    name = fn.displayName || fn.name;  }  // 当第二个参数为为空不存在时，即是对相应任务的获取----配合上一段  if 一起看  /*    gulp.task(&#39;css_comm&#39;, function() {    });  */  if (!fn) {    return this._getTask(name);  }  // 调整好关系,再次存入task  this._setTask(name, fn);  // console.log(`name: ${name}, fn: ${fn}`)  /*此两处的_getTask和_setTask=&gt;可以看一下,类似于一开始DefaultRegistry中对tasks中    任务的操作(get\set)  */}module.exports = task;</code></pre><h2 id="九、-lib-parallel"><a href="#九、-lib-parallel" class="headerlink" title="九、./lib/parallel"></a>九、./lib/parallel</h2><p>this.parallel的使用 =&gt;</p><pre><code>var undertaker = require(&#39;undertaker&#39;);ut = new undertaker();  ut.task(&#39;taskA&#39;, function(){});  ut.task(&#39;taskB&#39;, function(){});  ut.task(&#39;taskC&#39;, function(){});  ut.task(&#39;taskD&#39;, function(){});// taskD 需要在 &#39;taskA&#39;, &#39;taskB&#39;, &#39;taskC&#39; 执行完毕后才开始执行，// 其中 &#39;taskA&#39;, &#39;taskB&#39;, &#39;taskC&#39; 的执行是异步的ut.task(&#39;taskD&#39;, ut.parallel(&#39;taskA&#39;, &#39;taskB&#39;, &#39;taskC&#39;));</code></pre><p><strong>那让我们来看一下parallel中分别实现了些什么吧！</strong></p><pre><code>&#39;use strict&#39;;var bach = require(&#39;bach&#39;);var metadata = require(&#39;./helpers/metadata&#39;);var buildTree = require(&#39;./helpers/buildTree&#39;);var normalizeArgs = require(&#39;./helpers/normalizeArgs&#39;);var createExtensions = require(&#39;./helpers/createExtensions&#39;);function parallel() {  var create = this._settle ? bach.settleParallel : bach.parallel;  // 根据“任务”数组从寄存器中获取展开的任务数组  var args = normalizeArgs(this._registry, arguments);  // 为对象扩展新“”对象  var extensions = createExtensions(this);  // 将参数与扩展的对象(after,before,create,error)做关联  // 所以我们来看一下它具体实现了些什么 =&gt;   // bach.settleParallel+  (args, extensions) : bach.parallel(args, extensions)  var fn = create(args, extensions);  fn.displayName = &#39;&lt;parallel&gt;&#39;;  metadata.set(fn, {    name: fn.displayName,    branch: true,    tree: {      label: fn.displayName,      type: &#39;function&#39;,      branch: true,      nodes: buildTree(args),    },  });  return fn;}module.exports = parallel;</code></pre><p>让我们从上到下的分析一下</p><pre><code>// 根据“任务”数组从寄存器中获取展开的任务数组var args = normalizeArgs(this._registry, arguments);</code></pre><p><strong>normalizeArgs</strong> 方法是来源于模块 <strong>./helpers/normalizeArgs</strong></p><p>那让我们转向来看一下此模块</p><h3 id="九-1-、normalizeArgs"><a href="#九-1-、normalizeArgs" class="headerlink" title="九(1)、normalizeArgs"></a>九(1)、normalizeArgs</h3><pre><code>&#39;use strict&#39;;// nODE的断言测试var assert = require(&#39;assert&#39;);// 类似于Array.map()的改进版本=&gt;最终返回的也是数组/*:npm中的讲解map([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], function(ele, i) {  return i + ele;});//=&gt; [&#39;0a&#39;, &#39;1b&#39;, &#39;2c&#39;]*/var map = require(&#39;arr-map&#39;);// 将数组展开为平面数组,解除嵌套/*flatten([&#39;a&#39;, [&#39;b&#39;, [&#39;c&#39;]], &#39;d&#39;, [&#39;e&#39;]]);//=&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]*/var flatten = require(&#39;arr-flatten&#39;);// 接收到寄存器以及相应的“任务数组”function normalizeArgs(registry, args) {  // 传递入一个一个的“任务”方法  function getFunction(task) {    // task类型判断    if (typeof task === &#39;function&#39;) {      return task;    }    // 从我们寄存器中找到有没有这个key的function,因为存在旧的写法----不知是否有理解错    /*    gulp.task(&#39;uglify&#39;, function(){        return gulp.src([&#39;src/*.js&#39;])            .pipe(uglify())            .pipe(gulp.dest(&#39;dist&#39;));    });    gulp.task(&#39;default&#39;, [&#39;uglify&#39;]);    =&gt;上面的一开始给registry传入的是一个uglify的key    */    var fn = registry.get(task);    // 错误处理    assert(fn, &#39;Task never defined: &#39; + task);    // 回    return fn;  }  // “任务数组”展开  var flattenArgs = flatten(args);  // 根据长度,判断是否写空了  assert(flattenArgs.length, &#39;One or more tasks should be combined using series or parallel&#39;);  // 对“任务数组”的任务进行方法的遍历  return map(flattenArgs, getFunction);}module.exports = normalizeArgs;</code></pre><p>//通过参数获取存在寄存器（registry）中的 taskFunctions（数组形式）<br>var args = normalizeArgs(this._registry, arguments);</p><p><strong>接下来我们继续阅读下一句：</strong><br>var extensions = createExtensions(this);</p><p>而<strong>createExtensions</strong>是来源于模块<strong>helpers/createExtensions</strong></p><p>那么我们看一下其中实现了什么 = ?</p><h3 id="九-2-、createExtensions"><a href="#九-2-、createExtensions" class="headerlink" title="九(2)、createExtensions"></a>九(2)、createExtensions</h3><pre><code>&#39;use strict&#39;;// 使用某函数,并记录捕获当前时间戳或者传入时间戳var captureLastRun = require(&#39;last-run&#39;).capture;// 获取一个function并删除最后一次运行时时间戳var releaseLastRun = require(&#39;last-run&#39;).release;var metadata = require(&#39;./metadata&#39;);var uid = 0;function Storage(fn) {  var meta = metadata.get(fn);  this.fn = meta.orig || fn;  this.uid = uid++;  this.name = meta.name;  this.branch = meta.branch || false;  this.captureTime = Date.now();  this.startHr = [];}Storage.prototype.capture = function() {  captureLastRun(this.fn, this.captureTime);};Storage.prototype.release = function() {  releaseLastRun(this.fn);};function createExtensions(ee) {  return {    create: function(fn) {      // 调用create时候,记录一下相关信息,并返回      return new Storage(fn);    },    before: function(storage) {      // Node获取相对于过去某一刻的时间      storage.startHr = process.hrtime();      // Node触发start事件,后面为参数      ee.emit(&#39;start&#39;, {        uid: storage.uid,        name: storage.name,        branch: storage.branch,        time: Date.now(),      });    },    after: function(result, storage) {      // 调用时判断是否有错,有则爆      if (result &amp;&amp; result.state === &#39;error&#39;) {        return this.error(result.value, storage);      }      // 记录当前时间戳      storage.capture();      // Node触发stop事件      ee.emit(&#39;stop&#39;, {        uid: storage.uid,        name: storage.name,        branch: storage.branch,        duration: process.hrtime(storage.startHr),        time: Date.now(),      });    },    error: function(error, storage) {      if (Array.isArray(error)) {        error = error[0];      }      // 删除出错的此次执行时间戳      storage.release();      ee.emit(&#39;error&#39;, {        uid: storage.uid,        name: storage.name,        branch: storage.branch,        error: error,        duration: process.hrtime(storage.startHr),        time: Date.now(),      });    },  };}module.exports = createExtensions;</code></pre><p>此方法扩展，为变量新增拥有<strong>create</strong>、<strong>before</strong>、<strong>after</strong>、<strong>error</strong>等方法的一个对象</p><p>最终期望将扩展出来的对象与我们的“任务”task关联</p><p><strong>接着我们来看下一句:</strong></p><p>var fn = create(args, extensions);</p><p>create =&gt; var create = this._settle ? bach.settleParallel : bach.parallel;</p><p><strong>bach</strong>模块来源于<strong>bach</strong></p><p>接下来我们再来看一下bach模块实现了些什么 =&gt; ?</p><h3 id="九-3-、bach"><a href="#九-3-、bach" class="headerlink" title="九(3)、bach"></a>九(3)、bach</h3><pre><code>module.exports = {  series: require(&#39;./lib/series&#39;),  parallel: require(&#39;./lib/parallel&#39;),  settleSeries: require(&#39;./lib/settleSeries&#39;),  settleParallel: require(&#39;./lib/settleParallel&#39;),};</code></pre><p>而我们所需要用的的parallel是来源于<strong>lib/parallel</strong></p><p>而<strong>lib/parallel</strong>具体代码如下:</p><pre><code>&#39;use strict&#39;;// 对数组取值操作,取第一及最后一个var initial = require(&#39;array-initial&#39;);var last = require(&#39;array-last&#39;);// 用于异步化函数var asyncDone = require(&#39;async-done&#39;);var nowAndLater = require(&#39;now-and-later&#39;);var helpers = require(&#39;./helpers&#39;);function iterator(fn, key, cb) {  // 那asyncDone又是做什么的呢 =&gt; ?  // 传入一个方法与回调  return asyncDone(fn, cb);}function buildParallel() {  // 校验传入参数(arguments的合法性)  var args = helpers.verifyArguments(arguments);  // 取到最后一个参数,即传入时的extensions,然后执行此方法  // 如果最后一个参数!==function则return 回  var extensions = helpers.getExtensions(last(args));  if (extensions) {    // 如果扩展对象存在,取第一个参数    args = initial(args);  }  // 我们具体来看一下nowAndLater.map做了什么 =&gt;   function parallel(done) {    /*    传入了四个值(args, function iterator(fn, key, cb) {return asyncDone(fn, cb);}, 扩展的对象, done)    */    nowAndLater.map(args, iterator, extensions, done);    //遍历tasks数组，将其生命周期和extensions属性关联起来,且将每个task异步化，且并发执行  }  return parallel;}module.exports = buildParallel;</code></pre><p>这一段代码中所用的的重要方法函数有这些：</p><pre><code>function iterator(fn, key, cb) {  return asyncDone(fn, cb);}/*...省略*/function parallel(done) {  nowAndLater.map(args, iterator, extensions, done);}</code></pre><p>首先可以让我们来看一下<strong>async-Done</strong>分别做了什么 =&gt; ？</p><h3 id="九-4-async-Done"><a href="#九-4-async-Done" class="headerlink" title="九(4)async-Done"></a>九(4)async-Done</h3><p>它可以把一个普通函数（传入的第一个参数）异步化</p><pre><code>//demo1var asyncDone = require(&#39;async-done&#39;);asyncDone(function(done){    console.log(&#39;测试AsyncDone---1--开始&#39;);    done(null, &#39;测试AsyncDone---1--结束&#39;)}, function(err, data){  //  成功执行第一个函数时，``error`将为null。  //  `result`将是第一个函数的结果。    console.log(data)});asyncDone(function(done){    console.log(&#39;测试AsyncDone---2--开始&#39;);    setTimeout( done.bind(this, null, &#39;测试AsyncDone---2--结束&#39;), 1000 )}, function(err, data){    console.log(data)});asyncDone(function(done){    console.log(&#39;测试AsyncDone---3--开始&#39;);    done(null, &#39;测试AsyncDone---3--结束&#39;)}, function(err, data){    console.log(data)});</code></pre><p><strong>执行的结果 :</strong></p><ul><li>测试AsyncDone—1–开始</li><li>测试AsyncDone—1–结束</li><li>测试AsyncDone—2–开始</li><li>测试AsyncDone—3–开始</li><li>测试AsyncDone—3–结束</li><li>测试AsyncDone—2–结束</li></ul><p>其中第一个参数方法中的done将会提醒第二个参数(callback)去执行相关回调</p><p><strong>接下来我们我们再来看一下parallel的重要部分 :</strong></p><pre><code>function parallel(done) {nowAndLater.map(args, iterator, extensions, done);}</code></pre><p>而nowAndLater的模块接口来源于<strong>now-and-later</strong></p><p>那我们再来看一下<strong>now-and-later</strong>实现了些什么呢?</p><h3 id="九-5-、now-and-later"><a href="#九-5-、now-and-later" class="headerlink" title="九(5)、now-and-later"></a>九(5)、now-and-later</h3><pre><code>var once = require(&#39;once&#39;);var helpers = require(&#39;./helpers&#39;);function map(values, iterator, extensions, done) {    if (typeof extensions === &#39;function&#39;) {        done = extensions;        extensions = {};    }    if (typeof done !== &#39;function&#39;) {        done = helpers.noop;  //没有传入done则赋予一个空函数    }    //让 done 函数只执行一次    done = once(done);    var keys = Object.keys(values);    var length = keys.length;    var count = length;    var idx = 0;    // 初始化一个空的、和values等长的数组    var results = helpers.initializeResults(values);    /**     * helpers.defaultExtensions(extensions) 返回如下对象：     *  {            create: extensions.create || defaultExts.create,            before: extensions.before || defaultExts.before,            after: extensions.after || defaultExts.after,            error: extensions.error || defaultExts.error,        }     */    var exts = helpers.defaultExtensions(extensions);    for (idx = 0; idx &lt; length; idx++) {        var key = keys[idx];        next(key);    }    function next(key) {        var value = values[key];        //创建一个 Storage 实例        var storage = exts.create(value, key) || {};        //触发&#39;start&#39;事件        exts.before(storage);        //利用 async-done 将 taskFunction 转为异步方法并执行        iterator(value, once(handler));        function handler(err, result) {            if (err) {                //触发&#39;error&#39;事件                exts.error(err, storage);                return done(err, results);            }            //触发&#39;stop&#39;事件            exts.after(result, storage);            results[key] = result;            if (--count === 0) {                done(err, results);            }        }    }}module.exports = map;</code></pre><p>在这段代码的 map 方法中，通过 for 循环遍历了每个传入 parallel 接口的 taskFunction，然后使用 iterator（async-done）将 taskFunction 异步化并执行（执行完毕会触发 hadler），并将 extensions 的各方法和 task 的生命周期关联起来（比如在任务开始时执行“start”事件、任务出错时执行“error”事件）。 ——[引用自vaoy博客说明]</p><h2 id="十、-lib-series"><a href="#十、-lib-series" class="headerlink" title="十、./lib/series"></a>十、./lib/series</h2><p>series接口的使用:</p><pre><code>ut.task(&#39;taskA&#39;, function(){/*略*/});  ut.task(&#39;taskB&#39;, function(){/*略*/});  ut.task(&#39;taskC&#39;, function(){/*略*/});  ut.task(&#39;taskD&#39;, function(){/*略*/});// taskD 需要在 &#39;taskA&#39;, &#39;taskB&#39;, &#39;taskC&#39; 执行完毕后才开始执行，// 其中 &#39;taskA&#39;, &#39;taskB&#39;, &#39;taskC&#39; 的执行必须是按顺序一个接一个的  ut.task(&#39;taskD&#39;, ut.series(&#39;taskA&#39;, &#39;taskB&#39;, &#39;taskC&#39;));</code></pre><p>其实现和parallel是基本一致的，但在series中使用的是nowAndlater的mapSeries接口</p><pre><code>next(key);    function next(key) {        var value = values[key];        var storage = exts.create(value, key) || {};        exts.before(storage);        iterator(value, once(handler));        function handler(err, result) {            if (err) {                exts.error(err, storage);                return done(err, results); //有任务出错，故所有任务应停止调用            }            exts.after(result, storage);            results[key] = result;            if (++idx &gt;= length) {                done(err, results); //全部任务已经结束了            } else {                next(keys[idx]);  //next不在是放在外面的循环里，而是在任务的回调里            }        }    }</code></pre><p>此处在series接口中通过改动 next 的位置，可以很好地要求传入的任务必须一个接一个去执行（后一个任务在前一个任务执行完毕的回调里才会开始执行）。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gulp </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gulp源码分析学习(一</title>
      <link href="/2019/04/05/2019/Gulp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0-%E4%B8%80/"/>
      <url>/2019/04/05/2019/Gulp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p align="center"><br>  <a href="https://gulpjs.com" target="_blank" rel="noopener"><br>    <img height="257" width="114" src="https://raw.githubusercontent.com/gulpjs/artwork/master/gulp-2x.png"><br>  </a><br></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>目前工作会依赖于Gulp进行项目的构建打包，也为了可以有更深入的学习心得与收获。因此在此记录对于<em>Gulp</em>源码的阅读、及个人理解</p><p>在总结的markdown 与 <strong>个人博客</strong> 有相关系列文章，在此项目各文件夹的源码中也有相应的源码分析的注释</p><p><em>版本 </em><br><strong>gulp： ^4.0.0 版本为例</strong></p><h2 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h2><a id="more"></a><p>源码相关：</p><ul><li><p>gulp主入口分析—<a href="https://github.com/Jayantxu/gulp-source/tree/master/gulp" target="_blank" rel="noopener">gulp-index.js</a></p></li><li><p>glob-watcher模块分析—<a href="https://github.com/Jayantxu/gulp-source/tree/master/glob-watcher" target="_blank" rel="noopener">glob-watcher-index.js</a></p></li><li><p>undertaker模块分析—<a href="https://github.com/Jayantxu/gulp-source/tree/master/undertaker" target="_blank" rel="noopener">undertaker-index.js</a></p></li><li><p>vinyl-fs模块分析—<a href="https://github.com/Jayantxu/gulp-source/tree/master/vinyl-fs" target="_blank" rel="noopener">vinyl-fs-index.js</a></p></li></ul><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>此篇分析有内容借鉴于前辈的gulp源码分析博客，深表感谢，在此说明：</p><p><a href="https://www.cnblogs.com/vajoy/p/6349817.html" target="_blank" rel="noopener">gulp源码解析 系列</a></p><p>同时也推荐一个收集丰富gulp资料的GH项目，作为学习之用：</p><p><a href="https://github.com/Platform-CUF/use-gulp" target="_blank" rel="noopener">use-gulp</a></p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>作者： JayantXu</p><p>邮箱： <a href="mailto:Jayant89@163.com" target="_blank" rel="noopener">Jayant89@163.com</a></p><p>个人博客： <a href="www.essssss.com">Jayantxu</a></p><p>Github(若对您有所帮助,感谢star)   - ：<a href="https://github.com/Jayantxu/gulp-source" target="_blank" rel="noopener">GitHub</a> </p><p>第一次写源码分析系列，若有不足之处请谅解，对任何内容有所疑问，欢迎联系我。</p><hr><h2 id="gulp-index-js的分析"><a href="#gulp-index-js的分析" class="headerlink" title="gulp-index.js的分析:"></a>gulp-index.js的分析:</h2><h2 id="gulp基本使用"><a href="#gulp基本使用" class="headerlink" title="gulp基本使用"></a>gulp基本使用</h2><p><a href="https://www.gulpjs.com.cn/docs/api/" target="_blank" rel="noopener">gulp-api介绍</a></p><h2 id="入口文件分析"><a href="#入口文件分析" class="headerlink" title="入口文件分析"></a>入口文件分析</h2><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>可以在本文件目录下寻找到index.js，接下来让我们看一下其中都有什么内容 =&gt;</p><pre><code>&#39;use strict&#39;;var util = require(&#39;util&#39;); var Undertaker = require(&#39;undertaker&#39;);var vfs = require(&#39;vinyl-fs&#39;);var watch = require(&#39;glob-watcher&#39;);function Gulp() {  Undertaker.call(this);  // Bind the functions for destructuring  this.watch = this.watch.bind(this);  this.task = this.task.bind(this);  this.series = this.series.bind(this);  this.parallel = this.parallel.bind(this);  this.registry = this.registry.bind(this);  this.tree = this.tree.bind(this);  this.lastRun = this.lastRun.bind(this);}util.inherits(Gulp, Undertaker);Gulp.prototype.src = vfs.src;Gulp.prototype.dest = vfs.dest;Gulp.prototype.symlink = vfs.symlink;Gulp.prototype.watch = function(glob, opt, task) {};// Let people use this class from our instanceGulp.prototype.Gulp = Gulp;var inst = new Gulp();module.exports = inst;</code></pre><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>让我们由上到下的看一遍：</p><p>其中，声明了所需要加载的依赖包</p><pre><code>// Node内部util模块，是Node中一个核心的工具函数模块var util = require(&#39;util&#39;); // 执行任务管理有关的逻辑,---&gt; gulp.task()var Undertaker = require(&#39;undertaker&#39;);// vinyl-fs模块: src/dest/symlinkvar vfs = require(&#39;vinyl-fs&#39;);// npm中介绍为 ： 观察全局并在更改时执行功能，具有用于去抖动和排队的智能默认值。var watch = require(&#39;glob-watcher&#39;);</code></pre><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>我们接下去看一下<strong>Gulp</strong>这个方法中实现了什么功能</p><pre><code>function Gulp() {  // 转this,将Undertaker的方法绑定到this中  Undertaker.call(this);  // 绑定函数为解构  this.watch = this.watch.bind(this);  this.task = this.task.bind(this);  this.series = this.series.bind(this);  this.parallel = this.parallel.bind(this);  this.registry = this.registry.bind(this);  this.tree = this.tree.bind(this);  this.lastRun = this.lastRun.bind(this);}</code></pre><p>我们可以在此看到我们所用到的gulp.task\gulp.series等方法都是来源于<font color="ff0000"><strong>undertaker</strong></font>这个模块</p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><pre><code>// 继承,(构造函数,父类构造函数)util.inherits(Gulp, Undertaker);</code></pre><p>util是Node中的核心工具函数模块，其中的inherits是实现继承的一种方法</p><p><a href="http://nodejs.cn/api/util.html#util_util_inherits_constructor_superconstructor" target="_blank" rel="noopener">Node-Api-util.inherits</a></p><p>其中传入的参数为(子类构造函数, 父类构造函数)</p><h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><pre><code>Gulp.prototype.src = vfs.src;Gulp.prototype.dest = vfs.dest;Gulp.prototype.symlink = vfs.symlink;Gulp.prototype.watch = function(glob, opt, task) {  // 省略些许代码---后续涉及此部分将再提及};// Let people use this class from our instanceGulp.prototype.Gulp = Gulp;</code></pre><p>第五部分的代码既是将在Gulp的原型peototype上增加部分方法，且来源于<font color="ff0000"><strong>vinyl-fs</strong></font>这个模块</p><h2 id="六"><a href="#六" class="headerlink" title="六"></a>六</h2><pre><code>var inst = new Gulp();module.exports = inst;</code></pre><p>最后一块即是new一个Gulp的实例，并将其暴露出来供调用使用</p><h2 id="七"><a href="#七" class="headerlink" title="七"></a>七</h2><p>由此</p><p>我们可以知道我们需要了解gulp的内部执行机制以及流程，我们需要关注于</p><pre><code>undertaker、vinyl-fs、glob-watcher</code></pre><p>这三模块分别都将实现什么功能。</p><hr><h4 id="题外-gt"><a href="#题外-gt" class="headerlink" title="题外-&gt;"></a>题外-&gt;</h4><h5 id="util-inherits实现了什么？"><a href="#util-inherits实现了什么？" class="headerlink" title="util.inherits实现了什么？"></a>util.inherits实现了什么？</h5><pre><code>var util = require(&#39;util&#39;); function Base() {     this.name = &#39;base&#39;;     this.base = 1991;     this.sayHello = function() {     console.log(&#39;Hello &#39; + this.name);     }; } Base.prototype.showName = function() {     console.log(this.name);}; function Sub() {     this.name = &#39;sub&#39;; } util.inherits(Sub, Base); var objBase = new Base(); objBase.showName();  // baseobjBase.sayHello(); // Hello baseconsole.log(objBase);  // Base()var objSub = new Sub(); objSub.showName();  // sub// objSub.sayHello();  // is not a functionconsole.log(objSub);</code></pre><p>在网上寻找的测试，inherits是通过将父类构造函数的原型链复制到子类的原型链上，进而实现的继承，因此我们也只能继承到相应原型链上的方法</p><pre><code>exports.inherits = function(ctor, superCtor) {  // 一些参数的合法性判断，略……  ctor.super_ = superCtor;  ctor.prototype = Object.create(superCtor.prototype, {    constructor: {      value: ctor,      enumerable: false,      writable: true,      configurable: true    }  });};同时继承的子类也可以通过super_访问到父类的构造函数console.log(Sub.super_ === Base) // true</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gulp </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node读取图片并转Base64</title>
      <link href="/2019/03/30/2019/Node%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87%E5%B9%B6%E8%BD%ACBase64/"/>
      <url>/2019/03/30/2019/Node%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87%E5%B9%B6%E8%BD%ACBase64/</url>
      
        <content type="html"><![CDATA[<p>Node作为后端开发时，可以采用读取图片文件，并转为base64编码，使得前端得到展示</p><p>运用到的模块分别有<strong>fs</strong>、<strong>path</strong>、<strong>mime-types</strong></p><p>mime-type需要额外安装，可于项目根目录运行：</p><pre><code>npm install --save mime-type</code></pre><p>并且考虑到后续的读取转化的需要，可将方法使用promise异步，并且在数量不定时可以使用<em>promise.all()</em>进行异步等待</p><pre><code>const fs = require(&#39;fs&#39;)const path = require(&#39;path&#39;)const mineType = require(&#39;mime-types&#39;)module.exports = {  base64img: function (file) {    var base64imgpromise = new Promise(function (resolve, reject) {      var result      // 判断传入路径是否为空，空即不存在      if (!file) {        result = &#39;&#39;        resolve(result)      }      // 转换路径      file = path.join(__dirname, &#39;../&#39;, file)      let filePath = path.resolve(file)      fs.readFile(path.resolve(filePath), &#39;base64&#39;, function (err, data) {        if (err) {          console.log(err + &#39;读取错误&#39;)          result = {            code: &#39;1&#39;,            data: {            },            msg: &#39;服务器出错&#39;          }          reject(result)        }        result = &#39;data:&#39; + mineType.lookup(filePath) + &#39;;base64,&#39; + data        resolve(result)      })    })    return base64imgpromise  }}</code></pre><p>当最终我们得到了base64编码的图片后，既可以发送回前端，对img标签的src进行绑定base64，从而在前端页面展示</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Grid布局</title>
      <link href="/2019/03/26/2019/Grid%E5%B8%83%E5%B1%80/"/>
      <url>/2019/03/26/2019/Grid%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>昨天看见阮大神的博客更新Grid布局的相关知识总结，学习相关的知识点</p><font><strong>原文链接：</strong></font> <a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">阮一峰-Grid布局</a><br><a id="more"></a><br><br><font><strong>个人练习小demo：</strong></font><pre><code>&lt;!--    网格Grid布局    --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;网格Grid布局&lt;/title&gt;    &lt;style&gt;        *{            padding: 0;            margin: 0;        }        .container{            display: grid;    /*行内的grid布局*/            grid-template-columns: 100px 100px 100px;            grid-template-rows: 100px 100px 100px;            grid-column-gap: 10px;            grid-row-gap: 10px;            justify-content: center;            grid-auto-flow: row;    /*布局基准，按行还是列*/            /* grid-template-areas:&#39;header header header&#39;                                                    &#39;main main aside&#39;                                                    &#39;footer footer footer&#39;; */            /*            align-items:center 设置单元格内容的垂直位置;            justify-items: 设置单元格内容的水平位置;            place-items: 合并简写了上述两个;                        place-items: &lt;align-items&gt; &lt;justify-items&gt;;             */            /*             align-content: 设置整个内容区域在grid容器里的垂直位置;            justify-content: 设置整个内容区域在grid容器里的水平位置;            place-content: 合并前两者; */        }        .item-a{            background-color: pink;            /*从第几条网格线开始，到第几条网格线结束*/            grid-column-start: 1;            /*左边框的起始线*/            grid-column-end: 3;            /* 右边框的结束线 */            /* 同理有上下：grid-row-start; grid-row-end */            /* justify-self: 设置单元格内容的水平位置;与justice-items作用一致,但只控制单个项目;            align-self: 设置单元格内容的垂直位置;与align-items作用一致,但只控制单个项目;            place-self: 前两者的合并写法; */        }        .item-b{            background-color: red;        }        .item-c{            background-color: blue;            /*缩写版：从第几条开始，到第几条结束*/            grid-row: 2/4;        }        .item-d{            background-color: yellow;            grid-column: 2/4;        }        .item-e{            background-color: black;            color: white;        }        .item-f{            background-color: grey;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;span&gt;foo&lt;/span&gt;    &lt;div class=&#39;container&#39;&gt;        &lt;div class=&quot;item-a&quot;&gt;item-a&lt;/div&gt;        &lt;div class=&quot;item-b&quot;&gt;item-b&lt;/div&gt;        &lt;div class=&quot;item-c&quot;&gt;item-c&lt;/div&gt;        &lt;div class=&quot;item-d&quot;&gt;item-d&lt;/div&gt;        &lt;div class=&quot;item-e&quot;&gt;item-d&lt;/div&gt;        &lt;div class=&quot;item-f&quot;&gt;item-d&lt;/div&gt;    &lt;/div&gt;    &lt;span&gt;bar&lt;/span&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2019/03/26/2019/Grid布局/Grid布局.png" alt="Grid布局" title="Grid布局"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 布局 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阻止冒泡、默认事件</title>
      <link href="/2019/03/03/2019/%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1%E3%80%81%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6/"/>
      <url>/2019/03/03/2019/%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1%E3%80%81%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>取消冒泡：</p><p>w3c的方法是e.stopPropagation，IE为e.cancelBubble = true<br>window.event ? window.event.cancelBubble = true : e.stopPropagation</p><p>取消默认：</p><p>w3c的方法是e.prcentDefault()，IE为e.returnValue = false<br>return false;</p><pre><code>&lt;script&gt;  function stopBubble (e) {    if(e &amp;&amp; e.stopPropagation) {      e.stopPropagation();    } else {      window.event.cancelBubble = true;    }  }  function stopDefault (e) {    if(e &amp;&amp; e.prventDefault) {      e.prventDefault();    } else {      window.event.returnValue = false;      return false;    }  }&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS清除浮动的几种方式</title>
      <link href="/2019/03/03/2019/CSS%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
      <url>/2019/03/03/2019/CSS%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>2019-3-3更新<br><a id="more"></a></p><font color="#ff0000"><strong>浮动效果重现</strong></font><pre><code>  .parent {    padding:10px;    width:1000px;    background: red;  }  .child {    float: left;    margin-right: 10px;    width: 50px;    height: 50px;    background: green;  }&lt;!-- 浮动效果 --&gt;    &lt;div class=&quot;parent&quot;&gt;        &lt;div class=&quot;child&quot;&gt; child&lt;/div&gt;        &lt;div class=&quot;child&quot;&gt; child&lt;/div&gt;        &lt;div class=&quot;child&quot;&gt; child&lt;/div&gt;    &lt;/div&gt;</code></pre><p>图：<br><img src="/2019/03/03/2019/CSS清除浮动/浮动重现.png" alt="浮动重现" title="浮动重现"></p><font color="#ff0000"><strong>清除浮动的方式1 clear:both</strong></font><pre><code>/*清除浮动方式1 clear:both*/        .parent1 {            padding:10px;            width:1000px;            margin-top: 50px;            background: red;        }        .child1 {            float: left;            margin-right: 10px;            width: 50px;            height: 50px;            background: green;        }        .clear1 {            clear: both;        }    &lt;!-- 清除浮动的方式1,使用额外标签clear:both --&gt;    &lt;div class=&quot;parent1&quot;&gt;      &lt;div class=&quot;child1&quot;&gt; child&lt;/div&gt;      &lt;div class=&quot;child1&quot;&gt; child&lt;/div&gt;      &lt;div class=&quot;child1&quot;&gt; child&lt;/div&gt;      &lt;div class=&quot;clear1&quot;&gt;&lt;/div&gt;    &lt;/div&gt;</code></pre><p>图：</p><p><img src="/2019/03/03/2019/CSS清除浮动/解决浮动的方式1.png" alt="解决浮动的方式1" title="解决浮动的方式1"></p><font color="#ff0000"><strong>清除浮动的方式2 overflow: hidden</strong></font><pre><code>/* 清除浮动方式2,overflow*/        .parent2 {            padding:10px;            width:1000px;            overflow: hidden;            margin-top: 50px;            background: red;        }        .child2 {            float: left;            margin-right: 10px;            width: 50px;            height: 50px;            background: green;        }    &lt;!-- 清除浮动方式2,使用overflow属性,定义了overflow后，浏览器会自动检查浮动区域高度 --&gt;    &lt;div class=&quot;parent2&quot;&gt;      &lt;div class=&quot;child2&quot;&gt; child&lt;/div&gt;      &lt;div class=&quot;child2&quot;&gt; child&lt;/div&gt;      &lt;div class=&quot;child2&quot;&gt; child&lt;/div&gt;      &lt;!-- 不能和position配合使用 --&gt;    &lt;/div&gt;</code></pre><p>图：</p><p><img src="/2019/03/03/2019/CSS清除浮动/解决浮动的方式1.png" alt="解决浮动的方式1" title="解决浮动的方式1"></p><font color="#ff0000"><strong>清除浮动的方式3 定义父元素伪类after清除浮动</strong></font><pre><code>/* 清除浮动方式3,:after*/        .parent3 {            padding:10px;            background: red;            margin-top: 50px;        }        .parent3:after {            content: &#39;&#39;;            display: block;            clear: both;        }        .child3 {            float: left;            margin-right: 10px;            width: 50px;            height: 50px;            background: green;        }&lt;!-- 使用伪元素清除浮动:after --&gt;    &lt;div class=&quot;parent3&quot;&gt;        &lt;div class=&quot;child3&quot;&gt; child&lt;/div&gt;        &lt;div class=&quot;child3&quot;&gt; child&lt;/div&gt;        &lt;div class=&quot;child3&quot;&gt; child&lt;/div&gt;    &lt;/div&gt;</code></pre><p><img src="/2019/03/03/2019/CSS清除浮动/解决浮动的方式1.png" alt="解决浮动的方式1" title="解决浮动的方式1"></p><hr><p>2019-2-2</p><p>经常在各种前端面试题中出现，今天就将原本CSDN博客上总结的清除浮动的方式再次回顾并且搬运过来</p><font color="ff0000"><strong>1</strong></font><p>定义伪类清除</p><pre><code>.clearfloat:after {   display: block;  clear: both;  content: &quot;&quot;;  visibility: hidden;  height: 0}</code></pre><font color="ff0000"><strong>2</strong></font><p>定义空div进行clear</p><pre><code>.clearfloat {   clear: both}</code></pre><font color="ff0000"><strong>3</strong></font><p>为父元素设置高度</p><pre><code>.div1 {  background: #000080;  border: 1px solid red;/*解决代码*/  height: 200px;}</code></pre><font color="ff0000"><strong>4</strong></font><p>为父元素设置overflow:hidden</p><pre><code>.div1 {  background: #000080;  border: 1px solid red;/*解决代码*/  width: 98%;  overflow: hidden}</code></pre><font color="ff0000"><strong>5</strong></font><p>父元素一并浮动</p><pre><code>.div1 {  background: #000080;  border: 1px solid red;/*解决代码*/  width: 98%;  margin-bottom: 10px;  float: left}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>margin重叠以及解决办法</title>
      <link href="/2019/03/01/2019/margin%E9%87%8D%E5%8F%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2019/03/01/2019/margin%E9%87%8D%E5%8F%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>先重现一遍两个块级元素在上下margin方向的重叠现象<br><a id="more"></a></p><pre><code>&lt;!-- 重现浮动 --&gt;/* 重现浮动*/.contain {    color: #fff;}.first {    margin-bottom:20px;    padding-left: 10px;    height: 200px;    width: 200px;    background-color: black;}.second {    margin-top: 20px;    height: 200px;    width: 200px;    background-color: red;}&lt;div class=&quot;contain&quot;&gt;    &lt;div class=&quot;first&quot;&gt;first &lt;/div&gt;    &lt;div class=&quot;second&quot;&gt;second  &lt;/div&gt;&lt;/div&gt;</code></pre><p><img src="/2019/03/01/2019/margin重叠以及解决办法/margin重现.png" alt="margin重现" title="margin重现"></p><p>此处我们可以看到，当第一个(first)拥有的margin-bottom：20px;与第二个(second)div块所拥有的margin-top:20px;叠加在了一块</p><p>而我们根据BFC（块级格式化上下文）我们可以在必要时候有效避免这种现象对于我们布局的影响<br>而我们创建BFC的条件有以下几种情况：</p><ul><li>float不是none，使该元素浮动起来</li><li>position的值不是static或者relative</li><li>display的值是inline-block，table-cell， flex，table-caption， inline-flex</li><li>overflow不是visible</li></ul><p>BFC的特征：</p><ul><li>所有子元素包括浮动元素，与容器左边对齐</li><li>属于同一个BFC的父元素与子元素，相邻的<strong>父子</strong>或者<strong>兄弟</strong>间的margin垂直方向会重叠，<strong>若两个元素属于不同BFC</strong>，则垂直方向上不重叠</li><li>可以撑开容器（若子元素是float，则父元素设置overflow：hidden，父元素就形成一个BFC</li></ul><p>因此我们实践尝试如何使用形成BFC解决margin重叠所带来的影响</p><font color="#ff0000"><strong>一</strong></font><pre><code>/* 清除margin方式1*/.contain1 {    color: #fff;}.first1 {    margin-bottom:20px;    padding-left: 10px;    height: 200px;    width: 200px;    background-color: yellow;}.second1 {    margin-top: 20px;    height: 200px;    width: 200px;    background-color: blue;}&lt;!-- 清除，margin重叠方式1 通过新增父元素，形成一个新的BFC块 --&gt;&lt;div class=&quot;contain1&quot;&gt;    &lt;div class=&quot;first1&quot;&gt; first 1&lt;/div&gt;    &lt;div style=&quot;overflow:hidden;&quot;&gt;        &lt;div class=&quot;second1&quot;&gt; second1&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p>效果：<br><img src="/2019/03/01/2019/margin重叠以及解决办法/margin重叠解决方式1.png" alt="margin重叠解决方式1" title="margin重叠解决方式1"></p><p>我们为second块元素，新增一个父元素，并且设置其overflow，成功使得first1与second1分别归属不同的BFC块，从而结局margin重叠问题。</p><font color="#ff0000"><strong>二</strong></font><pre><code>/* 清除margin方式2*/.contain2 {    color: #fff;    width: 200px;}.first2 {    margin-bottom:20px;    padding-left: 10px;    height: 200px;    width: 200px;    background-color: red;}.second2 {    margin-top: 20px;    height: 200px;    width: 200px;    background-color: blue;}&lt;!-- 清除margin重叠方式2，子元素浮动 :相邻的子元素都浮动，或者下面的那个浮动--&gt;&lt;div class=&quot;contain2&quot;&gt;    &lt;div class=&quot;first2&quot;&gt; first 2&lt;/div&gt;    &lt;div class=&quot;second2&quot; style=&quot;float: left;&quot;&gt; second 2&lt;/div&gt;        &lt;/div&gt;</code></pre><p>我们使得相邻兄弟元素浮动的形式，满足float不等于none，从而使得second2形成一个新的BFC块，而解决margin重叠的问题</p><p>效果：<br><img src="/2019/03/01/2019/margin重叠以及解决办法/margin重叠解决方式2.png" alt="margin重叠解决方式2" title="margin重叠解决方式2"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> CSS </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS省略号实现</title>
      <link href="/2019/03/01/2019/CSS%E7%9C%81%E7%95%A5%E5%8F%B7%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/03/01/2019/CSS%E7%9C%81%E7%95%A5%E5%8F%B7%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<font><strong>一</strong></font><a id="more"></a><pre><code>&lt;div class=&quot;contain&quot;&gt;    &lt;p class=&quot;contain-1&quot;&gt;很多很多很多很多很多很多很多文字[要有固定宽度]&lt;/p&gt;    &lt;p class=&quot;contain-2&quot;&gt;        多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本        [此设定不适合多行文本]    &lt;/p&gt;&lt;/div&gt;</code></pre><pre><code>.contain-1 {    overflow: hidden;    white-space: nowrap;    text-overflow: ellipsis;}.contain-2 {    overflow: hidden;    white-space:white-space;    text-overflow: ellipsis;}</code></pre><p>可以关注text-overflow：ellipsis；属性，此属性针对单行文本的末尾显示省略号</p><p>如图：<br><img src="/2019/03/01/2019/CSS省略号实现/CSS省略号实现1.png," alt="CSS省略号实现1.png" title="CSS省略号实现1.png"></p><font><strong>二</strong></font><p>当目标浏览器内核是webkit、或移动端为主时，可采用针对webkit的私有属性</p><pre><code>-webkit-box-orient:vertical;-webkit-line-clamp:2;</code></pre><pre><code>&lt;div class=&quot;contain1&quot;&gt;    &lt;p class=&quot;contain1-1&quot;&gt;很多很多很多很多很多很多很多文字&lt;/p&gt;    &lt;p class=&quot;contain1-2&quot;&gt;        多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本        [有适用范围,仅适用于webkit浏览器及移动端]    &lt;/p&gt;&lt;/div&gt;</code></pre><pre><code>.contain1 {    width:200px;    height: 200px;    background-color: grey;}.contain1-1 {    display: -webkit-box;    -webkit-box-orient:vertical;    -webkit-line-clamp:1;    overflow: hidden;}.contain1-2 {    display: -webkit-box;    -webkit-box-orient:vertical;    -webkit-line-clamp:2;    overflow: hidden;}</code></pre><p>可针对webkit内核的浏览器以及移动端浏览器进行省略号布局</p><p>如图:<br><img src="/2019/03/01/2019/CSS省略号实现/CSS省略号实现2.png," alt="CSS省略号实现2.png" title="CSS省略号实现2.png"></p><font><strong>三</strong></font><p>使用伪元素问题</p><pre><code>&lt;div class=&quot;contain2&quot;&gt;    &lt;p &gt;        多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本多行文本[利用伪元素,适用性广,在文字未超行的情况下也会出现省略号]    &lt;/p&gt;&lt;/div&gt;</code></pre><pre><code>.contain2 {    width:200px;    height: 200px;    background-color: grey;}.contain2 p {    position: relative;    /*需要额外注意line-height和max-height需要时line-height的整数倍,否则会造成超出文字显示一半的情况,另外如果没有这两个元素,视觉上会有“无论什么情况都带省略号的情况”*/    line-height:20px;    max-height: 40px;    overflow: hidden;}.contain2 p::after {    content: &quot;...&quot;;    position:absolute;    bottom:0;    right:0;    padding-left:20px;    background:linear-gradient(to right,transparent,grey 55%);}</code></pre><p>如图:</p><p><img src="/2019/03/01/2019/CSS省略号实现/CSS省略号实现3.png," alt="CSS省略号实现2.png" title="CSS省略号实现2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gulp增量编译优化</title>
      <link href="/2019/02/21/2019/Gulp%E5%A2%9E%E9%87%8F%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/"/>
      <url>/2019/02/21/2019/Gulp%E5%A2%9E%E9%87%8F%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>总结18年12月Gulp增量编译优化</p><p>实习时候，有一天，照常进行开发的时候，在等待项目运行gulp构建命令之后，等待着构建的完成…</p><p>这时候导师看了一眼，说：“是不是觉得很慢咧，能优化一下就好了”。</p><p>是呀，每次十几秒的等待，真的是很漫长的咧</p><a id="more"></a><p><img src="/2019/02/21/2019/Gulp增量编译优化/gulp增量编译3.png" alt="gulp增量编译3.png" title="gulp增量编译3.png"></p><p>也就是这样一句话，我想闲下来的时间可以试一试嘛，反正近期需求也不会太过忙碌，而且Gulp相关的命令也不算多，也就是如此，开始了Gulp的重新复习。</p><p><strong><font color="ff0000">开始啦~</font></strong></p><p>先分析了项目的gulpfile.js构建过程</p><p><img src="/2019/02/21/2019/Gulp增量编译优化/gulp增量编译1.png" alt="gulp增量编译1" title="gulp增量编译1"></p><p>可以看到项目原先进行了gulp.task的控制，并将依次进行arrTask中的任务</p><p>而在’clean_build’中，gulp将会清空build打包后的文件，这是不行的，因为我们建立起来的增量编译逻辑是：</p><pre><code>我们需要与未做改变的文件进行比较，然后判断我们是否修改了该文件，如果是，则将进行该文件的处理，如果不是，那我们就不需要处理该文件，这样便可以省去很多重复处理的时间</code></pre><p>接下来我们抽出一段公共代码分析与查看其构建原理</p><pre><code>gulp.task(&#39;css_comm&#39;, function() {  return gulp.src([&#39;1.css&#39;,&#39;2.min.css&#39;,&#39;3.css&#39;,&#39;4.css&#39;])        .pipe(concat(&#39;5.css&#39;)) // 合并common.css        .pipe(rev())    // 加MD5后缀        .pipe(cleanCss())   //压缩css        .pipe(gulp.dest(&#39;./build/css&#39;)) // 压缩完        .pipe(rev.manifest())        .pipe(gulp.dest(&#39;./rev/css&#39;));});</code></pre><p>看完代码，那时候就想嚯，要是我们初步在每一次合并，<font color="ff0000"><strong>未加MD戳</strong></font>之前，以及<font color="ff0000"><strong>未经压缩</strong></font>等操作前对上一次的构建文件进行比较，那么我们就可以抉择出是否继续对该文件进行构建，这样就可以达到我们自动识别构建的目的了。</p><p>因此新建了一个beforebuild文件夹作为中转文件夹用于压缩，加戳之前进行的比较作用</p><p><img src="/2019/02/21/2019/Gulp增量编译优化/gulp增量编译4.png" alt="gulp增量编译4" title="gulp增量编译4"></p><p><img src="/2019/02/21/2019/Gulp增量编译优化/gulp增量编译5.png" alt="gulp增量编译5" title="gulp增量编译5"></p><p>于是寻找相应是否有实现此比较功能的gulp包，在npm上找到一个<font color="ff0000"><strong>gulp-changed</strong></font><br>其用法如下：</p><pre><code>其中的hasChanged可以根据下列三项做比较changed.compareLastModifiedTimechanged.compareContentschanged.compareSha1Digest (Deprecated)可以对内容，最后修改时间等方式对文件作比较，从而判断是否修改过文件。</code></pre><font color="ff0000"><em>修改：</em></font><br><code>gulp.task(&#39;css_comm&#39;, function() {  return gulp.src([&#39;1.css&#39;,&#39;2.min.css&#39;,&#39;3.css&#39;,&#39;4.css&#39;])        .pipe(concat(&#39;5.css&#39;)) // 合并common.css        .pipe(changed(&#39;./beforebuild/6.css&#39;,{hasChanged: changed.compareLastModifiedTime})) //对比中转beforebuild中的6.css        .pipe(gulp.dest(&#39;./beforebuild/6.css&#39;)) // 先输出一遍        .pipe(rev())    // 加MD5后缀        .pipe(cleanCss())   //压缩css        .pipe(gulp.dest(&#39;./build/css&#39;)) // 压缩完        .pipe(rev.manifest())        .pipe(gulp.dest(&#39;./rev/css&#39;));});</code><br>关键之处在于添加了此两行对比代码：<br><code>.pipe(changed(&#39;./beforebuild/6.css&#39;,{hasChanged: changed.compareLastModifiedTime})) //对比中转beforebuild中的6.css.pipe(gulp.dest(&#39;./beforebuild/6.css&#39;)) // 先输出一遍</code><br><br>changed根据先前输出的文件的最终修改时间进行比较文件是否改变<br><br>而如果有改变，再输出覆盖beforebuild中的6.css，同时继续执行后续压缩，加戳等命令，从而输出到build文件中的6.css<br><br><br>最终将相关指令划分为default、dev，用于区分开发环境，生产环境中所用不同。因为生产环境中需要执行’clean_build’指令中的所有文件清除过程。<br><img src="/2019/02/21/2019/Gulp增量编译优化/gulp增量编译8.png" alt="gulp增量编译8" title="gulp增量编译8"><br><br>依次对项目gulp中的文件如此处理，最终将构建均速由<font><strong>15s</strong></font>降低至<font><strong>4s</strong></font>。<br><br><br><font color="ff0000"><strong>前后对比：</strong></font><p><img src="/2019/02/21/2019/Gulp增量编译优化/gulp增量编译3.png" alt="gulp增量编译3" title="gulp增量编译3"></p><p><img src="/2019/02/21/2019/Gulp增量编译优化/gulp增量编译6.png" alt="gulp增量编译6" title="gulp增量编译6"></p><p>至此，gulp的增量编译初步完成。<br>后续仍然有一些代码优化的空间在，所以并不认为这是最终的优化结果。</p><font><strong>加油!</strong></font><hr><p>附上在gulp中文网，查看到的gulp增量编译，官方使用watch与cache进行的增量处理。</p><p>Gulp增量编译: <a href="https://www.gulpjs.com.cn/docs/recipes/incremental-builds-with-concatenate/" target="_blank" rel="noopener">gulp增量编译</a></p><p><img src="/2019/02/21/2019/Gulp增量编译优化/gulp增量编译9.png" alt="gulp增量编译9" title="gulp增量编译9"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Gulp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript深浅拷贝</title>
      <link href="/2019/02/18/2019/JavaScript%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2019/02/18/2019/JavaScript%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<p>我们首先稍微复习一下有关JS中的数据类型及相关知识点</p><p>1-简单数据类型：Undefined，Null，Boolean，Symbol，Number，String</p><p>2-复杂数据类型：对象</p><p>简单数据类型保存在栈内存中</p><p>复杂数据类型即引用类型，保存于堆内存中；引用的类型值实际为指向对象的指针</p><p>这与我们今天所需要讲到的深浅拷贝有关😁</p><p><img src="/2019/02/18/2019/JavaScript深浅拷贝/深浅拷贝.jpg" alt="&quot;深浅拷贝.jpg&quot;" title="深浅拷贝.jpg"></p><a id="more"></a><p><strong><font color="ff0000">浅拷贝</font></strong></p><p>相当于我们复制了该对象或数组，然而该“指针”仍然指向原本内存空间</p><pre><code>var obj = {  name:&#39;wsscat&#39;,  age:0}var obj2 = obj;obj2[&#39;c&#39;] = 5;console.log(obj);//Object {name: &quot;wsscat&quot;, age: 0, c: 5}console.log(obj2);////Object {name: &quot;wsscat&quot;, age: 0, c: 5}</code></pre><p>我们可以看到，当我们改变obj2的[‘c’]时候，obj1会受到其影响</p><p><strong><font color="ff0000">深拷贝</font></strong></p><p><em>数组：</em></p><pre><code>1-slice()：var arr = [&#39;wsscat&#39;, &#39;autumns&#39;, &#39;winds&#39;];var arrCopy = arr.slice(0);arrCopy[0] = &#39;tacssw&#39;console.log(arr)//[&#39;wsscat&#39;, &#39;autumns&#39;, &#39;winds&#39;]console.log(arrCopy)//[&#39;tacssw&#39;, &#39;autumns&#39;, &#39;winds&#39;]2-concat():var arr = [&#39;wsscat&#39;, &#39;autumns&#39;, &#39;winds&#39;];var arrCopy = arr.concat();arrCopy[0] = &#39;tacssw&#39;console.log(arr)//[&#39;wsscat&#39;, &#39;autumns&#39;, &#39;winds&#39;]console.log(arrCopy)//[&#39;tacssw&#39;, &#39;autumns&#39;, &#39;winds&#39;]</code></pre><p><em>对象</em></p><pre><code>1-新建对象后遍历实现var obj = {      name:&#39;wsscat&#39;,      age:0}var obj2 = new Object();obj2.name = obj.name;obj2.age = obj.ageobj.name = &#39;autumns&#39;;console.log(obj);//Object {name: &quot;autumns&quot;, age: 0}console.log(obj2);//Object {name: &quot;wsscat&quot;, age: 0}2-封装好方法进行对象拷贝处理var obj = {  name: &#39;wsscat&#39;,  age: 0}var deepCopy = function(source) {var result = {};for(var key in source) {  if(typeof source[key] === &#39;object&#39;) {    result[key] = deepCopy(source[key])  } else {    result[key] = source[key]  }}return result;}var obj3 = deepCopy(obj)obj.name = &#39;autumns&#39;;console.log(obj);//Object {name: &quot;autumns&quot;, age: 0}console.log(obj3);//Object {name: &quot;wsscat&quot;, age: 0}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node+Express+Element实现文件上传下载</title>
      <link href="/2019/02/10/2019/Node-express%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
      <url>/2019/02/10/2019/Node-express%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>毕设的共享图书系统需要所运用到的，有关文件的上传、下载功能的实现，现在就总结一下记录在博客上：</p><p><strong>上传功能</strong></p><p><em>前端</em></p><p>上传所使用的element的upload组件<br><a id="more"></a></p><pre><code>&lt;el-upload class=&quot;upload-demo&quot; ref=&quot;upload&quot; action=&quot;&quot;    :with-credentials=&quot;true&quot;    :on-error=&quot;handleError&quot;    :limit=&quot;1&quot;    :before-upload=&quot;beforeAvatarUpload&quot;    :file-list=&quot;fileList&quot;    :http-request=&quot;commintEditor&quot;    :on-exceed=&quot;uploadExceed&quot;    :on-change=&quot;uploadChange&quot;    :on-remove=&quot;uploadRemove&quot;    :auto-upload=&quot;false&quot;&gt;    &lt;el-button slot=&quot;trigger&quot; size=&quot;small&quot; type=&quot;primary&quot;&gt;选取文件&lt;/el-button&gt;    &lt;!-- &lt;el-button style=&quot;margin-left: 10px;&quot; size=&quot;small&quot; type=&quot;success&quot; @click=&quot;submitUpload&quot;&gt;上传到服务器&lt;/el-button&gt; --&gt;    &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;只能上传jpg、pdf、doc文件，且不超过5MB&lt;/div&gt;&lt;/el-upload&gt;</code></pre><p>其中对一些钩子方法进行了定义，用于检验上传的设定大小，格式等…例如</p><pre><code>beforeAvatarUpload (file) {      var fileType = file.name.substring(file.name.lastIndexOf(&#39;.&#39;) + 1)      console.log(fileType)      const isJPG = fileType === &#39;jpg&#39;      const iswordx = fileType === &#39;docx&#39;      const isword = fileType === &#39;doc&#39;      const ispdf = fileType === &#39;pdf&#39;      const ispng = fileType === &#39;png&#39;      const isLt5M = file.size / 1024 / 1024 &lt; 5      if (!isJPG &amp;&amp; !isword &amp;&amp; !ispdf &amp;&amp; !iswordx &amp;&amp; !ispng) {        this.$message.error(&#39;上传只能是 jpg、png、doc、pdf 格式!&#39;)      }      if (!isLt5M) {        this.$message.error(&#39;上传图片大小不能超过 5MB!&#39;)      }      return (isJPG || isword || ispdf || iswordx || ispng) &amp;&amp; isLt5M    }    //  以上是对于文件格式，大小的检验</code></pre><p>在上传的函数中使用formdata的形式传输</p><pre><code>formData.append(&#39;file&#39;, _file)</code></pre><p>并且独立配置相应Axios的headers</p><pre><code>var config = {        headers: {          &#39;Content-Type&#39;: &#39;multipart/form-data&#39;        }      }</code></pre><p><em>后台</em></p><p>后台接收部分使用的是formidable模块，并为其设定服务器中的默认存储目录</p><pre><code>// 接收文件var formidable = require(&#39;formidable&#39;)var form = new formidable.IncomingForm()form.uploadDir = &#39;./uploadFile&#39;</code></pre><p>对文件的解析部分</p><pre><code>// 此模块解析请求信息，将json数据与文件数据分开为field、files两部分form.parse(req, function (err, field, files) {  // fields存放json数据，files存放的是文件信息  files.field = field  var $params = files.field  //  我们可以识别若files存在，则进行存储写入的操作再后续进行数据库记录操作  //  1  //  如果有文件的情况下  if (files.file) {    //  oldpath为解析请求中文件时存放的目录地址，我们目前需要将其重命名然后放入我们所需要的最终地址    let oldpath = path.join(files.file.path)    //  获取files相关属性    var JsonFile = files.file    var fileName = JsonFile.name    //  新的目录，为了防止同名，再加上随机数    var ranFileName = String(parseInt(Math.random() * 8999 + 10000)).concat(fileName)    //  新生成包含随机数的文件名与目录拼接的地址    newpath = path.join(&#39;./uploadFile&#39;, ranFileName)    //  利用fs模块进行文件重命名并且移动    fs.rename(oldpath, newpath, function (err) {      if (err) {        result = {          code: &#39;1&#39;,          data: {          },          msg: &#39;新文章上传错误&#39;        }        jsonWrite(res, result)        console.log(`上传文件重命名错误${err}`)      } else {        //  进行数据库记录，newpath为移动后的目录记录        commitToSql(req, res, $params, newpath)      }    })  }  //  无文件的情况下，进行数据库记录  else {    //  进行数据库记录，newpath为移动后的目录记录    commitToSql(req, res, $params, newpath)  }})</code></pre><p>于此，便完成了文件的上传记录（其余省略代码）</p><hr><p><strong>下载功能</strong></p><p><em>前端</em></p><pre><code>//  利用window.open打开一个新的页面，并且发送相应的请求连接与参数//  缺点：页面闪现lookArticle (index, row) {  var bookusername = row.username  var booktitle = row.title  window.open(`/lookArticle?bookusername=${bookusername}&amp;booktitle=${booktitle}`)},</code></pre><p><em>后台</em></p><pre><code>  //  分析相应文件名称  var fileName = $params.fileName  //  拼接后台服务器中文件的路径，以便使用  var currFile = path.join(__dirname, &#39;../uploadFile/&#39; + fileName)  //  使用fs.exists判断文件是否存在，目前已经不推荐使用fs.exists  fs.exists(currFile, function (exists) {    if (exists) {      console.log(&#39;文件存在&#39;)      res.download(currFile)    } else {      result = {        code: &#39;1&#39;,        data: {        },        msg: &#39;文件不存在&#39;      }      jsonWrite.jsonWrite(res, result)    }  })</code></pre><p>于此完成文件的下载功能<br>演示代码略为简单</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> Node </tag>
            
            <tag> Express </tag>
            
            <tag> Element </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新年快乐</title>
      <link href="/2019/02/08/2019/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/"/>
      <url>/2019/02/08/2019/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<p>今天是大年初四了，过去几天在热烈的气氛中，迎来了农历猪年，我也面临着大学四年的最后一个学期，珍惜!，希望新的一年的来临可以为自己带来不错的好运，在工作上顺利，自己一切的规划，也可以顺利的进行与实现。<strong>加油！</strong></p><p>也希望家人，朋友们，大家，新年快乐，心想事成，身体健康，万事如意。</p><p><img src="/2019/02/08/2019/新年快乐/timg.gif" alt="2019" title="2019"></p>]]></content>
      
      
      <categories>
          
          <category> 读书V生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常碎碎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node+MySQL释放数据库连接的Bug</title>
      <link href="/2019/02/02/2019/Node-MySQL%E9%87%8A%E6%94%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E7%9A%84Bug/"/>
      <url>/2019/02/02/2019/Node-MySQL%E9%87%8A%E6%94%BE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E7%9A%84Bug/</url>
      
        <content type="html"><![CDATA[<p>今天做毕业设计时，在前端业务中向后台请求用户数据时，每当请求次数超过五次，及以上时，总会卡死，于是，用简单的console判断代码停止位置，发现每次运行到pool.getConnection时第五次连接查询就会卡住，如图</p><p><img src="/2019/02/02/2019/Node-MySQL释放数据库连接的Bug/QQ截图20190202195830.png" alt="五次运行停1" title="五次运行停1"></p><p>图一</p><p><img src="/2019/02/02/2019/Node-MySQL释放数据库连接的Bug/QQ截图20190202195902.png" alt="五次运行停2" title="五次运行停2"></p><p>图二</p><p>于是乎就感觉是由于前次连接时的数据库连接没有释放的原因导致的，于是，在cmd中查看mysql的连接情况</p><pre><code>mysql &gt; mysqladmin -uroot -p processlist</code></pre><a id="more"></a><p>再实验前端的请求时，数据库的连接情况</p><p><font color="7f7f7f"><em>没有连接请求时</em></font><br><img src="/2019/02/02/2019/Node-MySQL释放数据库连接的Bug/QQ截图20190202200600.png" alt="没有连接请求" title="没有连接请求"></p><p><font color="7f7f7f"><em>第一次请求时</em></font><br><img src="/2019/02/02/2019/Node-MySQL释放数据库连接的Bug/QQ截图20190202200619.png" alt="第一次请求时" title="第一次请求时"></p><p><font color="7f7f7f"><em>第二次请求时</em></font><br><img src="/2019/02/02/2019/Node-MySQL释放数据库连接的Bug/QQ截图20190202200631.png" alt="第二次请求时" title="第二次请求时"></p><p><font color="7f7f7f"><em>第五次请求时</em></font><br><img src="/2019/02/02/2019/Node-MySQL释放数据库连接的Bug/QQ截图20190202200646.png" alt="第五次请求时" title="第五次请求时"></p><p>于是乎，得知了每一次请求时，后台的代码中总有两个数据库查询没有释放连接，从而导致，程序的中断</p><p>那接下来来检查一下代码：</p><p><font color="ff0000">简略的写，代码如下</font></p><pre><code>var getAlluserTotalPromise = function () {  var promise2 = new Promise(function (resolve, reject) {    pool.getConnection(function (err, connection) {      if (err) {        reject(result)      }      connection.query($sql.userCenter.getuserTotal, [], (err, result) =&gt; {        if (err) {          connection.release()          reject(result)        } else {          resolve(result)        }      })    })  })  return promise2}</code></pre><p>通过走查发现，我们在执行if-else逻辑时，对于else时的流程中忘记添加数据库释放了，以及后来采用了新的方式是否数据库连接</p><pre><code>pool.releaseConnection(connection)</code></pre><p>于是我们就将代码改为了</p><pre><code>var getAlluserTotalPromise = function () {  var promise2 = new Promise(function (resolve, reject) {    pool.getConnection(function (err, connection) {      if (err) {        reject(result)      }      connection.query($sql.userCenter.getuserTotal, [], (err, result) =&gt; {        if (err) {          // 修改位置          reject(result)          pool.releaseConnection(connection)        } else {          // 修改位置          resolve(result)          pool.releaseConnection(connection)        }      })    })  })  return promise2}</code></pre><p>之后我们再一遍遍发送请求，查看数据库的连接情况，发现这时候数据库的连接释放就正常了</p><p><font color="7f7f7f"><em>正常请求时</em></font><br><img src="/2019/02/02/2019/Node-MySQL释放数据库连接的Bug/QQ截图20190202201843.png" alt="正常请求时" title="正常请求时"></p><p>就把今天的Bug解决了，路漫漫，以后还会多着呢，也算是自己的粗心大意导致的，希望以后解决问题的能力更加厉害有所提升，节约时间</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> Express </tag>
            
            <tag> MySQL </tag>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>transform父元素对fixed子元素的影响</title>
      <link href="/2019/02/02/2019/transform%E5%AF%B9fixed/"/>
      <url>/2019/02/02/2019/transform%E5%AF%B9fixed/</url>
      
        <content type="html"><![CDATA[<p>在应用了属性transform的父元素上，若其拥有fixed属性的子元素，则该子元素的fixed属性讲失效，并将以其父元素为定位基准</p><p>详情请看例子：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;style&gt;    .outer {      overflow: hidden;      width: 300px;      height: 300px;      background: yellow;    }    .mid {      margin: 20px;      width: 200px;      height: 200px;      transform: translate(0, 0);      background: greenyellow;    }    .inner {      position: fixed;      top: 0;      left: 0;      width: 100px;      height: 100px;      background: pink;    }&lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;outer&quot;&gt;          &lt;div class=&quot;mid&quot;&gt;            &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;          &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>以上代码所呈现的布局样式：</p><p><img src="/2019/02/02/2019/transform对fixed/20181120224139596.png" alt="transform" title="transform"></p><a id="more"></a><p>若我们删除去父元素的transform属性：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;style&gt;    .outer {      overflow: hidden;      width: 300px;      height: 300px;      background: yellow;    }    .mid {      margin: 20px;      width: 200px;      height: 200px;      background: greenyellow;    }    .inner {      position: fixed;      top: 0;      left: 0;      width: 100px;      height: 100px;      background: pink;    }&lt;/style&gt;&lt;body&gt;    &lt;div class=&quot;outer&quot;&gt;          &lt;div class=&quot;mid&quot;&gt;            &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;          &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/2019/02/02/2019/transform对fixed/20181120224251281.png" alt="transform2" title="transform2"></p><p>由此可见，其父元素的transform对fixed子元素的影响；</p><p>注，此实例在chorme以及firefox下有效，IE环境等不受影响</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue父子组件间的通信</title>
      <link href="/2019/02/02/2019/Vue%E7%88%B6%E5%AD%90%E9%80%9A%E4%BF%A1/"/>
      <url>/2019/02/02/2019/Vue%E7%88%B6%E5%AD%90%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<font color="ff0000"><strong>父 –&gt; 子</strong></font><p>父组件向子组件传递，利用props属性<br><a id="more"></a></p><pre><code>父组件&lt;template&gt;  &lt;div&gt;    &lt;parent&gt;      &lt;!-- 通过为子组件绑定属性 --&gt;      &lt;child :parentToChild=&quot;value1&quot;&gt;&lt;/child&gt;                 &lt;/parent&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  data () {    return {      value1:&#39;父组件的值传给子组件&#39;    }  },  components: {},  mounted () {},  watch: {},  methods: {}}&lt;/script&gt;</code></pre><pre><code>子组件&lt;template&gt;  &lt;div&gt;    &lt;p&gt;这是子组件&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  data () {    return {      valueFromParent:&#39;&#39;,    }  },  components: {},  // 子组件通过props可以拿到父组件传递的值  props: [&#39;parentToChild&#39;],  mounted () {},  // 倘若需要与data中绑定的数据项应，则在watch中做监视  watch: {    &#39;parentToChild&#39;: function () {      this.valueFromParent = this.parentToChild    }  },  methods: {}}&lt;/script&gt;</code></pre><hr><font color="ff0000"><strong>子 –&gt; 父</strong></font><p>利用emit方法，绑定触发事件</p><pre><code>子组件&lt;template&gt;  &lt;div&gt;    &lt;p&gt;这是子组件&lt;/p&gt;    &lt;button @click=&quot;clickEvent&quot;&gt;点击按钮&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  data () {    return {      value1:&#39;这是要传给父组件的值&#39;,      value2:&#39;可以传多个值&#39;,      value3:false,    }  },  components: {},  props: [],  mounted () {},  watch: {},  methods: {    clickEvent(){      // 通过绑定事件，触发emit      this.$emit(&#39;sendValueToParent&#39;,this.value1,this.value2,this.value3,true);        }  },  created(){}}&lt;/script&gt;</code></pre><pre><code>父组件&lt;template&gt;  &lt;div&gt;    &lt;p&gt;这是父组件&lt;/p&gt;    &lt;parent&gt;      &lt;!-- 绑定事件触发getValueFromChild  --&gt;      &lt;child @sendValueToParent = &quot;getValueFromChild&quot;&gt;&lt;/child&gt;    &lt;/parent&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  data () {    return {}  },  components: {},  mounted () {},  watch: {},  methods: {    // 触发的事件    getValueFromChild(value1,value2,value3,value4){                             &lt;-----关键      //打印值分别是      //value1: 这是要传给父组件的值      //value2: 可以传多个值      //value3: false      //value4: true    }  },  created(){}}&lt;/script&gt;</code></pre><p>以上就是父子组件相互传递值得大致行为</p><p>大致可以用于：例<br>分页器组件与父组件的关系</p><p><img src="/2019/02/02/2019/Vue父子通信/vue.jpg" alt="vue父子组件" title="vue父子组件"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Axios使用</title>
      <link href="/2019/01/31/2019/Axios%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/01/31/2019/Axios%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>这几天临近过年，实习的公司也从25号开始放假了，好好休整了几天，摸鱼做做毕业设计，也还有几天就要过年了，但时间紧迫，毕业，工作的各种事情也都将棘手起来，所以还是不能闲太久呢，要有所紧迫感…</p><p>今天零星总结一下之前笔记中的Axios的使用方法:<br><a id="more"></a></p><hr><font color="ff0000"><em>get</em></font><pre><code>axios.get(&#39;/user?ID=12345&#39;)  .then(function (response) {    console.log(response);  })  .catch(function (error) {    console.log(error);  });// 可选地，上面的请求可以这样做axios.get(&#39;/user&#39;, {  params: {  ID: 12345}}).then(function (response) {  console.log(response);}).catch(function (error) {  console.log(error);});</code></pre><font color="ff0000"><em>post</em></font><pre><code>axios.post(&#39;/user&#39;, {  firstName: &#39;Fred&#39;,  lastName: &#39;Flintstone&#39;}).then(function (response) {  console.log(response);}).catch(function (error) {  console.log(error);});</code></pre><font color="ff0000"><em>Axios API</em></font><pre><code>//可使用下列配置方法请求axios(config)axios({method: &#39;post&#39;,url: &#39;/user/12345&#39;,data: {    firstName: &#39;Fred&#39;,    lastName: &#39;Flintstone&#39;}});axios(url[, config])axios(&#39;/user/12345&#39;);以及几种其他的请求别名: axios.request(config)    axios.get(url[, config])    axios.delete(url[, config])    axios.head(url[, config])    axios.post(url[, data[, config]])axios.put(url[, data[, config]])  axios.patch(url[, data[, config]])</code></pre><font color="ff0000"><em>多个Axios的执行</em></font><pre><code>axios.all(iterable)axios.spread(callback)function getUserAccount() {return axios.get(&#39;/user/12345&#39;);}function getUserPermissions() {return axios.get(&#39;/user/12345/permissions&#39;);}axios.all([getUserAccount(), getUserPermissions()])  .then(axios.spread(function (acct, perms) {  // 两个请求现在都执行完成  }));</code></pre><font color="ff0000"><em>Axios请求的配置项</em></font><pre><code>{    url: &#39;url&#39;  // 请求的url    method: &#39;get&#39;  //  请求的方法    baseURL: &#39;url&#39;  //  将baserURL加在url前边，便于axios传递为相对URL     transformRequest: [function (data) {        return data    }] //允许向服务器发送数据前，修改请求的数据，只限于 &#39;PUT&#39;,&#39;POST&#39;,&#39;PATCH&#39;请求方法    transformRequest: [function (data) {        return data    }] //允许向服务器响应数据后，数据传递给then/catch前，修改响应数据    headers: {&#39;&#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;&#39;}  //自定义请求头    params: {        ID: 12345    }  // 将发送的URL参数    paramsSerializer: function (params) {        return Qs.stringify(params, {arrayFormat: &#39;brackets&#39;})    }   // 负责序列化 params，为什么？-&gt;看解决问题1、，所以需要序列化    data: {        firstName: &#39;Fred&#39;   // 作为请求主体发送的数据    }    timeout: 1000   // 指定请求超时的时间数，超时将中断    withCredentials: false  //跨域时是否需要凭证    以及其余众多方法...}</code></pre><font color="ff0000"><em>params与data</em></font><pre><code>params与data的区别？：params是添加到url的请求字符串的，用于get请求data是添加到body中的，用于post请求</code></pre><font color="ff0000"><em>Axios请求的结构</em></font><pre><code>response-&gt;:响应结构{  // `data` 由服务器提供的响应  data: {},  // `status` 来自服务器响应的 HTTP 状态码  status: 200,  // `statusText` 来自服务器响应的 HTTP 状态信息  statusText: &#39;OK&#39;,  // `headers` 服务器响应的头  headers: {},  // `config` 是为请求提供的配置信息  config: {}}</code></pre><font color="ff0000"><em>axios.create创建实例</em></font><pre><code>// 自定义创造一个axios的实例，这样亦可以与默认的axios区分开来var instance = axios.create({  baseURL: &#39;https://api.example.com&#39;});</code></pre><font color="ff0000"><em>axios拦截器</em></font><p>可统一在请求发送时或者接收时做网络的统一处理，例如响应的404等错误处理，而不用交由每一个请求响应来做</p><pre><code>// 添加请求拦截器axios.interceptors.request.use(function (config) {  // 在发送请求之前做些什么  return config;  }, function (error) {  // 对请求错误做些什么  return Promise.reject(error);});// 添加响应拦截器axios.interceptors.response.use(function (response) {  // 对响应数据做点什么  return response;  }, function (error) {  // 对响应错误做点什么  return Promise.reject(error);});</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Axios </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写new、call、apply、bind</title>
      <link href="/2019/01/24/2019/%E6%89%8B%E5%86%99new-call-apply-bind/"/>
      <url>/2019/01/24/2019/%E6%89%8B%E5%86%99new-call-apply-bind/</url>
      
        <content type="html"><![CDATA[<h3 id="手写new"><a href="#手写new" class="headerlink" title="手写new"></a>手写new</h3><a id="more"></a><ol><li>新建一个对象</li><li>对象可以访问构造函数原型链上的属性</li><li>根据构造函数执行结果返回实例<ul><li>引用对象返回该对象</li><li>简单对象返回新建对象</li></ul></li></ol><pre><code>function myNew(fn, ...args) {    const obj = {};    obj.__proto__ = fn.prototype;    let res = fn.apply(obj, args);    return ret instanceof Object ? res : obj;}</code></pre><p><em>other</em></p><pre><code>function myNew(fn, ...args) {    // 1.创建一个空对象obj    let obj = {};    // 2.配置原型链：使用setPrototypeOf更改新建对象obj的原型对象，将其指向fn的原型对象    // 这样obj就能访问构造函数原型所在原型链上的属性了    Object.setPrototypeOf(obj, fn.prototype);    // 3.通过apply使this指向obj，执行函数fn并且获取执行后的结果    let result = fn.apply(obj, args);    // 4.判断result是否为对象，是则返回result，否则返回新创建obj    return result instanceof Object ? result : obj;}</code></pre><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><!--more--><hr><font color="ff0000"><strong>call的使用</strong></font><br><code>var foo = {  value: 1}function bar(name, age) {  console.log(name) // Jayant  console.log(age)  // 23  console.log(this.value) // 1}bar.call(foo,&#39;Jayant&#39;,23)</code><br><br><font color="7f7f7f"><em>如果将bar()作为foo的属性：</em></font><p>那么我们也可以完成其this的改变</p><pre><code>var foo = {    value: 1,    bar: function(){        console.log(this.value)    }}// 将bar作为属性放在foo上foo.bar(); </code></pre><p>那么按照此思路，我们是不是也可以将大致的行为抽象称为</p><pre><code>// 赋给属性--执行它--删除它foo.fn = bar()foo.fn()delete foo.fn</code></pre><font color="7f7f7f"><em>于是我们根据我们的思路，实现第一版绑定实现：</em></font><hr><font color="ff0000"><strong>第一版:</strong></font><p>我们选择将该函数定义在Function原型上</p><pre><code>Function.prototype.call2 = function(context) {    context.fn = this;    context.fn();    delete context.fn;}var foo = {    value: 1}function bar() {    console.log(this.value)}bar.call2(foo)  // 1</code></pre><font color="7f7f7f"><em>我们在call2函数上将this赋予了context的fn属性，并且在执行之后删除它</em></font><hr><font color="7f7f7f"><em>其次call中还有参数的问题，按照我们的第一版实现，我们并不能传入参数</em></font><font color="7f7f7f"><em>于是我们进一步进行参数的处理</em></font><font color="ff0000"><strong>第二版</strong></font><pre><code>Function.prototype.call3 = function(context) {    context.fn = this;    var args = [];    // 因为此处的arguments里边有参数,剥夺第一个的context方法,其余就是参数    for(var i =1,len=arguments.length;i&lt;len;i++){        args.push(arguments[i])    }    &lt;!--关键在于上边对于arguments参数的提取--&gt;    context.fn(...args);    delete context.fn;}var foo = {    value: 1}function bar(name,age) {    console.log(name)   //  jayant2    console.log(age)    // 23    console.log(this.value) //  1}bar.call3(foo,&#39;jayant2&#39;,23)</code></pre><font color="7f7f7f"><em>于是我们完成了call3函数内的参数定义，传递问题</em></font><hr><font color="ff0000"><strong>第三版</strong></font><font color="7f7f7f"><em>第三版，进行了函数的具体完善，this为空的情况，指向null，将值返回的情况</em></font><pre><code>Function.prototype.call4 = function(context) {    &lt;!--此处进行了传入this是否为空的情况--&gt;    var context = context || window    context.fn = this;    var args = [];    // 因为此处的arguments里边有参数,剥夺第一个的context方法,其余就是参数    for(var i =1,len=arguments.length;i&lt;len;i++){        args.push(arguments[i])    }    var result = context.fn(...args);    delete context.fn;    &lt;!--进行了返回值处理--&gt;    return result}var foo = {    value: 1}function bar(name,age) {    console.log(name)   //  jayant2    console.log(age)    // 23    console.log(this.value) //  1}bar.call4(foo,&#39;jayant4&#39;,23)</code></pre><font color="7f7f7f"><em>至此，以上就是进行call模拟的大致过程</em></font><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><pre><code>// apply模拟Function.prototype.apply_ = function (obj, arr) {    obj = obj ? Object(obj) : window;    obj.fn = this;    var result;    if (!arr) {        result = obj.fn();    } else {        var args = [];        // 注意这里的i从0开始        for (var i = 0, len = arr.length; i &lt; len; i++) {            args.push(&quot;arr[&quot; + i + &quot;]&quot;);        };        result = eval(&quot;obj.fn(&quot; + args + &quot;)&quot;); // 执行fn    };    delete obj.fn; //删除fn    return result;};</code></pre><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><hr><font color="ff0000"><strong>bind函数</strong></font><br><code>var foo ={    value: 1}function bar() {    console.log(this.value)}var bindFoo = bar.bind(foo)// bind不会立即执行bindFoo(); //1</code><br><br>我们可以总结得到，bind函数不同于call、apply，它会返回一个未执行的函数，并且等待你的执行<br><br>于是我们根据此做出第一版模拟<br><br>—<br><br><font color="ff0000"><strong>第一版</strong></font><pre><code>var foo ={    value: 1}function bar() {    console.log(this.value)}Function.prototype.bind2 = function(context) {    var self = this;    return function() {        self.apply(context)    }}var result = bar.bind2(foo)result(); // 1</code></pre><font color="7f7f7f"><em>上面我们模拟出来对于this的指向问题，接下来，我们继续对它的传递参数进行处理</em></font><font color="7f7f7f"><em>我们先来看一下原生bind的处理与效果</em></font><pre><code>var foo ={    value: 1}function bar(name, age) {    console.log(name)   //  Jayant    console.log(age)    // 23    console.log(this.value) //1}// 此处传了部分参数var bindFoo = bar.bind(foo, &#39;Jayant&#39;)// 再传部分参数bindFoo(23)</code></pre><hr><font color="ff0000"><strong>第二版</strong></font><pre><code>Function.prototype.bind3 = function (context) {    var self = this;    // 先接受一遍第一次的参数，    // 第二次调用时传递的在return的function中处理    var args = Array.prototype.slice.call(arguments, 1)    return function() {        var bindArr = Array.prototype.slice.call(arguments)        // 处理传入的参数;        return self.apply(context, args.concat(bindArr));    }}</code></pre><font color="7f7f7f"><em>我们选择将参数在其中划分出来，二步处理，完成了bind参数问题</em></font><hr><p><font color="ff0000"><strong>最终版</strong></font></p><p><font color="7f7f7f"><em>处理有关bind函数的new问题</em></font></p><pre><code>Function.prototype.bind4 = function(context) {    if(typeof this !== &#39;function&#39;) {        throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);    }    var self = this;    var args = Array.prototype.slice.call(arguments, 1);    var fNOP = function () {};    var fBound = function () {        var bindArgs = Array.prototype.slice.call(arguments);        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));    }    fNOP.prototype = this.prototype;    fBound.prototype = new fNOP();    return fBound;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript继承</title>
      <link href="/2019/01/23/2019/JavaScript%E7%BB%A7%E6%89%BF/"/>
      <url>/2019/01/23/2019/JavaScript%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>前几天整理了有关<strong>JavaScript继承</strong>的几种方式，今天就一并的从印象笔记中整理上来。</p><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><a id="more"></a><pre><code>function SuperType () {    this.property = true}SuperType.prototype.getSuperValue = function() {    return this.property}function SubType() {    this.subproperty = false}// 此处继承SubType.prototype = new SuperType()                // 此处也在原型中写了自己的getSubValue方法SubType.prototype.getSubValue = function() {            return this.subproperty}var instance = new SubType()alert(instance.getSuperValue)        //true// 此处重新定义了超类型中的该方法SubType.prototype.getSuperValue = function () {        return false}alert(instance.getSuperValue())    //false</code></pre><p>缺陷：</p><ol><li>多个实例对引用类型的操作会被篡改。</li></ol><h4 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h4><pre><code>function SuperType () {    this.colors = [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]}function SubType() {    //继承SuperType，此处继承/借助构造函数    SuperType.call(this)}var instance1 = new SubType()instance1.colors.push(&#39;black&#39;)alert(instance.colors)    //&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;,&#39;black&#39;var instance2 = new SubType()alert(instance2.colors)    //&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;</code></pre><p><em>如何传递参数？</em></p><pre><code>function SuperType(name) {    this.name = name}function SubType() {    // 此处继承，并传递具体name值    SuperType.call(this, &#39;Jayant&#39;)        this.age = 29}var instance = new SubType()alert(instance.name)    // Jayantalert(instance.age)    //29</code></pre><p>缺陷：</p><ol><li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li><li>无法实现复用，每个子类都有父类实例函数的副本，影响性能</li></ol><h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>结合原型链与构造函数，思路为：使用原型链实现对原型属性和方法的继承，又实用构造函数实现对实例属性的继承</p><pre><code>function SuperType(name) {    this.name = name    this.colors = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]}SuperType.prototype.sayName = function() {    alert(this.name)}function SubType(name, age) {    // 构造继承属性   第一次调用SuperType    SuperType.call(this,name)    this.age = age}// 原型链继承  第二次调用SuperTypeSubType.prototype = new SuperType()    SubType.prototype.constructor = SubTypeSubType.prototypr.sayAge = function() {    alert(this.age)}var instance1 = new SubType(&#39;Jayant&#39;, 23)instance1.colors.push(&#39;black&#39;)alert(instance1.colors)    //&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;,black&#39;instance1.sayName()        //Jayantinstance1.sayAge()        // 23vat instance2 = new SubType(&#39;Grey&#39;, 27)alert(instance2.colors)    //&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;instance2.sayName()       // &#39;Grey&#39;instance2.sayAge()        //27</code></pre><p>组合上述两种方法就是组合继承。用原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承<br>缺点：</p><ol><li>第一次调用SuperType()，给SubType.prototype写入两个属性name，color；</li><li>第二次调用SuperType()，给instance写入两个name，color</li></ol><h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><pre><code>function object(obj) {    function F(){};    F.prototype = obj;    return new F();}var person = {    name: &#39;1&#39;,    friends: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]}var anotherPerson = object(person);anotherPerson.name = &#39;Greg&#39;;anotherPerson.friends.push(&#39;rob&#39;);var secondPerson = object(person);secondPerson.name = &#39;Sreg&#39;;secondPerson.friends.push(&#39;Sob&#39;);console.log(anotherPerson.friends); //  &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;rob&#39;, &#39;Sob&#39;</code></pre><p>缺陷：</p><ol><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数</li></ol><h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><pre><code>function createAnthor(original) {    var clone = object(original)    // 添加新方法    clone.sayHi = function() {         alert(&#39;Hi&#39;)    }    return clone}</code></pre><p>在上边例子中，createAnther()函数接收一个参数，将要作为新对象基础的对象，然后将对象(original)传递给object()函数，将返回的结果赋值给Clone<br>再为clone对象添加一个新方法sayHi()，最后返回给clone对象。</p><pre><code>var person = {    name: &#39;Nicholas&#39;,    friends: [&#39;shelby&#39;, &#39;court&#39;, &#39;van&#39;]}var anthorPerson = createAnther(person)antherPerson.sayHi()        //Hi</code></pre><p>在原型式继承的基础上，增强对象，返回构造函数。</p><h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><p>为避免如同组合继承的方式，会调用两次超类型构造函数，衍生出了寄生组合继承方式</p><pre><code>function inheritPrototype(subType, superType) {    //创建对象    var prototype = object(superType.prototype)    //增强对象    prototype.constructor = subType                     //指定对象    subType.prototype = prototype   }</code></pre><p>实例</p><pre><code>function SuperType(name) {    this.name = name    this.colors = [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]}SuperType.prototype.sayName = function(){    alert(this.name)}function SubType(name, age) {    SuperType.call(this, name)    this.age = age}inheritPrototype(SubType, SuperType)SubType.prototype.sayAge = function () {    alert(this.age)}</code></pre><font color="7f7f7f"><em><br>优势在于只调用一次父类构造函数，并且将子构造函数，父构造函数传入方法中，复制一遍父类型的原型，并为其添加constructor属性</em></font><h4 id="ES6-Extends"><a href="#ES6-Extends" class="headerlink" title="ES6 Extends"></a>ES6 Extends</h4>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript创建对象</title>
      <link href="/2019/01/23/2019/JavaScript%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/01/23/2019/JavaScript%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>前几天整理了有关<strong>JavaScript创建对象</strong>的几种方式，今天就一并的从印象笔记中整理上来。</p><hr><p><font color="ff0000"><strong>工厂模式</strong></font></p><pre><code>function createPerson(name, age, job) {    var o = new Object()    o.name = name    o.age = age    o.job = job    o.sayName = function () {        alert(this.name)    }    return o}var person1= createPerson(&#39;jayant&#39;, 23, &#39;web&#39;)var person2 = createPerson(&#39;esss&#39;, 22, &#39;**&#39;)// 因为方法中已经new了一个object了，所以我们不需要new它</code></pre><a id="more"></a><p><font color="ff0000"><strong>构造函数模式</strong></font></p><pre><code>function Person(name, age, job) {    this.name = name    this.age = age    this.job = job    this.sayName = function () {        alert (this.name)    }}var person1 = new Person(&#39;jayant&#39;, 23, &#39;web&#39;)var person2 = new Person(&#39;esss&#39;, 22, &#39;no&#39;)</code></pre><p><em>构造函数Person与工厂模式createPerson的区别：</em></p><ul><li>没有显式创建对象，内部new Object</li><li>直接将属性赋予this对象</li><li>没有return 语句</li></ul><p><em>如果需要使用构造函数生成一个Person实例，则我们需要new一下，new一个对象会经历以下过程：</em></p><ul><li>创建一个新对象</li><li>将构造函数作用域赋予新对象，也就是this</li><li>执行构造函数中的代码</li><li>返回新对象</li></ul><p><em>构造函数的<font color="7f7f7f">不足之处</font>：</em></p><p>person1与person2中每个实例都有一个这个方法，都需要创建一遍，<font color="7f7f7f">造成内存上的浪费</font></p><pre><code>this.sayName = function () {    alert(this.name)}alert(person1.sayName == person2.sayName)　　//false</code></pre><p>于是又根据此不足之处衍生出以下方法：</p><p><font color="7f7f7f"><em>构造函数的优化：</em></font></p><pre><code>function Person (name, age, job) {    this.name = name    this.age = age    this.job = job    this.sayName = sayName}// 1、将共有方法定义在全局上，2、函数多的话，要定义多function sayName() {       alert(this.name)}</code></pre><p>但是这个操作又会造成如果函数很多，需要定义很多方法；并且是定义成为了全局函数，这完全不需要</p><hr><p><font color="ff0000"><strong>原型模式</strong></font></p><p><font color="7f7f7f"><em>每个函数都有一个prototype属性，是一个指针，为了使所有实例可以共享到属性和方法，从而不必在构造函数中定义</em></font></p><pre><code>function Person() {}// 定义在原型上Person.prototype.name = &#39;Jayant&#39;Person.prototype.age = 23Person.prototype.job = &#39;web&#39;Person.prototype.sayName = function() {    alert(this.name)}var person1 = new Person()person1.sayName()    //Jayantvar person2 = new Person()person2.sayName()    //Jayant</code></pre><p><em><font color="7f7f7f">好处：</font></em> 公共方法，属性可以共用，同时是定义在其构造函数原型上的</p><p><em><font color="7f7f7f">不足：</font></em> 是过于共享，以至于所有的实例都拥有相同的方法，实例了</p><p><font color="7f7f7f">例如：</font></p><pre><code>person1.age = 100person2.age // 100</code></pre><hr><p><font color="ff0000"><strong>组合使用构造函数模式与原型模式</strong></font></p><pre><code>function Person(name, age) {    this.name = name    this.age = age    this.friends = [&#39;乾隆&#39;, &#39;康熙&#39;]}Person.prototype = {    constructor: Person    sayName: function () {        alert(this.name)    }}var person1 = new Person()var person2 = new Person()person1.friends.push(&#39;嬴政&#39;)person1.friends    //乾隆，康熙，嬴政person2.friends    //乾隆，康熙//认可度，使用最广泛的一种创建对象方式</code></pre><hr><p><font color="ff0000"><strong>寄生构造函数模式</strong></font></p><pre><code>function Person(name, age, job) {    var o = new Object()    o.name = name    o.age = age    o.job = job    o.sayName = function () {        alert(this.name)    }    return o}var friend = new Person(&#39;Jayant&#39;, 23, &#39;web&#39;)</code></pre><p><font color="7f7f7f"><em>工厂模式</em></font></p><pre><code>function Person(name, age, job) {    var o = new Object()    o.name = name    o.age = age    o.job = job    o.sayName = function () {        alert(this.name)    }    return o}var friend = Person(&#39;Jayant&#39;, 23, &#39;web&#39;) </code></pre><p><em>寄生构造函数与工厂模式的区别</em></p><pre><code>// 寄生构造函数var friend = new Person(&#39;Jayant&#39;, 23, &#39;web&#39;)  // 工厂模式 var friend = Person(&#39;Jayant&#39;, 23, &#39;web&#39;) </code></pre><hr><p><font color="ff0000"><strong>稳妥构造函数模式</strong></font></p><pre><code>function Person (name, age) {    var o = new Object()    o.sayName = function () {        alert(name)    }    return name}var person = Person(&#39;jayant&#39;, 23)person.sayName()    //jayant// 除了调用sayName方法，没办法获取其数据成员，某种情况下安全性 up up</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git相关命令</title>
      <link href="/2019/01/23/2019/Git%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/01/23/2019/Git%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>将自己工作中所整理出来的常用Git命令于此总结一下</p><a id="more"></a><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><pre><code class="base">// 添加文件至区域git add . // 提交文件至本地仓库git commit -m &quot;xxx&quot;// 查看目前工作状态git status// 在添加之前可以查看修改的记录git diff // 查看提交的loggit log// 查看精简的提交loggit log --pretty=oneline   // 恢复本地分支至HEAD^git reset --hard HEAD^   // 重置本地分支至某分支git reset --hard 956d...   // 切换到xx分支git checkout branch   // 本地创建xx分支git checkout -b branch   // 查看当前远程库git remote -v   // 查看所有分支git remote -a// 将目前origin连接为xxx的远程git remote add origin https://xxx   // 克隆某仓库至本地git clone http: //xxx    // 删除本地某分支git branch -d branch   // 删除远程某分支git push origin --delete branch   // 查看本地有的分支git branch   // 查看远程有的分支git branch -r   // 查看log的流程分支图git log --graph   // 拉取本地没有的远程某分支git checkout -b 本地分支名 origin/远程分支名   // 切换与拉取最新分支git checkout maste  git pull --rebas git checkout branchxxx // 提交作为一次记录，MERGE修改完成后：git add .   git commit  // REBASE修改完成后，提交继续：git add &lt;filename&gt; git rebase --continue// 储藏工作现场git stash// 查看储藏的工作现场git stash list// 恢复应用工作现场git stash apply xxx// 删除第一个工作现场git stash drop</code></pre><h5 id="流程式操作"><a href="#流程式操作" class="headerlink" title="流程式操作"></a>流程式操作</h5><pre><code class="base">- 创建feature分支：git checkout master git ckeckout -b feature-s16 git push  //再根据base提示信息，将本地分支连接上origin上该分支- 在feature上进行开发：git add xxxgit commit -m &quot;xxx&quot;- 若为多人协同开发更新分支，有rebase冲突：// 拉取并合并远程该分支git pull --rebase  // 此两个命令为合并有冲突时，解决冲突后的继续合并命令git add .  git rebase --continue    - 完成feature开发：git checkout dev// 本地切换至dev分支后，拉取远端最新的dev分支代码git pull --rebase  - 再将feature分支合并到dev分支上：git merge --no-ff feature-s16 // 将合并后的dev分支推上远端git push origin dev  - 再将fev分支合并至master分支上：git merge --no-ff dev // 将合并后的master分支推上远端git push origin master  - 一段时间后删除feature分支：git branch -d feature-s16// 删除远端该分支git push origin --delete feature-s16  - 若merge --no-ff合并有冲突：// 将自动提交一个合并记录git add .  git commit  </code></pre><p><img src="/2019/01/23/2019/Git相关命令/Git.jpg" alt="竹林小道" title="竹林小道"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅读摘录</title>
      <link href="/2019/01/23/2019/%E9%98%85%E8%AF%BB%E6%91%98%E5%BD%95/"/>
      <url>/2019/01/23/2019/%E9%98%85%E8%AF%BB%E6%91%98%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>大部分都是从印象笔记中搬运过来的，想着也是记录在这边比较的方便…</p><h2 id="《罗生门》"><a href="#《罗生门》" class="headerlink" title="《罗生门》"></a>《罗生门》</h2><ul><li>【罗生门】<br>我们为人起初的恶意是会因为社会的理论…善恶一念之间…</li><li>【竹林中】<br>真相并不可得呀，每个人都为着自己的供词或多或少的撒着慌，真理，事实的真相又要从哪儿考据呢？</li><li>【地狱变】<br>大公，人人称颂的角色，正面光鲜，可却会做下卑劣的事，其心内核，也是肮脏的灵魂。<br>灵秀，猴子，温情，女儿成了他恋世的惟一，人人不喜欢灵秀，可也唯独对女儿百般疼爱，最终，完成了自己的作品，也无再牵挂。</li><li>【鼻子】<br>内心嫌弃自己的缺陷，因为它与众不同<br>有时候改变了它，它也改变了你，内心越来越暴躁与焦虑<br>我们要克服自身的缺陷，更重要的是心里这一关。</li><li>【山药粥】<br>幻想与希望中的东西，是最得我们意的吧？<br>最终接受着的那一刻，就已经不在那么如蜃楼那么般开心吧。</li><li>【河童】<br>很讽刺着现实社会，以及人类生活…思想上…生活习惯上…种种…</li></ul><h2 id="《挪威的森林》"><a href="#《挪威的森林》" class="headerlink" title="《挪威的森林》"></a>《挪威的森林》</h2><ol><li>尽管如此，记忆到底还是一步步远离开去了，我忘却的东西实在太多了。</li><li>我不禁再次感到敬佩：世上果然有多种多样的希望，人生的目的也各所不同。</li><li>既然话已出口，就该说清楚才是。</li><li>死并非生的对立面，而作为生的一部分永存。</li><li>或许我的心包有一层硬壳，能破壳而入的东西是极其有限的，所以我才不能对人一往情深。</li><li>我几次朝夜幕伸出手去。指尖毫无所触，那小小的光电总是同指尖保持着一点不可触及的距离。</li><li>一个扛着睡袋，满腮胡子，疲于奔命的人哪里找什么浪漫情调呢？</li><li>哪里有人喜欢孤独，不过是不乱交朋友罢了，那样只能落的失望。</li><li>也许等过久了，我追求的是十二分完美无缺的东西，所以才这么难。</li><li>我是个比你想的要不健全的人。</li><li>那不是努力，是劳动。</li><li>不要同情自己，同情自己是卑劣懦夫干的勾当。</li><li>春天里的熊；整个世界的森林的树都为之倾倒；整个世界森林里的老虎全都融化成黄油。</li><li>我们是生息在不健全世界上不健全的人。</li><li>我们唯一能做的，就是从这片悲哀中挣脱出来，并从中领悟某种哲理。</li><li>我已成为过去的人，你眼前存在的不过是我往日的记忆残片，我心目中最宝贵的东西在很久以前就已寿终正寝。</li></ol><h2 id="《瓦尔登湖》"><a href="#《瓦尔登湖》" class="headerlink" title="《瓦尔登湖》"></a>《瓦尔登湖》</h2><ul><li>【生计】<ol><li>人只有在举目无亲的远方才能够真诚的活着。</li><li>人对自己的看法，决定或者影响着他的命运。</li><li>所谓的委曲求全其实是积重难返的绝望。</li><li>因为岁月让他得不偿失。</li><li>有许多遥远而不同的生灵正在同时凝望着同一颗星星呢！</li><li>痛苦本身就是一种回报。（在哪里我好像也看过相同的一种说法…在哪本书里来着…）</li><li>我们总是想要学会如何得到更多的东西，但有时候应该学学如何满足于更少的东西。</li><li>房屋有如贝壳，让他们变得秀丽的，是寄居在内者的生活。（斯是陋室，唯吾德馨，的意思吧，哈哈哈哈哈中文博大精深！）</li><li>人世间本没有两全其美的事物。</li><li>民族想要千古流芳，靠的应该不是建筑，而是强大的抽象思想。</li><li>但我盼望每个人都能非常清醒地去发现和追求他自己的生活方式，而不是模仿他的父亲，母亲活着邻居。</li><li>我们也许没法依照预定的日子如期抵达我们的港口，但终归航行在正确的线路上。（终归在正确的道路上…）</li><li>独行的人今天就可以上路！</li><li>你现在是什么人，就做什么人，别想着要让自己变的更有价值，而是要怀着善意努力去做好事。</li><li>安抚人们的恐惧，而不是肯定人们的希望。</li><li>如果你手上很宽裕，想枣树那样慷慨大方吧；如果你没有可以送出去的余财，那么就像效访柏树，当一个自由的人吧！（穷则独善其身 达则兼济天下。）</li></ol></li></ul><ul><li><p>【居所和生活的目标】</p><ol><li>早晨让人回到英雄时代。</li><li>因为星期天很适合对虚度的一周进行总结，而不是让人精神抖擞地去迎接新的一周的日子。</li><li>儿童把生活当作游戏，反而能更清楚地认识生活的真实规则和各种关系。（just play！）</li></ol></li><li><p>【阅读】</p><ol><li>我们花了许多钱来治疗身体的病疼，对精神的疾患却不管不顾。</li></ol></li><li><p>【声音】</p><ol><li>人的路，要亲自去走，这是千真万确的。</li></ol></li><li><p>【孤寂】</p><ol><li>每个毛孔都洋溢着快乐。</li><li>人们在世间的日子真的很短促。</li><li>我已经发想，两个人的腿再怎么走，也无法让两颗心靠得更近。</li><li>衡量孤寂的标准，并不是一个人和其他同类之间隔了多少英里。</li></ol></li><li><p>【镇区】</p><ol><li>只有到了失去这个世界之后，我们才能找到我们自己。</li></ol></li><li><p>【湖泊】</p><ol><li>别再向往天堂，那是对大地的侮辱。</li></ol></li><li><p>【贝克尔农场】</p><ol><li>尽管去更远的地方，尽管在许多溪流和炉膛旁边休息，完全无需担心。趁着年轻，你要纪念你的造物主。尽管无忧无虑地在黎明醒来，踏上探险的征途。</li><li>别让谋生成为苦差事，而是让它成为娱乐活动。</li></ol></li><li><p>【更高的法则】</p><ol><li>我认为白水是唯一适合智者的饮料。（哈哈哈，我也在尝试，因为听说那样对皮肤好。）</li><li>心智尚处于胚胎期的成年人要当过猎人才能真正的成熟。</li><li>我们都知道自己内心有只猛兽，我们的高尚本性越是昏昏欲睡，它就越是清醒。（孩子成为大人，我们做过错事，才懂得成为正途上的人儿；我们要学会控制内心的欲望深渊。）</li></ol></li><li><p>【冬天的湖】</p><ol><li>我们对规律与和谐的了解，往往局限于那些我们已经掌握的事例。</li></ol></li><li><p>【春天】</p><ol><li>其实幸福的人应该永远生活在此刻，好好利用每件事落到我们身上的琐事。</li><li>别把时间用于挽回从前失去的机会，并美其名曰承担责任。明明春天已经来临，我们却还在冬天里流连。</li></ol></li><li><p>【结】</p><ol><li>将目光转向内部吧，你将会发现，你的精神世界有数以千计的区域，尚未被发现。去游览这些区域吧，要成为精通内在宇宙情况的专家。</li><li>去探索你内心偏远的地方。</li><li>但人生的目标并非自己持有这种敌视社会的态度，而是始终能够做他自己，遵从自己的原则。</li><li>如果人自信地朝着梦想的地方前进，努力去过上他事先设想的生活，他将会取的普通人想象不到的成功。</li><li>我们应该抱着开放的态度，顺其自然，别明确地限定我们将来应该是什么模样；至于过去活着从前，那就像我们的影子，无非是表明我们还在阳光下活着而已，应该将其抛在身后。</li><li>让每个人去管他自己的事吧。</li><li>去找旧东西吧，回去找他们。事物不会改变，变的是我们。</li></ol></li></ul><h2 id="《百年孤独》"><a href="#《百年孤独》" class="headerlink" title="《百年孤独》"></a>《百年孤独》</h2><ol><li>过去都是假的，回忆是一条没有归途的路，以往的一切春天都无法复原，即使最狂热最坚贞的爱情，归根结底也不过是一种瞬息即逝的现实，唯有孤独永恒。</li><li>生命中真正重要的不是你遭遇了什么，而是你记住了哪些事，又是如何铭记。</li><li>所有人都显得很寂寞，用自己的方式想尽办法，排遣寂寞，事实上仍是延续自己的寂寞，寂寞是造化对群居者的诅咒，孤独才是寂寞的唯一出口。</li><li>或许不久之后，或者不用多久，个把月时间，马孔多的居民们就像忘记香蕉公司的存在过那般，忘记那某一个家族的存在过，忘记了那最豪华的宅屋曾经的主人，以及由来，被人遗忘，作为鬼魂也孤独，频频出现的灵魂，似乎只是在印证第一代的精神继承。</li></ol><h2 id="《了不起的盖茨比》"><a href="#《了不起的盖茨比》" class="headerlink" title="《了不起的盖茨比》"></a>《了不起的盖茨比》</h2><ol><li>每逢你想要批评任何人的时候，你就要记住，这个世界上的人，并不是个个都有过你拥有的那些优越条件。（这里的批评，换成了质疑，以及其他各种情况都行；并不是所有人都经历了你的经历，想法都是自然有所不同的呀。）</li><li>盖茨比从年轻时起就一心要追求“一个绚丽得无法形容的宇宙”。实际上长岛西卵的杰伊.盖茨比来自他对自己柏拉图式的理念。他是上帝的儿子…因此他必须为他的天父效命，献身于一种博大庸俗，华而不实的美。</li><li>一旦爱上了“黄金女郎”，他那些无法形容的憧憬和她短暂的呼吸就结合在一起了，她成为他理想的化身，尽管黛西早已移情别恋，尽管他清楚的听出“她的声音充满了金钱”，他仍不改初衷，固执地追求重温旧梦。</li><li>黛西远不如他的梦想，并不是她本人的过错，而是由于他的幻梦有巨大的活力。他的幻梦超越了她，超越了一切，他以一种创造性的热情投入了这个幻梦，不断地添枝加叶，用飘来的每一根羽毛加以缀饰。</li><li>因此，他对理想的执着追求和献身精神也超越了世俗的男欢女爱的恩怨。为了抱着一个梦太久而付出很高的代价，’他一定透过可怕的树叶仰视过一片陌生的天空而感到毛骨悚然，同时发觉一朵玫瑰花是多么丑恶的东西，阳光照在刚刚露头的小草上又是多么残酷。</li><li>他的灵魂在受难，但是他无怨无悔，从一而终。</li></ol><h2 id="《岛上书店》"><a href="#《岛上书店》" class="headerlink" title="《岛上书店》"></a>《岛上书店》</h2><ol><li>来吧，亲爱的，且让我们来相爱，趁你我尚在人世。</li><li>无人为孤岛。</li><li>我们在二十岁时有共鸣的东西到了四十岁的时候不一定能产生共鸣。</li><li>生活中每一桩糟糕事，几乎都是时机不当的结果，每件好事，都是时机恰到好处的结果。</li><li>“亲爱的阿米莉亚，如果你要一直等到奈特利的秋季书目出来才会再来爱丽丝岛，我真觉得我会无法忍受”。——（全书最佳）</li><li>因为从心底害怕自己不值得被爱，我们独来独往，“然而就是因为独来独往，才让我们以为自己不值得被爱。有一天，你不知道是什么时候，你会驱车上路。有一天，你不知道是什么时候，你会遇上他。你会被爱，因为你今生第一次真正不再孤单。你会选择不再孤单下去。</li><li>我的一部分也死了，很可能直到我遇见你。</li><li>为什么我们写我们不喜欢，讨厌，承认有缺点的事物，要比我们喜爱的事物容易得多？</li><li>我不是为你哭，我为我自己哭。你知道我花了多久才找到你？你知道我经历了多少次糟糕的约会？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书V生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书籍摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello</title>
      <link href="/2019/01/22/2019/hello-world/"/>
      <url>/2019/01/22/2019/hello-world/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到JAYANT BLOG! .</p><h2 id="开头语"><a href="#开头语" class="headerlink" title="开头语"></a>开头语</h2><p>跟随着网上的多种搭建方式，搭建除了属于自己的hexo博客，兴奋之余也非常期待我能给予这个博客不同的“知识”生命力，也期待我所记录下的多种多样，各方各面的博文内容可以给来到这个网站上的朋友们带来帮助</p><p>之后也将陆陆续续将之前的博文迁移过来；</p><p><img src="/2019/01/22/2019/hello-world/MyPic.png" alt="心中藏之无日忘之" title="心中藏之，无日忘之"></p><h2 id="❤404-NOT-FOUND"><a href="#❤404-NOT-FOUND" class="headerlink" title="❤404 NOT FOUND"></a>❤404 NOT FOUND</h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常碎碎 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
