<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <title>JS设计模式 | Jayant Blog</title>
  <meta name="keywords" content=" JavaScript ">
  <meta name="description" content="JS设计模式 | Jayant Blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="许俊彦96年小青年，目前大四，就读于广东药科大学，现在深圳在职，从事前端开发，有团队开发合作经验，积极向上，对于前端领域研究有着十足的兴趣。在成长着，也努力着… 邮箱：jayant_xu@qq.com　期待你的联系 教育经历2015-9　至　2019-6　　　　广东药科大学　　　　信息管理与信息系统 主修课程：Java程序设计、计算机网络、数据结构、UML系统建模、Web程序设计、Linux、数据">
<meta property="og:type" content="website">
<meta property="og:title" content="关于我">
<meta property="og:url" content="http://jayantxu.cn/about/index.html">
<meta property="og:site_name" content="Jayant Blog">
<meta property="og:description" content="许俊彦96年小青年，目前大四，就读于广东药科大学，现在深圳在职，从事前端开发，有团队开发合作经验，积极向上，对于前端领域研究有着十足的兴趣。在成长着，也努力着… 邮箱：jayant_xu@qq.com　期待你的联系 教育经历2015-9　至　2019-6　　　　广东药科大学　　　　信息管理与信息系统 主修课程：Java程序设计、计算机网络、数据结构、UML系统建模、Web程序设计、Linux、数据">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2021-06-13T15:17:55.993Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="关于我">
<meta name="twitter:description" content="许俊彦96年小青年，目前大四，就读于广东药科大学，现在深圳在职，从事前端开发，有团队开发合作经验，积极向上，对于前端领域研究有着十足的兴趣。在成长着，也努力着… 邮箱：jayant_xu@qq.com　期待你的联系 教育经历2015-9　至　2019-6　　　　广东药科大学　　　　信息管理与信息系统 主修课程：Java程序设计、计算机网络、数据结构、UML系统建模、Web程序设计、Linux、数据">


<link rel="icon" href="/img/MyPic.png">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/gruvbox-dark.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0"></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js"></script>

<script src="/js/iconfont.js?v=1.1.0"></script>

</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value>
  <input class="theme_blog_path" value>
  <input id="theme_shortcut" value="true">
  <input id="theme_highlight_on" value="true">
  <input id="theme_code_copy" value="true">
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/MyPic.png">
</a>
<div class="author">
    <span>Jayantxu</span>
</div>

<div class="icon">
    
        
            <a title="github" href="https://github.com/Jayantxu" target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"/>
                    </svg>
                
            </a>
        
    
        
            <a title="email" href="mailto:Jayant_xu@qq.com" target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"/>
                    </svg>
                
            </a>
        
    
        
            <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=591060601&site=qq&menu=yes" target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"/>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <!-- <div class="all active" data-rel="全部文章">全部文章
            
                <small>(68)</small>
            
        </div> -->
    </li>
    
        
            
                <li>
                    <div data-rel="前端">
                        
                        前端
                        <small>(51)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="后端">
                        
                        后端
                        <small>(3)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="工具">
                        
                        工具
                        <small>(9)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="读书V生活">
                        
                        读书V生活
                        <small>(5)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
    </div>
    <div>
        
            <a class="about  site_url" href="/about">关于</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="68">
<input type="hidden" id="yelog_site_word_count" value="73k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off">
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search">
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Adv</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Axios</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Bug</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>canvas</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>CSS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Element</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Express</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Git</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Gulp</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>HTML</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>HTTP</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Interview</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>JavaScipt</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>JavaScript</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>MySQL</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Node</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Stylus</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Vue</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Web</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>WebPack</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>书籍摘录</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>布局</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>日常碎碎</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>源码</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>算法</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>踩坑</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>转载</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a id="top" class="全部文章 前端 " href="/2019/01/22/2019/hello-world/" data-tag="日常碎碎" data-author>
            <span class="post-title" title="Hello">Hello</span>
            <span class="post-date" title="2019-01-22 21:45:11">2019/01/22</span>
        </a>
        
        <a id="top" class="全部文章 前端 " href="/2021/06/01/2021/rJUI&vJUI/" data-tag="JavaScript,HTML" data-author>
            <span class="post-title" title="rJUI&amp;vJUI✨✨✨">rJUI&amp;vJUI✨✨✨</span>
            <span class="post-date" title="2021-06-01 22:23:03">2021/06/01</span>
        </a>
        
        <a id="top" class="全部文章 前端 " href="/2021/05/26/2021/批量数据绘制心得/" data-tag="JavaScript,Web" data-author>
            <span class="post-title" title="大量/批量数据优化总结">大量/批量数据优化总结</span>
            <span class="post-date" title="2021-05-26 20:23:03">2021/05/26</span>
        </a>
        
        <a id="top" class="全部文章 前端 " href="/2021/05/07/2021/SKU商品属性组合实践/" data-tag="JavaScript" data-author>
            <span class="post-title" title="SKU商品属性组合实践">SKU商品属性组合实践</span>
            <span class="post-date" title="2021-05-07 16:22:31">2021/05/07</span>
        </a>
        
        <a id="top" class="全部文章 前端 " href="/2020/03/30/2020/轮播/" data-tag="JavaScript,CSS" data-author>
            <span class="post-title" title="模拟生成虚拟3D轮播结构">模拟生成虚拟3D轮播结构</span>
            <span class="post-date" title="2020-03-30 17:30:29">2020/03/30</span>
        </a>
        
        <a id="top" class="全部文章 前端 " href="/2020/02/15/2020/adv/" data-tag="JavaScript,Vue,Adv" data-author>
            <span class="post-title" title="adv">adv</span>
            <span class="post-date" title="2020-02-15 00:00:00">2020/02/15</span>
        </a>
        
        <a id="top" class="全部文章 前端 " href="/2020/01/07/2020/费舍尔-耶茨混洗/" data-tag="JavaScript,算法" data-author>
            <span class="post-title" title="借鉴费舍尔.耶茨混洗优化公司年会抽奖">借鉴费舍尔.耶茨混洗优化公司年会抽奖</span>
            <span class="post-date" title="2020-01-07 00:00:00">2020/01/07</span>
        </a>
        
        <a id="top" class="全部文章 前端 " href="/2019/10/08/2019/canvas进行图像像素点着色/" data-tag="canvas" data-author>
            <span class="post-title" title="基于Canvas进行像素分析，结合数据进行实时着色">基于Canvas进行像素分析，结合数据进行实时着色</span>
            <span class="post-date" title="2019-10-08 18:35:35">2019/10/08</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/04/12/2021/浏览器的多线程/" data-tag="JavaScript,HTTP" data-author>
            <span class="post-title" title="浏览器的多线程">浏览器的多线程</span>
            <span class="post-date" title="2021-04-12 19:10:48">2021/04/12</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/04/07/2021/HTTP1-HTTP1-1-HTTP2-HTTPS-HTTP3的区别特点/" data-tag="HTTP,Web" data-author>
            <span class="post-title" title="HTTP1-HTTP1.1-HTTP2-HTTPS-HTTP3的区别特定">HTTP1-HTTP1.1-HTTP2-HTTPS-HTTP3的区别特定</span>
            <span class="post-date" title="2021-04-07 14:45:27">2021/04/07</span>
        </a>
        
        <a class="全部文章 读书V生活 " href="/2021/04/05/2021/github的3D打印/" data-tag="日常碎碎" data-author>
            <span class="post-title" title="有趣-github的3D打印">有趣-github的3D打印</span>
            <span class="post-date" title="2021-04-05 00:00:00">2021/04/05</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/04/02/2021/十大排序/" data-tag="JavaScript" data-author>
            <span class="post-title" title="十大排序">十大排序</span>
            <span class="post-date" title="2021-04-02 11:10:07">2021/04/02</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/04/01/2021/JS手写Promise/" data-tag="JavaScript,转载" data-author>
            <span class="post-title" title="JS手写Promise">JS手写Promise</span>
            <span class="post-date" title="2021-04-01 20:08:55">2021/04/01</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/02/26/2021/HTTP缓存/" data-tag="HTTP" data-author>
            <span class="post-title" title="HTTP缓存">HTTP缓存</span>
            <span class="post-date" title="2021-02-26 00:00:00">2021/02/26</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/02/21/2021/TCP与UDP的区别/" data-tag="HTTP,Web" data-author>
            <span class="post-title" title="TCP与UDP的区别">TCP与UDP的区别</span>
            <span class="post-date" title="2021-02-21 22:23:03">2021/02/21</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/01/08/2021/JS与stylus与CSSVar的相互作用/" data-tag="JavaScript,CSS,Stylus" data-author>
            <span class="post-title" title="JS与stylus与CSSVar的相互作用">JS与stylus与CSSVar的相互作用</span>
            <span class="post-date" title="2021-01-08 00:00:00">2021/01/08</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/01/01/web/interview/" data-tag="Web,Interview" data-author>
            <span class="post-title" title="interview">interview</span>
            <span class="post-date" title="2021-01-01 00:00:00">2021/01/01</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/01/01/web/HTTP/" data-tag="HTTP,Web,Interview" data-author>
            <span class="post-title" title="HTTP">HTTP</span>
            <span class="post-date" title="2021-01-01 00:00:00">2021/01/01</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/01/01/web/Vue/" data-tag="Vue,Web,Interview" data-author>
            <span class="post-title" title="Vue">Vue</span>
            <span class="post-date" title="2021-01-01 00:00:00">2021/01/01</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/01/01/web/webpack/" data-tag="Web,Interview,WebPack" data-author>
            <span class="post-title" title="WebPack">WebPack</span>
            <span class="post-date" title="2021-01-01 00:00:00">2021/01/01</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/01/01/web/JS/" data-tag="JavaScript,Web,Interview" data-author>
            <span class="post-title" title="JS">JS</span>
            <span class="post-date" title="2021-01-01 00:00:00">2021/01/01</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/01/01/web/CSS/" data-tag="CSS,Web,Interview" data-author>
            <span class="post-title" title="CSS&amp;HTML">CSS&amp;HTML</span>
            <span class="post-date" title="2021-01-01 00:00:00">2021/01/01</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/12/26/2020/stylus-media/" data-tag="CSS,Stylus" data-author>
            <span class="post-title" title="stylus_media">stylus_media</span>
            <span class="post-date" title="2020-12-26 11:30:02">2020/12/26</span>
        </a>
        
        <a class="全部文章 读书V生活 " href="/2020/12/01/2020/My/" data-tag="日常碎碎" data-author>
            <span class="post-title" title="My">My</span>
            <span class="post-date" title="2020-12-01 20:09:10">2020/12/01</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/11/05/2020/网络七层结构/" data-tag="HTTP" data-author>
            <span class="post-title" title="网络七层结构">网络七层结构</span>
            <span class="post-date" title="2020-11-05 11:20:37">2020/11/05</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/10/28/2020/HTTP常见状态码/" data-tag="HTTP" data-author>
            <span class="post-title" title="HTTP常见状态码">HTTP常见状态码</span>
            <span class="post-date" title="2020-10-28 09:29:34">2020/10/28</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/09/29/2020/JS设计模式/" data-tag="JavaScript" data-author>
            <span class="post-title" title="JS设计模式">JS设计模式</span>
            <span class="post-date" title="2020-09-29 21:56:10">2020/09/29</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/09/28/2020/JS模块化演进/" data-tag="JavaScript" data-author>
            <span class="post-title" title="JS模块化演进">JS模块化演进</span>
            <span class="post-date" title="2020-09-28 09:21:32">2020/09/28</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/09/23/2020/垃圾回收机制/" data-tag="JavaScript" data-author>
            <span class="post-title" title="垃圾回收机制">垃圾回收机制</span>
            <span class="post-date" title="2020-09-23 22:39:54">2020/09/23</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/08/11/2020/XSS-CSRF/" data-tag="JavaScript,HTTP" data-author>
            <span class="post-title" title="XSS-CSRF-Cookie">XSS-CSRF-Cookie</span>
            <span class="post-date" title="2020-08-11 21:57:03">2020/08/11</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/07/09/2020/三次握手四次挥手/" data-tag="HTTP" data-author>
            <span class="post-title" title="三次握手四次挥手WebSocket握手">三次握手四次挥手WebSocket握手</span>
            <span class="post-date" title="2020-07-09 21:09:28">2020/07/09</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/07/09/2020/HTTPS连接过程/" data-tag="HTTP" data-author>
            <span class="post-title" title="HTTPS连接过程">HTTPS连接过程</span>
            <span class="post-date" title="2020-07-09 00:00:00">2020/07/09</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/06/30/2020/async-await原理/" data-tag="JavaScript" data-author>
            <span class="post-title" title="async/await原理">async/await原理</span>
            <span class="post-date" title="2020-06-30 20:03:07">2020/06/30</span>
        </a>
        
        <a class="全部文章 工具 " href="/2020/06/21/2020/Vue数据双向绑定原理/" data-tag="Vue" data-author>
            <span class="post-title" title="Vue响应式原理">Vue响应式原理</span>
            <span class="post-date" title="2020-06-21 20:02:10">2020/06/21</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/06/12/2020/EventLoop/" data-tag="JavaScript" data-author>
            <span class="post-title" title="EventLoop">EventLoop</span>
            <span class="post-date" title="2020-06-12 12:20:39">2020/06/12</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/05/11/2020/cors跨域/" data-tag="JavaScript,HTTP" data-author>
            <span class="post-title" title="跨域访问">跨域访问</span>
            <span class="post-date" title="2020-05-11 20:38:10">2020/05/11</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/02/03/2020/重绘回流/" data-tag="JavaScript,CSS,HTML" data-author>
            <span class="post-title" title="重绘回流">重绘回流</span>
            <span class="post-date" title="2020-02-03 00:00:00">2020/02/03</span>
        </a>
        
        <a class="全部文章 工具 " href="/2020/01/27/2020/Vue的Keep-alive/" data-tag="Vue" data-author>
            <span class="post-title" title="Vue的Keep-alive组件">Vue的Keep-alive组件</span>
            <span class="post-date" title="2020-01-27 20:17:56">2020/01/27</span>
        </a>
        
        <a class="全部文章 工具 " href="/2020/01/23/2020/Vue的nextTick剖析/" data-tag="Vue" data-author>
            <span class="post-title" title="Vue的nextTick剖析">Vue的nextTick剖析</span>
            <span class="post-date" title="2020-01-23 16:42:30">2020/01/23</span>
        </a>
        
        <a class="全部文章 工具 " href="/2020/01/17/2020/Vue-Diff/" data-tag="Vue,转载" data-author>
            <span class="post-title" title="Vue虚拟节点VNodeDiff算法">Vue虚拟节点VNodeDiff算法</span>
            <span class="post-date" title="2020-01-17 20:17:56">2020/01/17</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/12/15/2019/JS原型链/" data-tag="JavaScipt" data-author>
            <span class="post-title" title="JS原型链">JS原型链</span>
            <span class="post-date" title="2019-12-15 22:48:23">2019/12/15</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/11/01/2019/踩坑eCharts参数/" data-tag="踩坑" data-author>
            <span class="post-title" title="踩坑eCharts参数">踩坑eCharts参数</span>
            <span class="post-date" title="2019-11-01 18:51:02">2019/11/01</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/10/17/2019/this指向/" data-tag="JavaScript" data-author>
            <span class="post-title" title="this指向">this指向</span>
            <span class="post-date" title="2019-10-17 22:33:39">2019/10/17</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/09/26/2019/一个失焦指令的学习/" data-tag="Vue,Element" data-author>
            <span class="post-title" title="一个失焦指令的学习">一个失焦指令的学习</span>
            <span class="post-date" title="2019-09-26 17:41:35">2019/09/26</span>
        </a>
        
        <a class="全部文章 读书V生活 " href="/2019/06/27/2019/毕业了/" data-tag="日常碎碎" data-author>
            <span class="post-title" title="毕业了">毕业了</span>
            <span class="post-date" title="2019-06-27 19:48:20">2019/06/27</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/05/13/2019/Flex布局的基本属性介绍/" data-tag="CSS,布局" data-author>
            <span class="post-title" title="Flex布局的基本属性介绍">Flex布局的基本属性介绍</span>
            <span class="post-date" title="2019-05-13 13:22:26">2019/05/13</span>
        </a>
        
        <a class="全部文章 工具 " href="/2019/04/09/2019/Gulp源码分析学习-三/" data-tag="Gulp,源码" data-author>
            <span class="post-title" title="Gulp源码分析学习(三">Gulp源码分析学习(三</span>
            <span class="post-date" title="2019-04-09 08:51:45">2019/04/09</span>
        </a>
        
        <a class="全部文章 工具 " href="/2019/04/06/2019/Gulp源码分析学习-二/" data-tag="Gulp,源码" data-author>
            <span class="post-title" title="Gulp源码分析学习(二">Gulp源码分析学习(二</span>
            <span class="post-date" title="2019-04-06 13:47:27">2019/04/06</span>
        </a>
        
        <a class="全部文章 工具 " href="/2019/04/05/2019/Gulp源码分析学习-一/" data-tag="Gulp,源码" data-author>
            <span class="post-title" title="Gulp源码分析学习(一">Gulp源码分析学习(一</span>
            <span class="post-date" title="2019-04-05 16:41:26">2019/04/05</span>
        </a>
        
        <a class="全部文章 后端 " href="/2019/03/30/2019/Node读取图片并转Base64/" data-tag="Node" data-author>
            <span class="post-title" title="Node读取图片并转Base64">Node读取图片并转Base64</span>
            <span class="post-date" title="2019-03-30 00:12:42">2019/03/30</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/03/26/2019/Grid布局/" data-tag="转载,CSS,布局" data-author>
            <span class="post-title" title="Grid布局">Grid布局</span>
            <span class="post-date" title="2019-03-26 10:50:48">2019/03/26</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/03/03/2019/阻止冒泡、默认事件/" data-tag="JavaScript,HTML" data-author>
            <span class="post-title" title="阻止冒泡、默认事件">阻止冒泡、默认事件</span>
            <span class="post-date" title="2019-03-03 20:30:42">2019/03/03</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/03/03/2019/CSS清除浮动/" data-tag="CSS" data-author>
            <span class="post-title" title="CSS清除浮动的几种方式">CSS清除浮动的几种方式</span>
            <span class="post-date" title="2019-03-03 19:29:44">2019/03/03</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/03/01/2019/margin重叠以及解决办法/" data-tag="JavaScript,CSS,HTML" data-author>
            <span class="post-title" title="margin重叠以及解决办法">margin重叠以及解决办法</span>
            <span class="post-date" title="2019-03-01 23:15:21">2019/03/01</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/03/01/2019/CSS省略号实现/" data-tag="CSS,HTML" data-author>
            <span class="post-title" title="CSS省略号实现">CSS省略号实现</span>
            <span class="post-date" title="2019-03-01 16:09:35">2019/03/01</span>
        </a>
        
        <a class="全部文章 工具 " href="/2019/02/21/2019/Gulp增量编译优化/" data-tag="JavaScript,Gulp" data-author>
            <span class="post-title" title="Gulp增量编译优化">Gulp增量编译优化</span>
            <span class="post-date" title="2019-02-21 20:14:45">2019/02/21</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/02/18/2019/JavaScript深浅拷贝/" data-tag="JavaScript" data-author>
            <span class="post-title" title="JavaScript深浅拷贝">JavaScript深浅拷贝</span>
            <span class="post-date" title="2019-02-18 20:06:36">2019/02/18</span>
        </a>
        
        <a class="全部文章 后端 " href="/2019/02/10/2019/Node-express文件上传下载/" data-tag="HTML,Node,Express,Element" data-author>
            <span class="post-title" title="Node+Express+Element实现文件上传下载">Node+Express+Element实现文件上传下载</span>
            <span class="post-date" title="2019-02-10 20:59:42">2019/02/10</span>
        </a>
        
        <a class="全部文章 读书V生活 " href="/2019/02/08/2019/新年快乐/" data-tag="日常碎碎" data-author>
            <span class="post-title" title="新年快乐">新年快乐</span>
            <span class="post-date" title="2019-02-08 22:41:02">2019/02/08</span>
        </a>
        
        <a class="全部文章 后端 " href="/2019/02/02/2019/Node-MySQL释放数据库连接的Bug/" data-tag="Node,Express,MySQL,Bug" data-author>
            <span class="post-title" title="Node+MySQL释放数据库连接的Bug">Node+MySQL释放数据库连接的Bug</span>
            <span class="post-date" title="2019-02-02 19:42:07">2019/02/02</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/02/02/2019/transform对fixed/" data-tag="CSS,Bug" data-author>
            <span class="post-title" title="transform父元素对fixed子元素的影响">transform父元素对fixed子元素的影响</span>
            <span class="post-date" title="2019-02-02 10:16:34">2019/02/02</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/02/02/2019/Vue父子通信/" data-tag="JavaScript,Vue" data-author>
            <span class="post-title" title="Vue父子组件间的通信">Vue父子组件间的通信</span>
            <span class="post-date" title="2019-02-02 09:45:31">2019/02/02</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/01/31/2019/Axios使用/" data-tag="JavaScript,Vue,Axios" data-author>
            <span class="post-title" title="Axios使用">Axios使用</span>
            <span class="post-date" title="2019-01-31 15:14:03">2019/01/31</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/01/24/2019/手写new-call-apply-bind/" data-tag="JavaScript" data-author>
            <span class="post-title" title="手写new、call、apply、bind">手写new、call、apply、bind</span>
            <span class="post-date" title="2019-01-24 19:21:39">2019/01/24</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/01/23/2019/JavaScript继承/" data-tag="JavaScript" data-author>
            <span class="post-title" title="JavaScript继承">JavaScript继承</span>
            <span class="post-date" title="2019-01-23 15:29:41">2019/01/23</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/01/23/2019/JavaScript创建对象/" data-tag="JavaScript" data-author>
            <span class="post-title" title="JavaScript创建对象">JavaScript创建对象</span>
            <span class="post-date" title="2019-01-23 14:10:25">2019/01/23</span>
        </a>
        
        <a class="全部文章 工具 " href="/2019/01/23/2019/Git相关命令/" data-tag="Git" data-author>
            <span class="post-title" title="Git相关命令">Git相关命令</span>
            <span class="post-date" title="2019-01-23 09:45:11">2019/01/23</span>
        </a>
        
        <a class="全部文章 读书V生活 " href="/2019/01/23/2019/阅读摘录/" data-tag="书籍摘录" data-author>
            <span class="post-title" title="阅读摘录">阅读摘录</span>
            <span class="post-date" title="2019-01-23 08:56:01">2019/01/23</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-2020/JS设计模式" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">JS设计模式</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a data-rel="前端">前端</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color1">JavaScript</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title="最后更新: 2021-06-19 17:13:13">2020-09-29 21:56</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:4.6k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#前文"><span class="toc-text">前文</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#构造器模式"><span class="toc-text">构造器模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#模块化模式"><span class="toc-text">模块化模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#暴露模块模式"><span class="toc-text">暴露模块模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单例模式"><span class="toc-text">单例模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#观察者模式"><span class="toc-text">观察者模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#发布订阅模式"><span class="toc-text">发布订阅模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#中介者模式"><span class="toc-text">中介者模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原型模式"><span class="toc-text">原型模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命令模式"><span class="toc-text">命令模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#外观模式"><span class="toc-text">外观模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#工厂模式"><span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mixin模式"><span class="toc-text">Mixin模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#装饰模式"><span class="toc-text">装饰模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建者模式"><span class="toc-text">创建者模式</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-6 i,
    .toc-level-6 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h3><p>本篇将介绍以下几种设计模式：</p>
<ol>
<li>构造器模式</li>
<li>模块化模式</li>
<li>暴露模块模式</li>
<li>单例模式</li>
<li>观察者模式</li>
<li>发布订阅模式</li>
<li>中介者模式</li>
<li>原型模式</li>
<li>命令模式</li>
<li>外观模式</li>
<li>工厂模式</li>
<li>Mixin模式</li>
<li>装饰模式</li>
<li>MVC模式</li>
<li>创建者模式</li>
</ol>
<a id="more"></a>
<p>对于JSer来说，可能实际开发上用到的可能会没有那么多，但是学学也不错😭，（本菜可能接触的也不过几种）。</p>
<h4 id="构造器模式"><a href="#构造器模式" class="headerlink" title="构造器模式"></a>构造器模式</h4><ol>
<li>构造函数：<br>在这个构造器内部，关键字this引用到刚被创建的对象。回到对象创建，一个基本的构造函数看起来像这样:</li>
</ol>
<pre><code>
function Car(model, year, miles) {
    this.model = model;
    this.year = year;
    this.miles = miles;

    this.toString = function() {
        return `${this.model} + ${this.year} + ${this.miles}`;
    }
}
var civic = new Car( &quot;Honda Civic&quot;, 2009, 20000 );
var mondeo = new Car( &quot;Ford Mondeo&quot;, 2010, 5000 );
console.log(civic.toString());
</code></pre><p>缺陷: 每个对象都会带上 <code>toString</code> 之类的函数</p>
<ol start="2">
<li>原型链版构造器</li>
</ol>
<pre><code>
function Car_prop( model, year, miles ) {
    this.model = model;
    this.year = year;
    this.miles = miles;
}

Car_prop.prototype.toString = function () {
    return this.model + &quot; has done &quot; + this.miles + &quot; miles&quot;;
};


var civic_prop = new Car_prop( &quot;Honda Civic&quot;, 2009, 20000 );
var mondeo_prop = new Car_prop( &quot;Ford Mondeo&quot;, 2010, 5000 );
console.log(civic_prop.toString());
</code></pre><h4 id="模块化模式"><a href="#模块化模式" class="headerlink" title="模块化模式"></a>模块化模式</h4><ol>
<li>模块化模式最初被定义为一种对传统软件工程中的类提供私有和公共封装的方法。</li>
<li>通过这种方式 可以在单一对象中包含公共/私有方法和变量</li>
</ol>
<pre><code>var testModuleMode = (function() {
    var counter = 0;
    return {
        incrementCounter: function() {
            return counter++;
        },
        resetCounter: function() {
            console.log(`reset counter`);
            counter = 0;
        }
    }
})();
testModule.incrementCounter();
testModule.resetCounter();
</code></pre><p><em>进阶</em></p>
<p>包含了命名控件，公共变量，私有变量，潜藏闭包的形式</p>
<pre><code>var mySpaceName = (function() {
    var myPrivateVar = 0;
    var myPrivateMethod = function(foo) {
        console.log(foo);
    }
    return {
        myPublicVar: &#39;Foo&#39;,
        muPubliceMethod: function(bar) {
            myPrivateVar++;
            myPrivateMethod(bar)
        }
    }

})
</code></pre><p>缺陷：定义了公共/私用成员 但是要改的时候 就得在成员的方法上修改代码</p>
<h4 id="暴露模块模式"><a href="#暴露模块模式" class="headerlink" title="暴露模块模式"></a>暴露模块模式</h4><ol>
<li>我们可以简单地在私有域中定义我们所有的函数和变量，并且返回一个匿名对象，这个对象包含有一些指针，这些指针指向我们想要暴露出来的私有成员，使这些私有成员公有化</li>
<li>这个模式可以用于将私有函数和属性以更加规范的命名方式展现出来。</li>
</ol>
<pre><code>var myRevealingModule = function () {

    var privateVar = &quot;Ben Cherry&quot;,
        publicVar  = &quot;Hey there!&quot;;

    function privateFunction() {
        console.log( &quot;Name:&quot; + privateVar );
    }

    function publicSetName( strName ) {
        privateVar = strName;
    }

    function publicGetName() {
        privateFunction();
    }
    // Reveal public pointers to 
    // private functions and properties
    return {
        setName: publicSetName,
        greeting: publicVar,
        getName: publicGetName
    };

}();

myRevealingModule.setName( &quot;Paul Kinlan&quot; );
</code></pre><ul>
<li>优势: 使脚本语法更加一致 公共访问更加清晰 增强了可读性</li>
<li>缺陷: <ol>
<li>这个模式的一个缺点是如果私有函数需要使用公有函数，那么这个公有函数在需要打补丁的时候就不能被重载。因为私有函数仍然使用的是私有的实现，并且这个模式不能用于公有成员，只用于函数。</li>
<li>公有成员使用私有成员也遵循上面不能打补丁的规则。因为上面的原因，使用暴露式模块模式创建的模块相对于原始的模块模式更容易出问题，因此在使用的时候需要小心。</li>
</ol>
</li>
</ul>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><ul>
<li>特点：唯一、全局访问</li>
</ul>
<ol>
<li>简单版单例</li>
</ol>
<pre><code>let singleton = function(name) {
    this.name = name;
    this.instance = null;
}
singleton.prototype.getName = function() {
    console.log(this.name);
}
singleton.getInstance = function(name){
    if(this.instace){
        return this.instance; 
    }
    return this.instance = new Singleton(name);
}
let sunner = Singleton.getInstance(&quot;sunner&quot;);   //winner
console.log(sunner.getName())
</code></pre><p>不足：创建对象和实例操作耦合在一起 不符合 单一职责</p>
<ol start="2">
<li><p>改良版，使用闭包</p>
<pre><code>let createSingleton = (function() {
 let instance = null;
 return function(name) {
     this.name = name;
     if(instance) {
         return instance;
     }
     return instance = this;
 }
})();
createSingleton.prototype.getName = function(){
 console.log(this.name);
}
let winner = new createSingleton(&quot;winner&quot;);  //winner
console.log(winner.getName());
</code></pre></li>
<li><p>代理版单例</p>
</li>
</ol>
<pre><code>let proxyCreateSingleton = function() {
    let instance = null;
    return function(name) {
        if(instance) { return instance }
        return instance = new singleProxy(name);
    }
}
function singleProxy(name) {
    this.name = name;
}
singleProxy.prototype.getName = function() {
    console.log(this.name);
}
let winner_Proxy = new proxyCreateSingleton(&quot;winner&quot;);
console.log(winner_Proxy.getName());

</code></pre><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>被观察者 - 观察者</p>
<ol>
<li>一个或者更多的观察者对一个被观察者的状态感兴趣，将自身的这种兴趣通过附着自身的方式注册在被观察者身上；</li>
<li>当被观察者发生变化，而这种便可也是观察者所关心的，就会产生一个通知，这个通知将会被送出去，最后将会调用每个观察者的更新方法；</li>
<li>当观察者不在对被观察者的状态感兴趣的时候，它们只需要简单的将自身剥离即可</li>
</ol>
<pre><code>/**

    Subject      (notify)-------&gt;      Observer1
        |
        |------(notify)---------&gt;       Observer2
        |
        |------(notify)---------&gt;       Observer3

 */

</code></pre><ol>
<li>实现ObserList</li>
</ol>
<pre><code>

function ObserverList(){
    this.observerList = [];
}
ObserverList.prototype.add = function( obj ){
    return this.observerList.push( obj );
};
ObserverList.prototype.count = function(){
    return this.observerList.length;
};
ObserverList.prototype.get = function( index ){
    if( index &gt; -1 &amp;&amp; index &lt; this.observerList.length ){
        return this.observerList[ index ];
    }
};
ObserverList.prototype.indexOf = function( obj, startIndex ){
    var i = startIndex;
    while( i &lt; this.observerList.length ){
        if( this.observerList[i] === obj ){
            return i;
        }
        i++;
    }
    return -1;
};
ObserverList.prototype.removeAt = function( index ){
    this.observerList.splice( index, 1 );
}
</code></pre><ol start="2">
<li>实现Subject</li>
</ol>
<pre><code>
function Subject(){
    this.observers = new ObserverList();
}
Subject.prototype.addObserver = function( observer ){
    this.observers.add( observer );
};
Subject.prototype.removeObserver = function( observer ){
    this.observers.removeAt( this.observers.indexOf( observer, 0 ) );
};
Subject.prototype.notify = function( context ){
    var observerCount = this.observers.count();
    for(var i=0; i &lt; observerCount; i++){
        this.observers.get(i).update( context );
    }
}
</code></pre><ol start="3">
<li>实现Observer </li>
</ol>
<pre><code>function Observer () {
    this.update = function () {
        // ...
    }
}
</code></pre><ol start="4">
<li>test</li>
</ol>
<pre><code>var subject = new Subject();

var observer1 = new Observer();
observer1.update = function () {
    console.log(&#39;observer1&#39;);
}
var observer2 = new Observer();
observer2.update = function () {
    console.log(&#39;observer2&#39;);
}
subject.addObserver(observer1);
subject.addObserver(observer2);
subject.notify();    // 输出 observer1 observer2
</code></pre><h4 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h4><ol>
<li><p>观察者对象是个消息容器 拥有订阅 发布订阅 取消订阅的消息方法</p>
<pre><code>var Observe = (function() {
 var topics = {}; // 回调函数存放的数组
 return {
     subscribe: function(type, fn) {
         // 如果此消息不存在则创建
         if (!topics[type]) {
             topics[type] = [];
         }
         // 将动作推入到该消息对应的动作执行序列中
         topics[type].push(fn);
     },
     publish: function(type, args) {
         // 如果该消息没有被注册，则返回
         if (!topics[type]) {
             return;
         }
         var self = this;
         setTimeout(function () {
             var subscribers = topics[type], len = subscribers ? subscribers.length: 0;
             for (var i = 0; i &lt; len; i++) {
                 // 依次执行注册的消息对应的动作序列
                 subscribers[i].call(self, args);
             }
         }, 0);
     },
     unsubscribe: function() {
         var subscribers = topics[type];
         // 判断是否存在    
         if (subscribers instanceof Array) {
             var i = subscribers.length - 1;
             for (;i &gt;= 0; i-- ) {
                 // 如果存在该动作则在消息动作序列中移除响应动作    
                 subscribers[i] === fn &amp;&amp; subscribers.splice(i, 1);
             }
         }
     }
 }
})();
</code></pre></li>
<li><p>test</p>
</li>
</ol>
<pre><code>
var listener1 = function (data) {
    console.log(&#39;listener1:&#39; + data);
}
var listener2 = function (data) {
    console.log(&#39;listener2:&#39; + data);
}
Observer.subscribe(&#39;example1&#39;, listener1);
Observer.subscribe(&#39;example1&#39;, listener2);

//发布通知
Observer.publish(&#39;example1&#39;, &#39;hello world!&#39;);
Observer.publish(&#39;example1&#39;, [&#39;test&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]);
// 取消订阅
Observer.unsubscribe(&#39;example1&#39;, listener2);
Observer.publish(&#39;example1&#39;, &#39;123&#39;);
</code></pre><ul>
<li><p>观察者与发布订阅的不同</p>
<ol>
<li>Publish/Subscribe(发布/订阅)模式使用一个主题/事件通道，这个通道介于订阅者和发布者之间；</li>
<li>该设计模式允许代码定义应用程序的特定事件，这些事件可以传递自定义参数，自定义参数包含订阅者需要的信息，采用事件通道可以避免发布者和订阅者之间产生依赖关系；</li>
<li>Observer(观察者)模式允许观察者实例对象(订阅者)执行适当的事件处理程序来注册和接收目标实例对象(发布者)发出的通知（即在观察者实例对象上注册update方法）。<br>使订阅者和发布者之间产生了依赖关系，且没有事件通道。</li>
</ol>
</li>
<li><p>优点: 解耦 @$%@#%</p>
</li>
<li>缺陷: 缺陷 具有不稳定性 发布订阅都是无状态的</li>
</ul>
<h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><ol>
<li>如果系统组件之间存在大量的直接关系，就可能是时候，使用一个中心的控制点，来让不同的组件通过它来通信；</li>
<li>中介者通过将组件之间显式的直接的引用替换成通过中心点来交互的方式，来做到松耦合。这样可以帮助我们解耦，和改善组件的重用性；</li>
<li>中介者模式主要用于一个系统中存在大量的对象，而且这些大量的对象需要互相通信，因为两个对象需要通信，一个对象必须要持有另一个对象，这样就会导致，系统里，每个对象都互相引用，会引起混乱，中介者把所有的对象都统一管理起来，其他的对象通过中介者去和别的对象通信。</li>
</ol>
<pre><code>function A(mediator) {
    this.mediator = mediator;
}
A.prototype = {
    send: function(msg,receiver) {
        this.mediator.send(msg,&#39;A&#39;,receiver);
    },
    receiveMsg: function(msg,sender) {
        console.log(sender+&quot; say:&quot;+msg)
    }
}
function B(mediator) {
    this.mediator = mediator;
}
B.prototype = {
    send: function(msg,receiver) {
        this.mediator.send(msg,&#39;B&#39;,receiver);
    },
    receiveMsg: function(msg,sender) {
        console.log(sender+&quot; say:&quot;+msg)
    }
}
function Mediator() {
    this.A = new A(this);
    this.B = new B(this);
}
Mediator.prototype = {
    send: function(msg,sender,receiver) {
        try {
            this[receiver].receiveMsg(msg,sender);
        }
        catch(err) {
            console.log(&#39;receiver &#39;+receiver+&#39; is not exsit&#39;);
            this[sender].receiveMsg(&#39;receiver &#39;+ receiver +&#39; is not exsit&#39;,&#39;mediator&#39;);
        }
    }
}
var _mediator = new Mediator();
var _a = new A(_mediator);
var _b = new B(_mediator);
_a.send(&#39;hello i am A&#39;,&#39;B&#39;);
_b.send(&#39;hello i am B&#39;,&#39;A&#39;);

</code></pre><ul>
<li>中介者模式</li>
</ul>
<pre><code>var mediator = (function() {

    var _channels = [],
        _subUid = -1

    function subscribe(channel, handler) {
      if(!_channels[channel]) _channels[channel] = []
      var token = (++_subUid).toString()
      _channels[channel].push({
        token: token,
        context: this,
        handler: handler
      })
      return token
    }
    function publish(channel, data) {
      if(!_channels[channel]) return false
      var subscribers = _channels[channel]
      var len = subscribers.length
      while(len--) {
        subscribers[len].handler.call(subscribers[len].context, data, channel, subscribers[len].token)
      }
      return this
    }
    function unsubscribe(token) {
      for(var channel in _channels) {
        var len = _channels[channel].length
        for(var index=0; index&lt;len; index++) {
          if(_channels[channel][index].token === token) {
            _channels[channel].splice(index, 1)
            return token
          }
        }
      }
    }
    // Module模式引出
    return {
      subscribe: subscribe,
      publish: publish,
      unsubscribe: unsubscribe,
      // 绑定到其他对象使用该设计模式
      installTo: function(obj) {
        obj.subscribe = subscribe
        obj.publish = publish 
        obj.unsubscribe = unsubscribe
      }
    }
})()

mediator.subscribe(&#39;message&#39;, function(data, channel, token) {
    // true
    console.log(this === mediator) 
    console.log(data)
    console.log(channel)
    console.log(token)
})
mediator.publish(&#39;message&#39;, &#39;hello world&#39;)
</code></pre><ol>
<li>Mediator(中介者)模式：单一目标通常有很多观察者，有时一个目标的观察者是另一个观察者的目标。通信可以实现双向</li>
<li>Observer(观察者)模式：不存在封装约束的单一对象，目标对象和观察者对象必须合作才能维持约束。 观察者对象向订阅它们的对象发布其感兴趣的事件。通信只能是单向的</li>
</ol>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><ol>
<li>原型模式引用为通过克隆的方式基于一个现有对象的模板创建对象的模式</li>
<li>原型模式可以让多个构造函数对应的实例对象共享同一个原型对象的属性和方法</li>
</ol>
<pre><code>var myCar = {
    name: &#39;a&#39;,
    drive: function() {},
    stop: function() {}
}
var carInstance = Object.create(myCar);
console.log(carInstance);
</code></pre><p><em>进阶</em></p>
<pre><code>var createProto = (function(){
    function Fconstructor() {}
    return function(_proto) {
        Fconstructor.prototype = _proto;
        return new Fconstructor();
    }
})()
</code></pre><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><ol>
<li>命令模式将命令执行者和命令发起者解耦，提供更大的整体灵活性。</li>
<li>用类来做比喻就是，抽象类（类似于命令发起者）定义一个接口，但不为它的成员函数提供实现，作为一个基类派生出其他类，派生类（类似于命令执行者）首先具体接口。</li>
</ol>
<pre><code>var clientCustom = {
    name: &#39;a&#39;
}
var cooker = {
    execute: function(food) {
        console.log(`do! ${food}`)
    }
}

function commandFunc(receiver, food) {
    this.receiver = receiver;
    this.food = food;
}
commandFunc.prototype.execute = function(cooker) {
    cooker.execute(this.food);
}

var orderCommand_1 = new commandFunc(clientCustom, &#39;菜1&#39;);
orderCommand_1.execute(cooker);
</code></pre><h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><ol>
<li>这一模式提供了面向一种更大型的代码体提供了一个的更高级别的舒适的接口，隐藏了其真正的潜在复杂性</li>
<li>把这一模式想象成要是呈现给开发者简化的API，一些总是会提升使用性能的东西</li>
</ol>
<pre><code>var module = (function() {
    var _private = {
        i:5,
        get : function() {
            console.log( &quot;current value:&quot; + this.i);
        },
        set : function( val ) {
            this.i = val;
        },
        run : function() {
            console.log( &quot;running&quot; );
        },
        jump: function(){
            console.log( &quot;jumping&quot; );
        }
    };
    return {
        facade : function( args ) {
            _private.set(args.val);
            _private.get();
            if ( args.run ) {
                _private.run();
            }
        }
    };
}());
module.facade( {run: true, val:10} );

</code></pre><pre><code>// 类似
var addMyEvent = function( el,ev,fn ){
    if( el.addEventListener ){
        el.addEventListener( ev,fn, false );
    }else if(el.attachEvent){
        el.attachEvent( &quot;on&quot; + ev, fn );
    } else{
        el[&quot;on&quot; + ev] = fn;
    }
 };
</code></pre><p><em>更多思路: 类似于检测浏览器版本、类型, 调用一个方法 方法内部再执行各种判断…</em></p>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><ol>
<li>工厂模式是另外一种关注对象创建概念的创建模式。它的领域中同其它模式的不同之处在于它并没有明确要求我们使用一个构造器；</li>
<li>取而代之，一个工厂能提供一个创建对象的公共接口，我们可以在其中指定我们希望被创建的工厂对象的类型；</li>
<li>试想一下，在我们被要求创建一种类型的UI组件时，我们就有一个UI工厂。并不是通过直接使用new操作符或者通过另外一个构造器来创建这个组件，我们取而代之的向一个工厂对象索要一个新的组件；</li>
<li>我们告知工厂我们需要什么类型的组件（例如：“按钮”，“面板”），而它会将其初始化，然后返回供我们使用。</li>
</ol>
<pre><code>function Car(options) {
    this.doors = options.doors || 4;
    this.state = options.state || &quot;brand new&quot;;
    this.color = options.color || &quot;silver&quot;;
}
function Trunk(options) {
    this.state = options.state || &quot;used&quot;;
    this.wheelSize = options.wheelSize || &quot;large&quot;;
    this.color = options.color || &quot;blue&quot;;
}
function VehicleFactory() {
    this.vehicleClass = Car;
}
VehicleFactory.prototype.createVehicle = function(options) {
    if(options.type === &#39;car&#39;) {
        this.vehicleClass.vehicleClass = Car;
    } else {
        this.vehicleClass.vehicleClass = Trunk;
    }
    return new this.vehicleClass(options);
}
var carFctory = new VehicleFactory();
var car = carFactory.createVehicle( {
    type: &quot;car&quot;,
    color: &quot;yellow&quot;,
    doors: 6 } 
);
// Outputs: true
console.log( car instanceof Car );
// Outputs: Car object of color &quot;yellow&quot;, doors: 6 in a &quot;brand new&quot; state
console.log( car );

</code></pre><p><em>什么时候使用？</em></p>
<ol>
<li>当我们的对象或者组件设置涉及到高程度级别的复杂度时；</li>
<li>当我们需要根据我们所在的环境方便的生成不同对象的实体时；</li>
<li>当我们在许多共享同一个属性的许多小型对象或组件上工作时；</li>
<li>当带有其它仅仅需要满足一种API约定(又名鸭式类型)的对象的组合对象工作时.这对于解耦来说是有用的。</li>
</ol>
<h4 id="Mixin模式"><a href="#Mixin模式" class="headerlink" title="Mixin模式"></a>Mixin模式</h4><ol>
<li>子类划分是一个参考了为一个新对象继承来自一个基类或者超类对象的属性的术语.在传统的面向对象编程中,类B能够从另外一个类A处扩展。</li>
<li>这里我们将A看做是超类,而将B看做是A的子类.如此,所有B的实体都从A处继承了其A的方法.然而B仍然能够定义它自己的方法,包括那些重载的原本在A中的定义的方法。</li>
<li>B是否应该调用已经被重载的A中的方法,我们将这个引述为方法链.B是否应该调用A(超类)的构造器,我们将这称为构造器链。</li>
</ol>
<pre><code>var Person =  function( firstName , lastName ){
    this.firstName = firstName;
    this.lastName =  lastName;
    this.gender = &quot;male&quot;;
};

var clark = new Person( &quot;Clark&quot; , &quot;Kent&quot; );
var Superhero = function( firstName, lastName , powers ){
    Person.call( this, firstName, lastName );
    this.powers = powers;
};
SuperHero.prototype = Object.create( Person.prototype );
var superman = new Superhero( &quot;Clark&quot; ,&quot;Kent&quot; , [&quot;flight&quot;,&quot;heat-vision&quot;] );
console.log( superman );

</code></pre><p><em>进阶</em></p>
<pre><code>// Define a simple Car constructor
var Car = function ( settings ) {
    this.model = settings.model || &quot;no model provided&quot;;
    this.color = settings.color || &quot;no colour provided&quot;;
};
var Mixin = function () {};
Mixin.prototype = {
    driveForward: function () {
        console.log( &quot;drive forward&quot; );
    },
    driveBackward: function () {
        console.log( &quot;drive backward&quot; );
    },
    driveSideways: function () {
        console.log( &quot;drive sideways&quot; );
    }
};
function augment( receivingClass, givingClass ) {
    // only provide certain methods
    if ( arguments[2] ) {
        for ( var i = 2, len = arguments.length; i &lt; len; i++ ) {
            receivingClass.prototype[arguments[i]] = givingClass.prototype[arguments[i]];
        }
    }
    // provide all methods
    else {
        for ( var methodName in givingClass.prototype ) {
            if ( !Object.hasOwnProperty(receivingClass.prototype, methodName) ) {
                receivingClass.prototype[methodName] = givingClass.prototype[methodName];
            }
        }
    }
}
// extend
augment( Car, Mixin, &quot;driveForward&quot;, &quot;driveBackward&quot; );
var myCar = new Car({
    model: &quot;Ford Escort&quot;,
    color: &quot;blue&quot;
});
myCar.driveForward();
myCar.driveBackward();

// extend
augment( Car, Mixin );
var mySportsCar = new Car({
    model: &quot;Porsche&quot;,
    color: &quot;red&quot;
});
mySportsCar.driveSideways();

</code></pre><h4 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h4><ol>
<li>装饰器模式并不去深入依赖于对象是如何创建的，而是专注于扩展它们的功能这一问题上。不同于只依赖于原型继承，我们在一个简单的基础对象上面逐步添加能够提供附加功能的装饰对象。</li>
<li>它的想法是，不同于子类划分，我们向一个基础对象添加（装饰）属性或者方法，因此它会是更加轻巧的。</li>
</ol>
<pre><code>function vehicle(type) {
    this.vehicleType = vehicleType || &quot;car&quot;;
    this.model = &quot;default&quot;;
    this.license = &quot;00000-000&quot;;
}
var veInstance = new vehicle(&#39;car&#39;);

var trunk = new vehicle(&#39;trunk&#39;);
// add
trunk.setModel = function( modelName ){
    this.model = modelName;
};
truck.setColor = function( color ){
    this.color = color;
};
</code></pre><p><em>进阶</em></p>
<pre><code>
// The constructor to decorate
function MacBook() {
    this.cost = function () { return 997; };
    this.screenSize = function () { return 11.6; };
}

// Decorator 1
function Memory( macbook ) {
    var v = macbook.cost();
    macbook.cost = function() {
      return v + 75;
    };
}
// Decorator 2
function Engraving( macbook ){
    var v = macbook.cost();
    macbook.cost = function(){
        return  v + 200;
    };
}
// Decorator 3
function Insurance( macbook ){
    var v = macbook.cost();
    macbook.cost = function(){
        return  v + 250;
    };
} 
var mb = new MacBook();
Memory( mb );
Engraving( mb );
Insurance( mb );

// Outputs: 1522
console.log( mb.cost() );

// Outputs: 11.6
console.log( mb.screenSize() );
</code></pre><ol>
<li>我们的装饰器重载了超类对象MacBook()的 object.cost()函数，使其返回的Macbook的当前价格加上了被定制后升级的价格；</li>
<li>这被看做是对原来的Macbook对象构造器方法的装饰，它并没有将其重写（例如，screenSize())，我们所定义的Macbook的其它属性也保持不变，完好无缺。</li>
</ol>
<pre><code>var decorator = function(dom, fn) {
    if(typeof dom.onclick === &#39;function&#39; ){
        var origin = dom.onclick;
        dom.onclick = function(event) {
            origin.call(dom, event); // 原事件
            fn.call(dom, event); // 装饰
        }
    } else {
        dom.onclick = fn;
    }
}
</code></pre><h4 id="创建者模式"><a href="#创建者模式" class="headerlink" title="创建者模式"></a>创建者模式</h4><ol>
<li>工厂模式可有效的创建可复用的实例对象，关心的是最终创建的对象是什么，不关心创建的过程，因此通过工厂模式得到的都是对象实例或者类簇。</li>
<li>建造者模式相对比工厂模式复杂一些，关心的是创建对象的过程</li>
</ol>
<pre><code>function Person(name, age) {
    this.name = name;
    this.age = age;
}
Person.prototype.getName = function() {
    return this.name
}
Person.prototype.getAge = function() {
    return this.age
}
function Job(job) {
    switch(job) {
      case &#39;teacher&#39;:
        this.job = &#39;教师&#39;
        this.jobDesc = &#39;数学教师&#39;
        break
      case &#39;doctor&#39;:
        this.job = &#39;医生&#39;
        this.jobDesc = &#39;骨科医生&#39;
        break
      case &#39;coder&#39;:
        this.job = &#39;程序员&#39;
        this.jobDesc = &#39;Web前端程序员&#39;
        break
      default:
        this.job = job
        this.jobDesc = &#39;不清楚您的职位的相关描述&#39;
        break
    }
}
Job.prototype.changeJobDesc = function(desc) {
    this.jobDesc = desc
}
Job.prototype.changeJob = function(job) {
    return this.job = job
}
function Hobby(hobby) {
    this.hobby = []
    this.hobby.push(hobby)
}
Hobby.prototype.addHobby = function(hobby) {
    this.hobby.concat(hobby)
}
Hobby.prototype.getHobby = function() {
    return this.hobby.split(&#39;,&#39;)
}
function Skill(skill) {
    this.skill = []
    this.skill.push(skill)
}
function Resume(name, age) {
    this.person = new Person(name, age)
    this.person.job = new Job()
    this.person.hobby = new Hobby()
    this.person.skill = new Skill()
}
let resume = new Resume(&#39;ziyi2&#39;, 28)
console.log(resume)

</code></pre>
      
       
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2019-2021 Jayant
</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class id="rocket"></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0"></script>

<script src="/js/script.js?v=1.1.0"></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
