<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <title>Vue响应式原理 | Jayant Blog</title>
  <meta name="keywords" content=" Vue ">
  <meta name="description" content="Vue响应式原理 | Jayant Blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="许俊彦96年小青年，目前大四，就读于广东药科大学，现在深圳在职，从事前端开发，有团队开发合作经验，积极向上，对于前端领域研究有着十足的兴趣。在成长着，也努力着… 邮箱：jayant_xu@qq.com　期待你的联系 教育经历2015-9　至　2019-6　　　　广东药科大学　　　　信息管理与信息系统 主修课程：Java程序设计、计算机网络、数据结构、UML系统建模、Web程序设计、Linux、数据">
<meta property="og:type" content="website">
<meta property="og:title" content="关于我">
<meta property="og:url" content="http://jayantxu.cn/about/index.html">
<meta property="og:site_name" content="Jayant Blog">
<meta property="og:description" content="许俊彦96年小青年，目前大四，就读于广东药科大学，现在深圳在职，从事前端开发，有团队开发合作经验，积极向上，对于前端领域研究有着十足的兴趣。在成长着，也努力着… 邮箱：jayant_xu@qq.com　期待你的联系 教育经历2015-9　至　2019-6　　　　广东药科大学　　　　信息管理与信息系统 主修课程：Java程序设计、计算机网络、数据结构、UML系统建模、Web程序设计、Linux、数据">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2021-06-13T15:17:55.993Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="关于我">
<meta name="twitter:description" content="许俊彦96年小青年，目前大四，就读于广东药科大学，现在深圳在职，从事前端开发，有团队开发合作经验，积极向上，对于前端领域研究有着十足的兴趣。在成长着，也努力着… 邮箱：jayant_xu@qq.com　期待你的联系 教育经历2015-9　至　2019-6　　　　广东药科大学　　　　信息管理与信息系统 主修课程：Java程序设计、计算机网络、数据结构、UML系统建模、Web程序设计、Linux、数据">


<link rel="icon" href="/img/MyPic.png">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/gruvbox-dark.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0"></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js"></script>

<script src="/js/iconfont.js?v=1.1.0"></script>

</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value>
  <input class="theme_blog_path" value>
  <input id="theme_shortcut" value="true">
  <input id="theme_highlight_on" value="true">
  <input id="theme_code_copy" value="true">
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/MyPic.png">
</a>
<div class="author">
    <span>Jayantxu</span>
</div>

<div class="icon">
    
        
            <a title="github" href="https://github.com/Jayantxu" target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"/>
                    </svg>
                
            </a>
        
    
        
            <a title="email" href="mailto:Jayant_xu@qq.com" target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"/>
                    </svg>
                
            </a>
        
    
        
            <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=591060601&site=qq&menu=yes" target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"/>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <!-- <div class="all active" data-rel="全部文章">全部文章
            
                <small>(68)</small>
            
        </div> -->
    </li>
    
        
            
                <li>
                    <div data-rel="前端">
                        
                        前端
                        <small>(51)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="后端">
                        
                        后端
                        <small>(3)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="工具">
                        
                        工具
                        <small>(9)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="读书V生活">
                        
                        读书V生活
                        <small>(5)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
    </div>
    <div>
        
            <a class="about  site_url" href="/about">关于</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="68">
<input type="hidden" id="yelog_site_word_count" value="72.1k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off">
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search">
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Adv</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Axios</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Bug</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>canvas</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>CSS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Element</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Express</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Git</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Gulp</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>HTML</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>HTTP</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Interview</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>JavaScipt</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>JavaScript</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>MySQL</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Node</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Stylus</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Vue</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Web</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>WebPack</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>书籍摘录</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>布局</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>日常碎碎</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>源码</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>算法</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>踩坑</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>转载</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a id="top" class="全部文章 前端 " href="/2019/01/22/2019/hello-world/" data-tag="日常碎碎" data-author>
            <span class="post-title" title="Hello">Hello</span>
            <span class="post-date" title="2019-01-22 21:45:11">2019/01/22</span>
        </a>
        
        <a id="top" class="全部文章 前端 " href="/2021/06/01/2021/rJUI&vJUI/" data-tag="JavaScript,HTML" data-author>
            <span class="post-title" title="rJUI&amp;vJUI✨✨✨">rJUI&amp;vJUI✨✨✨</span>
            <span class="post-date" title="2021-06-01 22:23:03">2021/06/01</span>
        </a>
        
        <a id="top" class="全部文章 前端 " href="/2021/05/26/2021/批量数据绘制心得/" data-tag="JavaScript,Web" data-author>
            <span class="post-title" title="大量/批量数据优化总结">大量/批量数据优化总结</span>
            <span class="post-date" title="2021-05-26 20:23:03">2021/05/26</span>
        </a>
        
        <a id="top" class="全部文章 前端 " href="/2021/05/07/2021/SKU商品属性组合实践/" data-tag="JavaScript" data-author>
            <span class="post-title" title="SKU商品属性组合实践">SKU商品属性组合实践</span>
            <span class="post-date" title="2021-05-07 16:22:31">2021/05/07</span>
        </a>
        
        <a id="top" class="全部文章 前端 " href="/2020/03/30/2020/轮播/" data-tag="JavaScript,CSS" data-author>
            <span class="post-title" title="模拟生成虚拟3D轮播结构">模拟生成虚拟3D轮播结构</span>
            <span class="post-date" title="2020-03-30 17:30:29">2020/03/30</span>
        </a>
        
        <a id="top" class="全部文章 前端 " href="/2020/02/15/2020/adv/" data-tag="JavaScript,Vue,Adv" data-author>
            <span class="post-title" title="adv">adv</span>
            <span class="post-date" title="2020-02-15 00:00:00">2020/02/15</span>
        </a>
        
        <a id="top" class="全部文章 前端 " href="/2020/01/07/2020/费舍尔-耶茨混洗/" data-tag="JavaScript,算法" data-author>
            <span class="post-title" title="借鉴费舍尔.耶茨混洗优化公司年会抽奖">借鉴费舍尔.耶茨混洗优化公司年会抽奖</span>
            <span class="post-date" title="2020-01-07 00:00:00">2020/01/07</span>
        </a>
        
        <a id="top" class="全部文章 前端 " href="/2019/10/08/2019/canvas进行图像像素点着色/" data-tag="canvas" data-author>
            <span class="post-title" title="基于Canvas进行像素分析，结合数据进行实时着色">基于Canvas进行像素分析，结合数据进行实时着色</span>
            <span class="post-date" title="2019-10-08 18:35:35">2019/10/08</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/04/12/2021/浏览器的多线程/" data-tag="JavaScript,HTTP" data-author>
            <span class="post-title" title="浏览器的多线程">浏览器的多线程</span>
            <span class="post-date" title="2021-04-12 19:10:48">2021/04/12</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/04/07/2021/HTTP1-HTTP1-1-HTTP2-HTTPS-HTTP3的区别特点/" data-tag="HTTP,Web" data-author>
            <span class="post-title" title="HTTP1-HTTP1.1-HTTP2-HTTPS-HTTP3的区别特定">HTTP1-HTTP1.1-HTTP2-HTTPS-HTTP3的区别特定</span>
            <span class="post-date" title="2021-04-07 14:45:27">2021/04/07</span>
        </a>
        
        <a class="全部文章 读书V生活 " href="/2021/04/05/2021/github的3D打印/" data-tag="日常碎碎" data-author>
            <span class="post-title" title="有趣-github的3D打印">有趣-github的3D打印</span>
            <span class="post-date" title="2021-04-05 00:00:00">2021/04/05</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/04/02/2021/十大排序/" data-tag="JavaScript" data-author>
            <span class="post-title" title="十大排序">十大排序</span>
            <span class="post-date" title="2021-04-02 11:10:07">2021/04/02</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/04/01/2021/JS手写Promise/" data-tag="JavaScript,转载" data-author>
            <span class="post-title" title="JS手写Promise">JS手写Promise</span>
            <span class="post-date" title="2021-04-01 20:08:55">2021/04/01</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/02/26/2021/HTTP缓存/" data-tag="HTTP" data-author>
            <span class="post-title" title="HTTP缓存">HTTP缓存</span>
            <span class="post-date" title="2021-02-26 00:00:00">2021/02/26</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/02/21/2021/TCP与UDP的区别/" data-tag="HTTP,Web" data-author>
            <span class="post-title" title="TCP与UDP的区别">TCP与UDP的区别</span>
            <span class="post-date" title="2021-02-21 22:23:03">2021/02/21</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/01/08/2021/JS与stylus与CSSVar的相互作用/" data-tag="JavaScript,CSS,Stylus" data-author>
            <span class="post-title" title="JS与stylus与CSSVar的相互作用">JS与stylus与CSSVar的相互作用</span>
            <span class="post-date" title="2021-01-08 00:00:00">2021/01/08</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/01/01/web/CSS/" data-tag="CSS,Web,Interview" data-author>
            <span class="post-title" title="CSS&amp;HTML">CSS&amp;HTML</span>
            <span class="post-date" title="2021-01-01 00:00:00">2021/01/01</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/01/01/web/HTTP/" data-tag="HTTP,Web,Interview" data-author>
            <span class="post-title" title="HTTP">HTTP</span>
            <span class="post-date" title="2021-01-01 00:00:00">2021/01/01</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/01/01/web/Vue/" data-tag="Vue,Web,Interview" data-author>
            <span class="post-title" title="Vue">Vue</span>
            <span class="post-date" title="2021-01-01 00:00:00">2021/01/01</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/01/01/web/JS/" data-tag="JavaScript,Web,Interview" data-author>
            <span class="post-title" title="JS">JS</span>
            <span class="post-date" title="2021-01-01 00:00:00">2021/01/01</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/01/01/web/interview/" data-tag="Web,Interview" data-author>
            <span class="post-title" title="interview">interview</span>
            <span class="post-date" title="2021-01-01 00:00:00">2021/01/01</span>
        </a>
        
        <a class="全部文章 前端 " href="/2021/01/01/web/webpack/" data-tag="Web,Interview,WebPack" data-author>
            <span class="post-title" title="WebPack">WebPack</span>
            <span class="post-date" title="2021-01-01 00:00:00">2021/01/01</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/12/26/2020/stylus-media/" data-tag="CSS,Stylus" data-author>
            <span class="post-title" title="stylus_media">stylus_media</span>
            <span class="post-date" title="2020-12-26 11:30:02">2020/12/26</span>
        </a>
        
        <a class="全部文章 读书V生活 " href="/2020/12/01/2020/My/" data-tag="日常碎碎" data-author>
            <span class="post-title" title="My">My</span>
            <span class="post-date" title="2020-12-01 20:09:10">2020/12/01</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/11/05/2020/网络七层结构/" data-tag="HTTP" data-author>
            <span class="post-title" title="网络七层结构">网络七层结构</span>
            <span class="post-date" title="2020-11-05 11:20:37">2020/11/05</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/10/28/2020/HTTP常见状态码/" data-tag="HTTP" data-author>
            <span class="post-title" title="HTTP常见状态码">HTTP常见状态码</span>
            <span class="post-date" title="2020-10-28 09:29:34">2020/10/28</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/09/29/2020/JS设计模式/" data-tag="JavaScript" data-author>
            <span class="post-title" title="JS设计模式">JS设计模式</span>
            <span class="post-date" title="2020-09-29 21:56:10">2020/09/29</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/09/28/2020/JS模块化演进/" data-tag="JavaScript" data-author>
            <span class="post-title" title="JS模块化演进">JS模块化演进</span>
            <span class="post-date" title="2020-09-28 09:21:32">2020/09/28</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/09/23/2020/垃圾回收机制/" data-tag="JavaScript" data-author>
            <span class="post-title" title="垃圾回收机制">垃圾回收机制</span>
            <span class="post-date" title="2020-09-23 22:39:54">2020/09/23</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/08/11/2020/XSS-CSRF/" data-tag="JavaScript,HTTP" data-author>
            <span class="post-title" title="XSS-CSRF-Cookie">XSS-CSRF-Cookie</span>
            <span class="post-date" title="2020-08-11 21:57:03">2020/08/11</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/07/09/2020/三次握手四次挥手/" data-tag="HTTP" data-author>
            <span class="post-title" title="三次握手四次挥手">三次握手四次挥手</span>
            <span class="post-date" title="2020-07-09 21:09:28">2020/07/09</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/07/09/2020/HTTPS连接过程/" data-tag="HTTP" data-author>
            <span class="post-title" title="HTTPS连接过程">HTTPS连接过程</span>
            <span class="post-date" title="2020-07-09 00:00:00">2020/07/09</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/06/30/2020/async-await原理/" data-tag="JavaScript" data-author>
            <span class="post-title" title="async/await原理">async/await原理</span>
            <span class="post-date" title="2020-06-30 20:03:07">2020/06/30</span>
        </a>
        
        <a class="全部文章 工具 " href="/2020/06/21/2020/Vue数据双向绑定原理/" data-tag="Vue" data-author>
            <span class="post-title" title="Vue响应式原理">Vue响应式原理</span>
            <span class="post-date" title="2020-06-21 20:02:10">2020/06/21</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/06/12/2020/EventLoop/" data-tag="JavaScript" data-author>
            <span class="post-title" title="EventLoop">EventLoop</span>
            <span class="post-date" title="2020-06-12 12:20:39">2020/06/12</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/05/11/2020/cors跨域/" data-tag="JavaScript,HTTP" data-author>
            <span class="post-title" title="跨域访问">跨域访问</span>
            <span class="post-date" title="2020-05-11 20:38:10">2020/05/11</span>
        </a>
        
        <a class="全部文章 前端 " href="/2020/02/03/2020/重绘回流/" data-tag="JavaScript,CSS,HTML" data-author>
            <span class="post-title" title="重绘回流">重绘回流</span>
            <span class="post-date" title="2020-02-03 00:00:00">2020/02/03</span>
        </a>
        
        <a class="全部文章 工具 " href="/2020/01/27/2020/Vue的Keep-alive/" data-tag="Vue" data-author>
            <span class="post-title" title="Vue的Keep-alive组件">Vue的Keep-alive组件</span>
            <span class="post-date" title="2020-01-27 20:17:56">2020/01/27</span>
        </a>
        
        <a class="全部文章 工具 " href="/2020/01/23/2020/Vue的nextTick剖析/" data-tag="Vue" data-author>
            <span class="post-title" title="Vue的nextTick剖析">Vue的nextTick剖析</span>
            <span class="post-date" title="2020-01-23 16:42:30">2020/01/23</span>
        </a>
        
        <a class="全部文章 工具 " href="/2020/01/17/2020/Vue-Diff/" data-tag="Vue,转载" data-author>
            <span class="post-title" title="Vue虚拟节点VNodeDiff算法">Vue虚拟节点VNodeDiff算法</span>
            <span class="post-date" title="2020-01-17 20:17:56">2020/01/17</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/12/15/2019/JS原型链/" data-tag="JavaScipt" data-author>
            <span class="post-title" title="JS原型链">JS原型链</span>
            <span class="post-date" title="2019-12-15 22:48:23">2019/12/15</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/11/01/2019/踩坑eCharts参数/" data-tag="踩坑" data-author>
            <span class="post-title" title="踩坑eCharts参数">踩坑eCharts参数</span>
            <span class="post-date" title="2019-11-01 18:51:02">2019/11/01</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/10/17/2019/this指向/" data-tag="JavaScript" data-author>
            <span class="post-title" title="this指向">this指向</span>
            <span class="post-date" title="2019-10-17 22:33:39">2019/10/17</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/09/26/2019/一个失焦指令的学习/" data-tag="Vue,Element" data-author>
            <span class="post-title" title="一个失焦指令的学习">一个失焦指令的学习</span>
            <span class="post-date" title="2019-09-26 17:41:35">2019/09/26</span>
        </a>
        
        <a class="全部文章 读书V生活 " href="/2019/06/27/2019/毕业了/" data-tag="日常碎碎" data-author>
            <span class="post-title" title="毕业了">毕业了</span>
            <span class="post-date" title="2019-06-27 19:48:20">2019/06/27</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/05/13/2019/Flex布局的基本属性介绍/" data-tag="CSS,布局" data-author>
            <span class="post-title" title="Flex布局的基本属性介绍">Flex布局的基本属性介绍</span>
            <span class="post-date" title="2019-05-13 13:22:26">2019/05/13</span>
        </a>
        
        <a class="全部文章 工具 " href="/2019/04/09/2019/Gulp源码分析学习-三/" data-tag="Gulp,源码" data-author>
            <span class="post-title" title="Gulp源码分析学习(三">Gulp源码分析学习(三</span>
            <span class="post-date" title="2019-04-09 08:51:45">2019/04/09</span>
        </a>
        
        <a class="全部文章 工具 " href="/2019/04/06/2019/Gulp源码分析学习-二/" data-tag="Gulp,源码" data-author>
            <span class="post-title" title="Gulp源码分析学习(二">Gulp源码分析学习(二</span>
            <span class="post-date" title="2019-04-06 13:47:27">2019/04/06</span>
        </a>
        
        <a class="全部文章 工具 " href="/2019/04/05/2019/Gulp源码分析学习-一/" data-tag="Gulp,源码" data-author>
            <span class="post-title" title="Gulp源码分析学习(一">Gulp源码分析学习(一</span>
            <span class="post-date" title="2019-04-05 16:41:26">2019/04/05</span>
        </a>
        
        <a class="全部文章 后端 " href="/2019/03/30/2019/Node读取图片并转Base64/" data-tag="Node" data-author>
            <span class="post-title" title="Node读取图片并转Base64">Node读取图片并转Base64</span>
            <span class="post-date" title="2019-03-30 00:12:42">2019/03/30</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/03/26/2019/Grid布局/" data-tag="CSS,布局,转载" data-author>
            <span class="post-title" title="Grid布局">Grid布局</span>
            <span class="post-date" title="2019-03-26 10:50:48">2019/03/26</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/03/03/2019/阻止冒泡、默认事件/" data-tag="JavaScript,HTML" data-author>
            <span class="post-title" title="阻止冒泡、默认事件">阻止冒泡、默认事件</span>
            <span class="post-date" title="2019-03-03 20:30:42">2019/03/03</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/03/03/2019/CSS清除浮动/" data-tag="CSS" data-author>
            <span class="post-title" title="CSS清除浮动的几种方式">CSS清除浮动的几种方式</span>
            <span class="post-date" title="2019-03-03 19:29:44">2019/03/03</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/03/01/2019/margin重叠以及解决办法/" data-tag="JavaScript,CSS,HTML" data-author>
            <span class="post-title" title="margin重叠以及解决办法">margin重叠以及解决办法</span>
            <span class="post-date" title="2019-03-01 23:15:21">2019/03/01</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/03/01/2019/CSS省略号实现/" data-tag="CSS,HTML" data-author>
            <span class="post-title" title="CSS省略号实现">CSS省略号实现</span>
            <span class="post-date" title="2019-03-01 16:09:35">2019/03/01</span>
        </a>
        
        <a class="全部文章 工具 " href="/2019/02/21/2019/Gulp增量编译优化/" data-tag="JavaScript,Gulp" data-author>
            <span class="post-title" title="Gulp增量编译优化">Gulp增量编译优化</span>
            <span class="post-date" title="2019-02-21 20:14:45">2019/02/21</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/02/18/2019/JavaScript深浅拷贝/" data-tag="JavaScript" data-author>
            <span class="post-title" title="JavaScript深浅拷贝">JavaScript深浅拷贝</span>
            <span class="post-date" title="2019-02-18 20:06:36">2019/02/18</span>
        </a>
        
        <a class="全部文章 后端 " href="/2019/02/10/2019/Node-express文件上传下载/" data-tag="HTML,Node,Express,Element" data-author>
            <span class="post-title" title="Node+Express+Element实现文件上传下载">Node+Express+Element实现文件上传下载</span>
            <span class="post-date" title="2019-02-10 20:59:42">2019/02/10</span>
        </a>
        
        <a class="全部文章 读书V生活 " href="/2019/02/08/2019/新年快乐/" data-tag="日常碎碎" data-author>
            <span class="post-title" title="新年快乐">新年快乐</span>
            <span class="post-date" title="2019-02-08 22:41:02">2019/02/08</span>
        </a>
        
        <a class="全部文章 后端 " href="/2019/02/02/2019/Node-MySQL释放数据库连接的Bug/" data-tag="Node,Express,MySQL,Bug" data-author>
            <span class="post-title" title="Node+MySQL释放数据库连接的Bug">Node+MySQL释放数据库连接的Bug</span>
            <span class="post-date" title="2019-02-02 19:42:07">2019/02/02</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/02/02/2019/transform对fixed/" data-tag="CSS,Bug" data-author>
            <span class="post-title" title="transform父元素对fixed子元素的影响">transform父元素对fixed子元素的影响</span>
            <span class="post-date" title="2019-02-02 10:16:34">2019/02/02</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/02/02/2019/Vue父子通信/" data-tag="JavaScript,Vue" data-author>
            <span class="post-title" title="Vue父子组件间的通信">Vue父子组件间的通信</span>
            <span class="post-date" title="2019-02-02 09:45:31">2019/02/02</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/01/31/2019/Axios使用/" data-tag="JavaScript,Axios,Vue" data-author>
            <span class="post-title" title="Axios使用">Axios使用</span>
            <span class="post-date" title="2019-01-31 15:14:03">2019/01/31</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/01/24/2019/手写new-call-apply-bind/" data-tag="JavaScript" data-author>
            <span class="post-title" title="手写new、call、apply、bind">手写new、call、apply、bind</span>
            <span class="post-date" title="2019-01-24 19:21:39">2019/01/24</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/01/23/2019/JavaScript继承/" data-tag="JavaScript" data-author>
            <span class="post-title" title="JavaScript继承">JavaScript继承</span>
            <span class="post-date" title="2019-01-23 15:29:41">2019/01/23</span>
        </a>
        
        <a class="全部文章 前端 " href="/2019/01/23/2019/JavaScript创建对象/" data-tag="JavaScript" data-author>
            <span class="post-title" title="JavaScript创建对象">JavaScript创建对象</span>
            <span class="post-date" title="2019-01-23 14:10:25">2019/01/23</span>
        </a>
        
        <a class="全部文章 工具 " href="/2019/01/23/2019/Git相关命令/" data-tag="Git" data-author>
            <span class="post-title" title="Git相关命令">Git相关命令</span>
            <span class="post-date" title="2019-01-23 09:45:11">2019/01/23</span>
        </a>
        
        <a class="全部文章 读书V生活 " href="/2019/01/23/2019/阅读摘录/" data-tag="书籍摘录" data-author>
            <span class="post-title" title="阅读摘录">阅读摘录</span>
            <span class="post-date" title="2019-01-23 08:56:01">2019/01/23</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-2020/Vue数据双向绑定原理" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Vue响应式原理</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a data-rel="工具">工具</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color4">Vue</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title="最后更新: 2021-06-13 23:17:55">2020-06-21 20:02</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:4.2k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue2"><span class="toc-text">Vue2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对象变响应式"><span class="toc-text">对象变响应式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#index入口"><span class="toc-text">index入口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#initJS"><span class="toc-text">initJS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stateJS"><span class="toc-text">stateJS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#initPorps"><span class="toc-text">initPorps</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#initData"><span class="toc-text">initData</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#proxy"><span class="toc-text">proxy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#observe"><span class="toc-text">observe</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Observer"><span class="toc-text">Observer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#defineReactive"><span class="toc-text">defineReactive</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get收集依赖"><span class="toc-text">get收集依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dep"><span class="toc-text">Dep</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Watcher"><span class="toc-text">Watcher</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#派发更新"><span class="toc-text">派发更新</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dep-notify"><span class="toc-text">dep.notify</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#watcher-update"><span class="toc-text">watcher.update</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queueWatcher"><span class="toc-text">queueWatcher</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-6 i,
    .toc-level-6 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Vue2"><a href="#Vue2" class="headerlink" title="Vue2"></a>Vue2</h2><p>之前看过几回<code>Vue</code>的响应式原理剖析，但是几乎总是不久就忘记了，仅仅是依稀记得<code>defineProperty</code>做<code>get</code>和<code>set</code>的数据劫持，然后在此基础上做一些发布，说到底还是可能不够深入，不够理解，特此希望借此总结一下，将一些点做下记录，顺便对源码做一些回顾。<br>我们从三个部分来介绍<code>Vue</code>的响应式原理的实现：</p>
<ul>
<li>对象变响应式</li>
<li>get收集依赖</li>
<li>set发布更新</li>
</ul>
<h3 id="对象变响应式"><a href="#对象变响应式" class="headerlink" title="对象变响应式"></a>对象变响应式</h3><p>我们都知道<code>Vue</code>中是通过<code>defineProperty</code>进行数据劫持，但是他具体是如何进行到劫持这一步的呢？<br>我们一起从<code>Vue</code>的源码中开始了解一下吧！</p>
<h4 id="index入口"><a href="#index入口" class="headerlink" title="index入口"></a>index入口</h4><ul>
<li><code>src\core\instance\index.js</code></li>
</ul>
<p>Vue的源码入口，其中通过<code>Function</code>实现的<code>Vue</code>这个类，并且还执行了一些方法，</p>
<pre><code>initMixin(Vue) 
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)
</code></pre><p>从字面意思上来看，我们很容易理解，<code>Mixin</code>，什么event，lifecycleMixin，大概应该都是对Vue这个进行的扩展。这个以后有机会的话一起详细看看，本单元我们的主角，就是<code>initMixin(Vue)</code>，我们看看它实现了什么呢。</p>
<h4 id="initJS"><a href="#initJS" class="headerlink" title="initJS"></a>initJS</h4><ul>
<li><code>src\core\instance\init.js</code></li>
</ul>
<p>我们看看<code>init</code>方法倒是实现了什么，我会去除掉部分代码，我们本单元关键是寻找如何变成响应式对象的。</p>
<pre><code>export function initMixin (Vue: Class&lt;Component&gt;) {
  Vue.prototype._init = function (options?: Object) {
    const vm: Component = this
    vm._uid = uid++
    // ...

    initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    // ...
    callHook(vm, &#39;beforeCreate&#39;)
    initInjections(vm)
    initState(vm)
    initProvide(vm)
    callHook(vm, &#39;created&#39;)

    // ...
    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
}
</code></pre><p>将<code>vm</code>变量赋值为<code>this</code>，这就是我们常见的<code>vm.xxx</code>写法，其中这就是<code>vm = this</code>的由来，这其中是对<code>生命周期</code>，<code>事件</code>的一些初始化，以及调用了两个生命<code>钩子</code>函数。而最主要的对<code>data</code>和<code>prop</code>的处理，则是在<code>initState</code>中。</p>
<h4 id="stateJS"><a href="#stateJS" class="headerlink" title="stateJS"></a>stateJS</h4><ul>
<li><code>src\core\instance\state.js</code></li>
</ul>
<pre><code>export function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props)
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    initData(vm) // 初始化数据
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch &amp;&amp; opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch) // 初始化 Watch
  }
}
</code></pre><p><code>initState</code>主要对<code>prop</code>，<code>methods</code>，<code>data</code>，<code>computed</code>，<code>watch</code>都分别做一些处理，其中<code>prop</code>和<code>data</code>是我们要下一步查看的。</p>
<h4 id="initPorps"><a href="#initPorps" class="headerlink" title="initPorps"></a>initPorps</h4><ol>
<li><code>initPorps</code></li>
</ol>
<pre><code>function initProps (vm: Component, propsOptions: Object) {
  const propsData = vm.$options.propsData || {}
  const props = vm._props = {}
  const keys = vm.$options._propKeys = []
  const isRoot = !vm.$parent
  for (const key in propsOptions) {
    keys.push(key)
    const value = validateProp(key, propsOptions, propsData, vm)
    if (process.env.NODE_ENV !== &#39;production&#39;) {
      // ...
    } else {
      defineReactive(props, key, value)
    }
    // ...
    if (!(key in vm)) {
      proxy(vm, `_props`, key)
    }
  }
  toggleObserving(true)
}
</code></pre><p>先从定义的props中遍历，调用了<code>validateProp</code>校验<code>props</code>是否符合规范。然后遍历<code>propsOptions</code>调用<code>defineReactive</code>方法把每个<code>prop</code>变成响应式，然后执行<code>proxy</code>方法，这个方法又是干什么的呢？</p>
<p>在这里我们先记住留下两个点需要解决，需要去跟踪：</p>
<ol>
<li><code>defineReactive</code>方法；</li>
<li><code>proxy</code>方法；</li>
</ol>
<p>我们需要再回头看看刚刚的<code>initData(vm)</code>。</p>
<h4 id="initData"><a href="#initData" class="headerlink" title="initData"></a>initData</h4><pre><code>function initData (vm: Component) {
  let data = vm.$options.data

  data = vm._data = typeof data === &#39;function&#39;
    ? getData(data, vm)
    : data || {}

  // ...
  const keys = Object.keys(data)

  const props = vm.$options.props

  const methods = vm.$options.methods
  let i = keys.length

  while (i--) {
    const key = keys[i]
    if (process.env.NODE_ENV !== &#39;production&#39;) {
      if (methods &amp;&amp; hasOwn(methods, key)) {
        warn(
          `Method &quot;${key}&quot; has already been defined as a data property.`,
          vm
        )
      }
    }
    if (props &amp;&amp; hasOwn(props, key)) {
      process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(
        `The data property &quot;${key}&quot; is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
      )
    } else if (!isReserved(key)) {
      proxy(vm, `_data`, key)
    }
  }
  observe(data, true /* asRootData */)
}
</code></pre><p><code>initData</code>这一段代码做了啥呢？先判断了一下<code>data</code>是不是一个方法，是的话使用<code>getData</code>拿到手。然后取出<code>data</code>中的数据，与<code>methods</code>，<code>props</code>中的数据做判断，判断是否存在键值重复！所有这里这一步就是我们再Vue组件中定义了键值重复时抛出警告的地方。</p>
<p>我们继续，诶，很眼熟，又是<code>proxy方法</code>，然后往下执行，是一个<code>observe</code>新方法，它们又是做什么的呢？</p>
<p>我们在记录一下，然后可以往下跟踪，我们现在有三个未接之谜了：</p>
<ol>
<li><code>defineReactive</code>方法；</li>
<li><code>proxy</code>方法；</li>
<li><code>observe</code>方法。</li>
</ol>
<h4 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h4><ul>
<li><code>src\core\instance\state.js</code></li>
</ul>
<p>还记得怎么使用<code>proxy</code>的吗？</p>
<pre><code>proxy(vm, `_props`, key)
</code></pre><pre><code>const sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
}
export function proxy (target: Object, sourceKey: string, key: string) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  }
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}
</code></pre><p>简单几句，传入得三个参数分别为<code>vm(this)</code>，<code>sourceKey</code>，<code>key</code>，这一步操作，其实还是利用了<code>get</code>，<code>set</code>将<code>props</code>上的参数代理到<code>vm(this)</code>上。仅此而已，也是因为这样，我们在<code>Vue</code>中才可以使用<code>this.xxx</code>去访问<code>props</code>上的传入的参数。好了，我们消灭了一个疑问<code>proxy</code>。</p>
<h4 id="observe"><a href="#observe" class="headerlink" title="observe"></a>observe</h4><ul>
<li>src\core\observer\index.js</li>
</ul>
<pre><code>export function observe (value: any, asRootData: ?boolean): Observer | void {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  let ob: Observer | void
  if (hasOwn(value, &#39;__ob__&#39;) &amp;&amp; value.__ob__ instanceof Observer) {
    ob = value.__ob__
  } else if (
    shouldObserve &amp;&amp;
    !isServerRendering() &amp;&amp;
    (Array.isArray(value) || isPlainObject(value)) &amp;&amp;
    Object.isExtensible(value) &amp;&amp;
    !value._isVue
  ) {
    ob = new Observer(value)
  }
  if (asRootData &amp;&amp; ob) {
    ob.vmCount++
  }
  return ob
}
</code></pre><p><code>observe</code>方法，首先先判断了一下传入的对象是不是<code>vnode</code>，对于非<code>VNODE</code>的对象类型才添加一个<code>Observer</code>，new出来的实例，那这个<code>Observer</code>又是啥，现在又有两个问题需要解决了。</p>
<ol>
<li><code>Observer</code>方法；</li>
<li><code>defineReactive</code>方法；</li>
</ol>
<h4 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h4><ul>
<li>src\core\observer\index.js</li>
</ul>
<pre><code>export class Observer {
  // ...
  constructor (value: any) {
    this.value = value
    this.dep = new Dep()
    this.vmCount = 0
    def(value, &#39;__ob__&#39;, this)

    if (Array.isArray(value)) {
      // ...
      this.observeArray(value) // 依然会遍历数组，然后observe
    } else {
      // ...
      this.walk(value)
    }
  }
  walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i &lt; keys.length; i++) {
      defineReactive(obj, keys[i])
    }
  }

  observeArray (items: Array&lt;any&gt;) {
    for (let i = 0, l = items.length; i &lt; l; i++) {
      observe(items[i])
    }
  }
}
</code></pre><p><code>Observer</code>是一个类，其中似乎创建了一个什么实例<code>new Dep</code>，这个我们先留下观察，继续向下，然后调用了<code>def</code>这么一个方法，这个方法是做什么呢？</p>
<ul>
<li><code>src\core\util\lang.js</code></li>
</ul>
<pre><code>export function def (obj: Object, key: string, val: any, enumerable?: boolean) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  })
}
</code></pre><pre><code>def(value, &#39;__ob__&#39;, this)
</code></pre><p>其实<code>def</code>封装了defineProperty，调用此方法可以在传入的<code>obj</code>上绑定一个<code>value</code>的<code>key</code>，在这一块，就是在我们data上绑定一个<strong>ob</strong>的属性。</p>
<p>然后继续向下走，使用<code>isArray</code>判断value是不是数组，如果是数组，则调用了<code>observeArray</code>，否则则调用<code>walk</code>方法。</p>
<ul>
<li><code>observeArray</code></li>
</ul>
<pre><code>observeArray (items: Array&lt;any&gt;) {
    for (let i = 0, l = items.length; i &lt; l; i++) {
      observe(items[i])
    }
}
</code></pre><p>这就是遍历调用observe方法。</p>
<ul>
<li><code>walk</code><pre><code>walk (obj: Object) {
  const keys = Object.keys(obj)
  for (let i = 0; i &lt; keys.length; i++) {
    defineReactive(obj, keys[i])
  }
}
</code></pre><code>walk</code>是在对象的情况下，遍历对象，对每一个key-value调用<code>defineReactive</code>方法，好家伙，兜兜转转又回来了。</li>
</ul>
<p>剩余跟踪问题：</p>
<ol>
<li><code>defineReactive</code>方法；</li>
</ol>
<h4 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive"></a>defineReactive</h4><ul>
<li><code>src\core\observer\index.js</code></li>
</ul>
<pre><code>export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean // 如果 shallow  为 true
) {
  // 对每一个属性对new一个Dep依赖
  const dep = new Dep()
  // ...
  const getter = property &amp;&amp; property.get
  const setter = property &amp;&amp; property.set

  if ((!getter || setter) &amp;&amp; arguments.length === 2) {
    val = obj[key]
  }
  // ...
  let childOb = !shallow &amp;&amp; observe(val)

  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      // ...
    },
    set: function reactiveSetter (newVal) {
      // ...
    }
  })
}
</code></pre><p>是不是有点熟悉，这不就是我们经常背的<code>Vue</code>响应式原理吗？通过<code>defineProperty</code>进行数据劫持啥啥啥的，最终我们还是走到了这里。<br>是的，在<code>defineProperty</code>中，通过<code>defineProperty</code>进行对对象的属性添加<code>getter</code>和<code>setter</code>进行数据劫持。<br>而这里面就深藏了我们的后续动作：<strong>收集依赖</strong>，<strong>发布更新</strong>。</p>
<h3 id="get收集依赖"><a href="#get收集依赖" class="headerlink" title="get收集依赖"></a>get收集依赖</h3><p>我们继续看看<code>defineProperty</code>中的<code>get</code>怎么做的依赖收集？</p>
<pre><code>export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean // 如果 shallow  为 true
) {
  // 对每一个属性对new一个Dep依赖
  const dep = new Dep()

  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property &amp;&amp; property.configurable === false) {
    return
  }

  // 拿到其原本的getter与setter方法
  const getter = property &amp;&amp; property.get
  const setter = property &amp;&amp; property.set

  if ((!getter || setter) &amp;&amp; arguments.length === 2) {
    val = obj[key]
  }
  // 迭代其子属性
  let childOb = !shallow &amp;&amp; observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        dep.depend()
        if (childOb) {
          childOb.dep.depend() 
          if (Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      // ...
    }
  })
}
</code></pre><p>这里面分别有这么三步，是重要的：</p>
<ol>
<li>const dep = new Dep()；</li>
<li>dep.depend()；</li>
<li>childOb的处理。<pre><code>if (childOb) {
 childOb.dep.depend() 
 if (Array.isArray(value)) {
   dependArray(value)
 }
}
</code></pre></li>
</ol>
<p>在了解这些之前，我们应该需要看看<code>new Dep</code>，究竟创建了个啥？</p>
<h4 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h4><ul>
<li><code>src\core\observer\dep.js</code></li>
</ul>
<pre><code>export default class Dep {
  static target: ?Watcher;
  id: number;
  subs: Array&lt;Watcher&gt;;

  constructor () {
    this.id = uid++
    this.subs = []
  }
  addSub (sub: Watcher) {
    this.subs.push(sub)
  }
  removeSub (sub: Watcher) {
    remove(this.subs, sub)
  }
  depend () {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }
  notify () {
    const subs = this.subs.slice()
    if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; !config.async) {
      subs.sort((a, b) =&gt; a.id - b.id)
    }
    // 循环更新
    for (let i = 0, l = subs.length; i &lt; l; i++) {
      subs[i].update()
    }
  }
}
</code></pre><p>嗯，很眼熟有没有，这就是一个<code>addSub</code>，<code>removeSub</code>，这就是一个发布订阅呀有没有，好吧，我们继续来看。<br>这个<code>this.subs</code>是一个<code>Watcher</code>的数组，那它发布订阅管理的是<code>Watcher</code>吗？</p>
<p>那这个<code>Watcher</code>又是啥？</p>
<h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h4><ul>
<li><code>src\core\observer\watcher.js</code></li>
</ul>
<pre><code>export default class Watcher {
  // ...
  constructor (
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: ?Object,
    isRenderWatcher?: boolean
  ) {
    this.vm = vm
    if (isRenderWatcher) {
      vm._watcher = this
    }
    vm._watchers.push(this)
    // options
    if (options) {
      this.deep = !!options.deep
      this.user = !!options.user
      this.lazy = !!options.lazy
      this.sync = !!options.sync
      this.before = options.before
    } else {
      this.deep = this.user = this.lazy = this.sync = false
    }
    this.cb = cb
    this.id = ++uid // uid for batching
    this.active = true
    this.dirty = this.lazy // for lazy watchers
    this.deps = []
    this.newDeps = []
    this.depIds = new Set()
    this.newDepIds = new Set()
    this.expression = process.env.NODE_ENV !== &#39;production&#39;
      ? expOrFn.toString()
      : &#39;&#39;
    // parse expression for getter
    if (typeof expOrFn === &#39;function&#39;) {
      this.getter = expOrFn
    } else {
      this.getter = parsePath(expOrFn)
      if (!this.getter) {
        this.getter = noop
        process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(
          `Failed watching path: &quot;${expOrFn}&quot; ` +
          &#39;Watcher only accepts simple dot-delimited paths. &#39; +
          &#39;For full control, use a function instead.&#39;,
          vm
        )
      }
    }
    this.value = this.lazy
      ? undefined
      : this.get()
  }

  /**
   * Evaluate the getter, and re-collect dependencies.
   */
  get () {
    pushTarget(this)，
    let value
    const vm = this.vm
    try {
      value = this.getter.call(vm, vm)
    } catch (e) {
      if (this.user) {
        handleError(e, vm, `getter for watcher &quot;${this.expression}&quot;`)
      } else {
        throw e
      }
    } finally {
      if (this.deep) {
        traverse(value)
      }
      popTarget()
      this.cleanupDeps()
    }
    return value
  }
  addDep (dep: Dep) {
    const id = dep.id
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id)
      this.newDeps.push(dep)
      if (!this.depIds.has(id)) {
        dep.addSub(this) //  addSub 为 sub 队列，添加一个Watcher 实例化对象
      }
    }
  }
  // 清理观察者依赖项集合
  cleanupDeps () {
    let i = this.deps.length
    while (i--) {
      const dep = this.deps[i]
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this)
      }
    }
    let tmp = this.depIds
    this.depIds = this.newDepIds
    this.newDepIds = tmp
    this.newDepIds.clear()
    tmp = this.deps
    this.deps = this.newDeps
    this.newDeps = tmp
    this.newDeps.length = 0
  }
  update () {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true
    } else if (this.sync) { 
      this.run()
    } else {
      queueWatcher(this)
    }
  }
  run () {
    if (this.active) {
      const value = this.get()
      if (
        value !== this.value ||
        isObject(value) ||
        this.deep
      ) {
        const oldValue = this.value
        this.value = value
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue)
          } catch (e) {
            handleError(e, this.vm, `callback for watcher &quot;${this.expression}&quot;`)
          }
        } else {
          this.cb.call(this.vm, value, oldValue)
        }
      }
    }
  }
  evaluate () {
    this.value = this.get()
    this.dirty = false
  }
  depend () {
    let i = this.deps.length
    while (i--) {
      this.deps[i].depend()
    }
  }
  teardown () {
    if (this.active) {
      // remove self from vm&#39;s watcher list
      // this is a somewhat expensive operation so we skip it
      // if the vm is being destroyed.
      if (!this.vm._isBeingDestroyed) {
        remove(this.vm._watchers, this)
      }
      let i = this.deps.length
      while (i--) {
        this.deps[i].removeSub(this)
      }
      this.active = false
    }
  }
}
</code></pre><pre><code>Dep.target = null
const targetStack = []

export function pushTarget (target: ?Watcher) {
  targetStack.push(target)
  Dep.target = target
}

export function popTarget () {
  targetStack.pop()
  Dep.ta
</code></pre><p><code>Watcher</code>也是一个类，其中定义了</p>
<ol>
<li><code>this.deps</code>，<code>this.newDeps</code>两数组，看名字，像是与Dep实例有关的数组；</li>
<li><code>this.depIds</code>，<code>this.newDepIds</code>两个<code>set</code>结构；</li>
<li><code>get()</code>方法；</li>
<li><code>addDep()</code>方法；</li>
<li><code>cleanupDeps</code>方法；</li>
<li><code>update</code>方法；</li>
<li><code>run</code>、<code>evaluate</code>、<code>depend</code>、<code>teardown</code>等方法。</li>
</ol>
<p>在初始化<code>Watcher</code>的时候会触发进入<code>get</code>方法，<code>get</code>方法中调用<code>pushTarget</code>，这个<code>pushTarget</code>是调用了<code>dep</code>中<code>pushTargt</code>方法，将<code>this</code>push进<code>taegetStack</code>的堆栈中，并且：</p>
<pre><code>Dep.target = target
</code></pre><pre><code>static target: ?Watcher;
</code></pre><p>将静态属性<code>target</code>设置为当前this(Watcher)，此处的<code>target</code>设置留下疑问①。</p>
<p>接下来我们继续，</p>
<pre><code>try {
  value = this.getter.call(vm, vm)
} catch (e) {
  // ...
}
</code></pre><p>此处的<code>this.getter</code>，就是在<code>constructor</code>中设置的<code>expOrFn</code>。</p>
<pre><code>// r: 88
if (typeof expOrFn === &#39;function&#39;) {
  this.getter = expOrFn
} 
</code></pre><p>那么这个<code>expOrFn</code>是传入了什么？我们可以在全局搜索一下在何处new了Watcher。<br><img src="/2020/06/21/2020/Vue数据双向绑定原理/NO1.png" alt="NO1" title="NO1"></p>
<p>在这个<code>mountComponent</code>中调用的，并且传入了</p>
<pre><code>updateComponent = () =&gt; {
  vm._update(vm._render(), hydrating)// 调用 Vue.prototype._update
}
</code></pre><p>因此，我们可以得出在这里<code>expOfFn = updateComponent</code>的结论，并且我们可以依然搜索，在<code>src\platforms\web\runtime\index.js</code>中，mount方法正是借用了<code>updateComponent</code>。</p>
<p>好了，我们回来，刚刚提到<code>this.getter.call()</code>，按照现在的寻找，正是执行了<code>vm._update(vm._render(), hydrating)</code>，在执行渲染时自然会触发<code>VNODE</code>对于<code>vm</code>上数据的访问，就会触发数据对象上设置的<code>getter</code>。</p>
<p>触发了get之后呢？<br>我们重新回到<code>defineRecative</code>，看看get中还做了啥。</p>
<pre><code>const value = getter ? getter.call(obj) : val
// 在get中手机属性依赖
if (Dep.target) {
  dep.depend()// 此里面做依赖收集，这个Dep有什么作用? --- src/core/observer/dep.js
  if (childOb) {
    childOb.dep.depend() 
    if (Array.isArray(value)) {
      dependArray(value)
    }
  }
}
</code></pre><p>因为刚刚<code>Dep.target</code>已经修改为Watcher了，就会执行<code>dep.depend</code>方法</p>
<pre><code>depend () {
  if (Dep.target) {
    Dep.target.addDep(this)
  }
}
</code></pre><p>而这个还是转头执行<code>addDep</code>，watcher中的addDep</p>
<pre><code>addDep (dep: Dep) {
  const id = dep.id
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id)
    this.newDeps.push(dep)
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
}
</code></pre><p>这里面做了一些判断，看样子是对一下判断是否有重复的情况…然后执行<code>addSub</code>，将<code>watcher</code>添加订阅到subs中。</p>
<pre><code>addSub (sub: Watcher) {
  this.subs.push(sub)
}
</code></pre><p>这样，在后续的<code>subs</code>pop执行更新派发时就可以通知到了。</p>
<h3 id="派发更新"><a href="#派发更新" class="headerlink" title="派发更新"></a>派发更新</h3><p>派发更新这一步，我们需要看回原来的<code>defineReactive</code>，看看里面的set做了什么。</p>
<pre><code>export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean // 如果 shallow  为 true
) {
  // ...
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      // ...
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) {
        return
      }

      if (getter &amp;&amp; !setter) return
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = !shallow &amp;&amp; observe(newVal)

      dep.notify()
    }
  })
}
</code></pre><p><code>set</code>内先对新值旧值做了一些比较，以及设置，然后就来到了这两行：</p>
<pre><code>childOb = !shallow &amp;&amp; observe(newVal)

dep.notify()
</code></pre><p>看起来比较高深，<code>dep.notify</code>故名思意，就是通知，那么应该就是这一步，对所有订阅者进行了通知。</p>
<p><code>!shallow &amp;&amp; observe(newVal)</code>当<code>shallow</code>是<code>false</code>的情况下，会再调用<code>observe</code>将newVal设置为响应式对象(observe在我们之前的内容中有讲到)。</p>
<h4 id="dep-notify"><a href="#dep-notify" class="headerlink" title="dep.notify"></a>dep.notify</h4><p><code>dep.notify</code>在类<code>Dep</code>中，<code>src\core\observer\dep.js</code>，r: 44，</p>
<pre><code>notify () {
  const subs = this.subs.slice()
  if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; !config.async) {
    subs.sort((a, b) =&gt; a.id - b.id)
  }
  // 循环更新
  for (let i = 0, l = subs.length; i &lt; l; i++) {
    subs[i].update()
  }
}
</code></pre><p>其中先对<code>subs</code>排了个序，当做先来后到，正确触发。然后在遍历，依次执行<code>update</code>方法，因为我们指定<code>subs</code>是<code>watcher</code>的数组，所有执行的也是<code>watcher</code>的<code>update</code>方法。</p>
<h4 id="watcher-update"><a href="#watcher-update" class="headerlink" title="watcher.update"></a>watcher.update</h4><pre><code>update () {
  if (this.lazy) {
    this.dirty = true
  } else if (this.sync) {
    this.run()
  } else {
    queueWatcher(this)
  }
}
</code></pre><p>其实这个<code>lazy</code>会对应的<code>computed</code>中的响应，我们后续有机会可以了解。<code>sync</code>是同步的情况下则直接改变。</p>
<p>我们来到了<code>queueWatcher</code>，看看这个里面做了什么？</p>
<h4 id="queueWatcher"><a href="#queueWatcher" class="headerlink" title="queueWatcher"></a>queueWatcher</h4><ul>
<li><code>src\core\observer\scheduler.js</code></li>
</ul>
<pre><code>export function queueWatcher (watcher: Watcher) {
  const id = watcher.id
  if (has[id] == null) {
    has[id] = true
    if (!flushing) {
      queue.push(watcher)
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      let i = queue.length - 1
      while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) {
        i--
      }
      queue.splice(i + 1, 0, watcher)
    }
    // queue the flush
    if (!waiting) {
      waiting = true

      if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; !config.async) {
        flushSchedulerQueue()
        return
      }
      nextTick(flushSchedulerQueue)
    }
  }
}
</code></pre><p>先是使用了<code>has</code>对象判断了<code>watcher</code>不能重复，那这个<code>flush</code>又是做啥的？暂时看不出来，我们先留下疑问。<br>接下去调用<code>nextTick</code>执行<code>flushSchedulerQueue</code>方法，这样子统一放进一个队列中进行，而不是每次更改都触发。</p>
<pre><code>function flushSchedulerQueue () {
  currentFlushTimestamp = getNow()
  flushing = true
  let watcher, id

  queue.sort((a, b) =&gt; a.id - b.id) // 根据id排序

  for (index = 0; index &lt; queue.length; index++) {
    watcher = queue[index]
    if (watcher.before) {
      watcher.before()
    }
    id = watcher.id
    has[id] = null

    watcher.run()

    if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; has[id] != null) {
      circular[id] = (circular[id] || 0) + 1
      if (circular[id] &gt; MAX_UPDATE_COUNT) {
        warn(
          &#39;You may have an infinite update loop &#39; + (
            watcher.user
              ? `in watcher with expression &quot;${watcher.expression}&quot;`
              : `in a component render function.`
          ),
          watcher.vm
        )
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  const activatedQueue = activatedChildren.slice()
  const updatedQueue = queue.slice()

  resetSchedulerState()

  callActivatedHooks(activatedQueue)
  callUpdatedHooks(updatedQueue)

  if (devtools &amp;&amp; config.devtools) {
    devtools.emit(&#39;flush&#39;)
  }
}
</code></pre><ol>
<li><p><code>queue.sort</code>进行了排序，源码已经有明确的注释表明含义了，大致就是：组件更新从父到子，所以执行也需要按照此顺序；</p>
</li>
<li><p>遍历<code>queue</code>，然后执行<code>watcher.run</code></p>
</li>
</ol>
<pre><code>run () {
  if (this.active) {
    const value = this.get()
    if (
      value !== this.value ||
      isObject(value) ||
      this.deep
    ) {

      const oldValue = this.value
      this.value = value
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue)
        } catch (e) {
          handleError(e, this.vm, `callback for watcher &quot;${this.expression}&quot;`)
        }
      } else {
        this.cb.call(this.vm, value, oldValue)
      }
    }
  }
}
</code></pre><p><code>run</code>方法执行了<code>get</code>去拿到当前的值，并且判断了新值旧值是否相等，是否是对象，是否deep为true，有一者满足的情况下会执行回调函数，并将新值，旧值做为参数。以及一些操作，清除Scheduler和触发<code>update</code>钩子等操作。</p>
<p>执行<code>get</code>方法时，会触发<code>getter</code>，也是前面提到的<code>expOrFn = updateComponent</code>重新<code>render</code>组件。</p>

      
       
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2019-2021 Jayant
</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class id="rocket"></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0"></script>

<script src="/js/script.js?v=1.1.0"></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
